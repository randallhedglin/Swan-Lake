{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f4\froman\fcharset0\fprq2{\*\panose 02020603060405020304}Times;}
{\f5\fswiss\fcharset0\fprq2{\*\panose 020b0604020202030204}Helvetica;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f7\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Geneva;}
{\f8\froman\fcharset0\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset0\fprq2{\*\panose 00000000000000000000}MS Serif;}
{\f11\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\froman\fcharset0\fprq2{\*\panose 00000000000000000000}New York;}{\f13\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}System;}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f15\froman\fcharset128\fprq1{\*\panose 00000000000000000000}Mincho{\*\falt ??};}{\f16\froman\fcharset129\fprq2{\*\panose 02030600000101010101}Batang{\*\falt ??};}
{\f17\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}SimSun{\*\falt ??};}{\f18\froman\fcharset136\fprq2{\*\panose 02020300000000000000}PMingLiU{\*\falt ????};}{\f19\fmodern\fcharset128\fprq1{\*\panose 00000000000000000000}Gothic{\*\falt ?????};}
{\f20\fmodern\fcharset129\fprq1{\*\panose 00000000000000000000}Dotum{\*\falt ??};}{\f21\fmodern\fcharset134\fprq1{\*\panose 00000000000000000000}SimHei{\*\falt ??};}{\f22\fmodern\fcharset136\fprq1{\*\panose 00000000000000000000}MingLiU{\*\falt ???};}
{\f23\fmodern\fcharset128\fprq1{\*\panose 02020609040205080304}MS Mincho{\*\falt MS ??};}{\f24\froman\fcharset129\fprq1{\*\panose 00000000000000000000}Gulim{\*\falt ??};}
{\f25\fmodern\fcharset128\fprq1{\*\panose 00000000000000000000}MS Gothic{\*\falt MS ????};}{\f26\froman\fcharset0\fprq2{\*\panose 02040604050505020304}Century;}{\f27\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}
{\f28\fnil\fcharset2\fprq2{\*\panose 00000000000000000000}Marlett;}{\f29\fmodern\fcharset0\fprq1{\*\panose 020b0609040504020204}Lucida Console;}{\f30\fswiss\fcharset0\fprq2{\*\panose 020b0602030504020204}Lucida Sans Unicode;}
{\f31\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f32\fswiss\fcharset0\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f33\fscript\fcharset0\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}
{\f34\fswiss\fcharset0\fprq2{\*\panose 020b0806030902050204}Impact;}{\f35\froman\fcharset0\fprq2{\*\panose 02040502050405020303}Georgia;}{\f36\fswiss\fcharset0\fprq2{\*\panose 020b0603020102020204}Franklin Gothic Medium;}
{\f37\froman\fcharset0\fprq2{\*\panose 02040502050505030304}Palatino Linotype;}{\f38\fswiss\fcharset0\fprq2{\*\panose 020b0603020202020204}Trebuchet MS;}{\f39\froman\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}
{\f40\fscript\fcharset0\fprq2 Estrangelo Edessa;}{\f41\fnil\fcharset0\fprq2 Gautami;}{\f42\fnil\fcharset0\fprq2 Latha;}{\f43\fnil\fcharset0\fprq2 Mangal;}{\f44\fnil\fcharset0\fprq2 MV Boli;}{\f45\fnil\fcharset0\fprq2 Raavi;}
{\f46\fnil\fcharset0\fprq2 Shruti;}{\f47\fnil\fcharset0\fprq2 Tunga;}{\f48\froman\fcharset0\fprq2{\*\panose 010a0502050306030303}Sylfaen;}{\f49\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Microsoft Sans Serif;}
{\f50\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f51\froman\fcharset0\fprq2{\*\panose 02040602050305030304}Book Antiqua;}{\f52\froman\fcharset0\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}
{\f53\fswiss\fcharset0\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f54\froman\fcharset0\fprq2{\*\panose 02020404030301010803}Garamond;}{\f55\fswiss\fcharset0\fprq2{\*\panose 020b0706040902060204}Haettenschweiler;}
{\f56\fscript\fcharset0\fprq2{\*\panose 03010101010201010101}Monotype Corsiva;}{\f57\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}MS Outlook;}{\f58\froman\fcharset2\fprq2{\*\panose 05020102010507070707}Wingdings 2;}
{\f59\froman\fcharset2\fprq2{\*\panose 05040102010807070707}Wingdings 3;}{\f60\froman\fcharset0\fprq2{\*\panose 02020500000000000000}WW Font;}{\f61\fswiss\fcharset0\fprq2{\*\panose 020be200000000000000}AHD Symbol Sans;}
{\f62\froman\fcharset0\fprq2{\*\panose 02027200000000000000}AHD Symbol;}{\f63\fswiss\fcharset0\fprq2{\*\panose 020b0607020203060204}BankGothic Lt BT;}{\f64\fswiss\fcharset0\fprq2{\*\panose 020b0807020203060204}BankGothic Md BT;}
{\f65\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}CityBlueprint;}{\f66\froman\fcharset2\fprq2{\*\panose 05020102010206080802}CommercialPi BT;}{\f67\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Complex;}
{\f68\fscript\fcharset0\fprq2{\*\panose 03030803040807090c04}CommercialScript BT;}{\f69\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}CountryBlueprint;}{\f70\froman\fcharset0\fprq2{\*\panose 02020603060505020304}Dutch801 Rm BT;}
{\f71\froman\fcharset0\fprq2{\*\panose 02020903060505020304}Dutch801 XBd BT;}{\f72\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}EuroRoman;}{\f73\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}GDT;}
{\f74\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}GothicI;}{\f75\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ISOCP;}{\f76\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ISOCP2;}
{\f77\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ISOCP3;}{\f78\fmodern\fcharset0\fprq1{\*\panose 00000409000000000000}ISOCT;}{\f79\fmodern\fcharset0\fprq1{\*\panose 00000409000000000000}ISOCT2;}
{\f80\fmodern\fcharset0\fprq1{\*\panose 00000409000000000000}ISOCT3;}{\f81\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Italic;}{\f82\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ItalicC;}
{\f83\fmodern\fcharset0\fprq1{\*\panose 020b0609020202020204}Monospac821 BT;}{\f84\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Monotxt;}{\f85\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 1;}
{\f86\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 2;}{\f87\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}PanRoman;}{\f88\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}Romantic;}
{\f89\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}RomanS;}{\f90\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}SansSerif;}{\f91\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ScriptC;}
{\f92\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ScriptS;}{\f93\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Simplex;}{\f94\fswiss\fcharset0\fprq2{\*\panose 020e0402020206020304}Stylus BT;}
{\f95\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}SuperFrench;}{\f96\fswiss\fcharset0\fprq2{\*\panose 020b0504020202020204}Swis721 BT;}{\f97\fdecor\fcharset0\fprq2{\*\panose 04020705020b03040203}Swis721 BdOul BT;}
{\f98\fswiss\fcharset0\fprq2{\*\panose 020b0506020202030204}Swis721 Cn BT;}{\f99\fdecor\fcharset0\fprq2{\*\panose 04020704030b03040203}Swis721 BdCnOul BT;}{\f100\fswiss\fcharset0\fprq2{\*\panose 020b0806030502040204}Swis721 BlkCn BT;}
{\f101\fswiss\fcharset0\fprq2{\*\panose 020b0406020202030204}Swis721 LtCn BT;}{\f102\fswiss\fcharset0\fprq2{\*\panose 020b0605020202020204}Swis721 Ex BT;}{\f103\fswiss\fcharset0\fprq2{\*\panose 020b0907040502030204}Swis721 BlkEx BT;}
{\f104\fswiss\fcharset0\fprq2{\*\panose 020b0505020202020204}Swis721 LtEx BT;}{\f105\fswiss\fcharset0\fprq2{\*\panose 020b0904030502020204}Swis721 Blk BT;}{\f106\fdecor\fcharset0\fprq2{\*\panose 04020905030b03040203}Swis721 BlkOul BT;}
{\f107\fswiss\fcharset0\fprq2{\*\panose 020b0403020202020204}Swis721 Lt BT;}{\f108\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}TechnicBold;}{\f109\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}TechnicLite;}
{\f110\fnil\fcharset2\fprq2{\*\panose 00000400000000000000}Technic;}{\f111\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Txt;}{\f112\froman\fcharset2\fprq2{\*\panose 05050102010205020602}UniversalMath1 BT;}
{\f113\fdecor\fcharset0\fprq2{\*\panose 04020906050602070202}Vineta BT;}{\f114\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}GothicE;}{\f115\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}GothicG;}
{\f116\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}GreekC;}{\f117\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}GreekS;}{\f118\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}ItalicT;}
{\f119\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}RomanC;}{\f120\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}RomanD;}{\f121\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}RomanT;}
{\f122\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Syastro;}{\f123\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Symap;}{\f124\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Symath;}
{\f125\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Symeteo;}{\f126\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Symusic;}{\f127\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 3;}
{\f128\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 4;}{\f129\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 5;}{\f130\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 6;}
{\f131\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 7;}{\f132\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 8;}{\f133\fnil\fcharset0\fprq2{\*\panose 00000400000000000000}Proxy 9;}
{\f134\fswiss\fcharset0\fprq2{\*\panose 020b0506030403020204}Myriad Condensed Web;}{\f135\fswiss\fcharset0\fprq2{\*\panose 020b0503030403020204}Myriad Web;}{\f136\fdecor\fcharset0\fprq2{\*\panose 04020705040a02060702}AlgerianD;}
{\f137\fdecor\fcharset0\fprq2{\*\panose 04040705040a02020702}AlgerianBasD;}{\f138\fswiss\fcharset0\fprq2{\*\panose 020b0306030101010103}Abadi MT Condensed Light;}{\f139\fnil\fcharset0\fprq2{\*\panose 01010101010101010101}Adolescence;}
{\f140\fnil\fcharset0\fprq2{\*\panose 00010606040000040003}Agency FB;}{\f141\fswiss\fcharset0\fprq2{\*\panose 020e0602030304020304}Albertus Medium;}{\f142\fswiss\fcharset0\fprq2{\*\panose 020e0802040304020204}Albertus Extra Bold;}
{\f143\fdecor\fcharset0\fprq2{\*\panose 04020705040a02060702}Algerian;}{\f144\fmodern\fcharset0\fprq1{\*\panose 020b0509000000000004}Andale Mono;}{\f145\fswiss\fcharset2\fprq2{\*\panose 020b0504020104020203}Andale Mono IPA;}
{\f146\fswiss\fcharset128\fprq2{\*\panose 020b0604020202020204}Arial Unicode MS;}{\f147\fswiss\fcharset128\fprq2{\*\panose 020b0604020202020204}@Arial Unicode MS;}{\f148\fswiss\fcharset0\fprq2{\*\panose 020f0704030504030204}Arial Rounded MT Bold;}
{\f149\fnil\fcharset178\fprq2{\*\panose 02010000000000000000}Arabic Transparent;}{\f150\fswiss\fcharset0\fprq2{\*\panose 020b0602020202020204}ITC Avant Garde Gothic;}
{\f151\fswiss\fcharset0\fprq2{\*\panose 020b0802020202020204}ITC Avant Garde Gothic Demi;}{\f152\fswiss\fcharset0\fprq2{\*\panose 020e0502060305020804}BibleScrT;}{\f153\fswiss\fcharset0\fprq2{\*\panose 020c0903060902020604}BinnerD;}
{\f154\fnil\fcharset0\fprq2{\*\panose 00000500000000000000}Bamboo;}{\f155\fswiss\fcharset0\fprq2{\*\panose 020b0804040403020303}Banjoman Open Bold;}{\f156\froman\fcharset0\fprq2{\*\panose 02020602080505020303}Baskerville Old Face;}
{\f157\froman\fcharset129\fprq2{\*\panose 02030600000101010101}@Batang;}{\f158\fdecor\fcharset0\fprq2{\*\panose 04030905020b02020c02}Bauhaus 93;}{\f159\froman\fcharset0\fprq2{\*\panose 02020503060305020303}Bell MT;}
{\f160\froman\fcharset0\fprq2{\*\panose 02050806060905020404}Bernard MT Condensed;}{\f161\fnil\fcharset0\fprq2{\*\panose 02000503000000000004}Bermuda Solid;}{\f162\froman\fcharset0\fprq2{\*\panose 02050604050505020204}ITC Bookman Light;}
{\f163\froman\fcharset0\fprq2{\*\panose 02050804040505020204}ITC Bookman Demi;}{\f164\fscript\fcharset0\fprq2{\*\panose 03070402050302030203}Bradley Hand ITC;}{\f165\fswiss\fcharset0\fprq2{\*\panose 020b0903060703020204}Britannic Bold;}
{\f166\fswiss\fcharset0\fprq2{\*\panose 020e0602020502020306}Berlin Sans FB;}{\f167\fswiss\fcharset0\fprq2{\*\panose 020e0802020502020306}Berlin Sans FB Demi;}{\f168\fdecor\fcharset0\fprq2{\*\panose 04040905080b02020502}Broadway;}
{\f169\fscript\fcharset0\fprq2{\*\panose 03060802040406070304}Brush Script MT;}{\f170\froman\fcharset0\fprq2{\*\panose 02060506040706070203}CityDLig;}{\f171\froman\fcharset0\fprq2{\*\panose 02060606040706070203}CityDMed;}
{\f172\froman\fcharset0\fprq2{\*\panose 02060406040706070204}CityDBol;}{\f173\froman\fcharset0\fprq2{\*\panose 0207040306080b030204}Californian FB;}{\f174\froman\fcharset0\fprq2{\*\panose 02040603050505030304}Calisto MT;}
{\f175\froman\fcharset0\fprq2{\*\panose 020a0402060406010301}Castellar;}{\f176\froman\fcharset0\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}{\f177\froman\fcharset0\fprq2{\*\panose 02030504050205020304}Centaur;}
{\f178\fswiss\fcharset0\fprq2{\*\panose 020b0502050508020304}CG Omega;}{\f179\froman\fcharset0\fprq2{\*\panose 02020603050405020304}CG Times;}{\f180\fscript\fcharset0\fprq2{\*\panose 03020702040403080804}ITC Zapf Chancery;}
{\f181\fdecor\fcharset0\fprq2{\*\panose 04020404031007020602}Chiller;}{\f182\froman\fcharset0\fprq2{\*\panose 02040706040705040204}Clarendon Condensed;}{\f183\fdecor\fcharset0\fprq2{\*\panose 04020805060202030203}Colonna MT;}
{\f184\froman\fcharset0\fprq2{\*\panose 0208090404030b020404}Cooper Black;}{\f185\fswiss\fcharset0\fprq2{\*\panose 020e0705020206020404}Copperplate Gothic Bold;}{\f186\fswiss\fcharset0\fprq2{\*\panose 020e0507020206020404}Copperplate Gothic Light;}
{\f187\fscript\fcharset0\fprq2{\*\panose 03030502040406070605}Coronet;}{\f188\fmodern\fcharset0\fprq1{\*\panose 02070609020205020404}CourierPS;}{\f189\fdecor\fcharset0\fprq2{\*\panose 04010502060101010303}Creepy;}
{\f190\fdecor\fcharset0\fprq2{\*\panose 04040404050702020202}Curlz MT;}{\f191\fnil\fcharset177\fprq2{\*\panose 00000000000000000000}David;}{\f192\fnil\fcharset177\fprq2{\*\panose 00000000000000000000}David Transparent;}
{\f193\froman\fcharset2\fprq2{\*\panose 05020102010704020609}ITC Zapf Dingbats;}{\f194\fdecor\fcharset0\fprq2{\*\panose 04040905080b02020802}EwieD;}{\f195\froman\fcharset0\fprq2{\*\panose 02020904090505020303}Elephant;}
{\f196\froman\fcharset0\fprq2{\*\panose 02090707080505020304}Engravers MT;}{\f197\fswiss\fcharset0\fprq2{\*\panose 020b0907030504020204}Eras Bold ITC;}{\f198\fswiss\fcharset0\fprq2{\*\panose 020b0805030504020804}Eras Demi ITC;}
{\f199\fswiss\fcharset0\fprq2{\*\panose 020c0804040000000001}EraserDust;}{\f200\fswiss\fcharset0\fprq2{\*\panose 020b0402030504020804}Eras Light ITC;}{\f201\fswiss\fcharset0\fprq2{\*\panose 020b0602030504020804}Eras Medium ITC;}
{\f202\fnil\fcharset0\fprq2{\*\panose 02000507000000000004}Falstaff Festival MT;}{\f203\fdecor\fcharset0\fprq2{\*\panose 04060505060202020a04}Felix Titling;}{\f204\fnil\fcharset0\fprq2{\*\panose 01010101010101010101}Figaro MT;}
{\f205\fscript\fcharset0\fprq2{\*\panose 03060902040502070203}Forte;}{\f206\fswiss\fcharset0\fprq2{\*\panose 020b0503020102020204}Franklin Gothic Book;}{\f207\fswiss\fcharset0\fprq2{\*\panose 020b0703020102020204}Franklin Gothic Demi;}
{\f208\fswiss\fcharset0\fprq2{\*\panose 020b0706030402020204}Franklin Gothic Demi Cond;}{\f209\fswiss\fcharset0\fprq2{\*\panose 020b0903020102020204}Franklin Gothic Heavy;}
{\f210\fswiss\fcharset0\fprq2{\*\panose 020b0606030402020204}Franklin Gothic Medium Cond;}{\f211\fscript\fcharset0\fprq2{\*\panose 030804020302050b0404}Freestyle Script;}{\f212\fscript\fcharset0\fprq2{\*\panose 03020402040607040605}French Script MT;}
{\f213\froman\fcharset0\fprq2{\*\panose 02020302060204020203}Footlight MT Light;}{\f214\fswiss\fcharset0\fprq2{\*\panose 020b0703020203020301}GlaserSteD;}{\f215\fdecor\fcharset0\fprq2{\*\panose 04040504061007020d02}Gigi;}
{\f216\fswiss\fcharset0\fprq2{\*\panose 020b0502020104020203}Gill Sans MT;}{\f217\fswiss\fcharset0\fprq2{\*\panose 020b0506020104020203}Gill Sans MT Condensed;}{\f218\fswiss\fcharset0\fprq2{\*\panose 020b0a06020104020203}Gill Sans Ultra Bold Condensed;}
{\f219\fswiss\fcharset0\fprq2{\*\panose 020b0a02020104020203}Gill Sans Ultra Bold;}{\f220\froman\fcharset0\fprq2{\*\panose 02030808020601010101}Gloucester MT Extra Condensed;}
{\f221\fswiss\fcharset0\fprq2{\*\panose 020b0902020104020203}Gill Sans MT Ext Condensed Bold;}{\f222\froman\fcharset0\fprq2{\*\panose 02020502050305020303}Goudy Old Style;}{\f223\froman\fcharset0\fprq2{\*\panose 0202090407030b020401}Goudy Stout;}
{\f224\fdecor\fcharset0\fprq2{\*\panose 04020704020802060204}HorndonD;}{\f225\fdecor\fcharset0\fprq2{\*\panose 04030604020f02020d02}Harlow Solid Italic;}{\f226\fdecor\fcharset0\fprq2{\*\panose 04040505050a02020702}Harrington;}
{\f227\fswiss\fcharset0\fprq2{\*\panose 020b0606020202030204}Helvetica Narrow;}{\f228\froman\fcharset0\fprq2{\*\panose 02040502050506030303}High Tower Text;}{\f229\fswiss\fcharset0\fprq2{\*\panose 020b7200000000000000}IGES 1001;}
{\f230\fswiss\fcharset0\fprq2{\*\panose 020b7200000000000000}IGES 1002;}{\f231\fswiss\fcharset0\fprq2{\*\panose 020b7200000000000000}IGES 1003;}{\f232\fdecor\fcharset0\fprq2{\*\panose 04020605060303030202}Imprint MT Shadow;}
{\f233\fscript\fcharset0\fprq2{\*\panose 030604020304060b0204}Informal Roman;}{\f234\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}ISOCPEUR;}{\f235\fmodern\fcharset0\fprq1{\*\panose 020b0609020202020204}ISOCTEUR;}
{\f236\fdecor\fcharset0\fprq2{\*\panose 04020505051007020d02}Blackadder ITC;}{\f237\fscript\fcharset0\fprq2{\*\panose 030303020407070d0804}Edwardian Script ITC;}{\f238\fscript\fcharset0\fprq2{\*\panose 03050502040202030202}Kristen ITC;}
{\f239\fdecor\fcharset0\fprq2{\*\panose 04090605060d06020702}Jokerman;}{\f240\fdecor\fcharset0\fprq2{\*\panose 04040403040a02020202}Juice ITC;}{\f241\fscript\fcharset0\fprq2{\*\panose 03050502040202020203}Kids;}
{\f242\fnil\fcharset0\fprq2{\*\panose 01010101010101010101}KidTYPEPaint;}{\f243\fscript\fcharset0\fprq2{\*\panose 030304020206070d0d06}Kunstler Script;}{\f244\froman\fcharset0\fprq2{\*\panose 020a0a07050505020404}Wide Latin;}
{\f245\froman\fcharset0\fprq2{\*\panose 02040602050505020304}Lucida Bright;}{\f246\fmodern\fcharset0\fprq2{\*\panose 020b0509020102020204}Letter Gothic MT;}{\f247\fscript\fcharset0\fprq2{\*\panose 03010101010101010101}Lucida Calligraphy;}
{\f248\fmodern\fcharset0\fprq1{\*\panose 020b0409020202030204}Letter Gothic;}{\f249\froman\fcharset0\fprq2{\*\panose 02060602050505020204}Lucida Fax;}{\f250\fscript\fcharset0\fprq2{\*\panose 03010101010101010101}Lucida Handwriting;}
{\f251\fswiss\fcharset0\fprq2{\*\panose 020b0602030504020204}Lucida Sans;}{\f252\fmodern\fcharset0\fprq1{\*\panose 020b0509030504030204}Lucida Sans Typewriter;}{\f253\fscript\fcharset0\fprq2{\*\panose 03040802040508040804}MariageD;}
{\f254\fswiss\fcharset0\fprq2{\*\panose 020b0607030502060204}MicrogrammaDMedExt;}{\f255\fswiss\fcharset0\fprq2{\*\panose 020e0907030506060204}MicrogrammaDBolExt;}{\f256\fdecor\fcharset0\fprq2{\*\panose 04030805050802020d02}Magneto;}
{\f257\fswiss\fcharset0\fprq2{\*\panose 020e0502030308020204}Maiandra GD;}{\f258\froman\fcharset0\fprq2{\*\panose 00050102010706020507}Map Symbols;}{\f259\fscript\fcharset0\fprq2{\*\panose 03020702040402020504}Marigold;}
{\f260\fdecor\fcharset0\fprq2{\*\panose 04040403030d02020704}Matisse ITC;}{\f261\fscript\fcharset0\fprq2{\*\panose 03020802060602070202}Matura MT Script Capitals;}{\f262\fscript\fcharset0\fprq2{\*\panose 03090702030407020403}Mistral;}
{\f263\froman\fcharset0\fprq2{\*\panose 02070704070505020303}Modern No. 20;}{\f264\fnil\fcharset177\fprq2{\*\panose 00000000000000000000}Miriam;}{\f265\fmodern\fcharset177\fprq1{\*\panose 00000009000000000000}Miriam Fixed;}
{\f266\fmodern\fcharset177\fprq1{\*\panose 00000009000000000000}Fixed Miriam Transparent;}{\f267\fnil\fcharset177\fprq2{\*\panose 00000000000000000000}Miriam Transparent;}{\f268\fmodern\fcharset128\fprq1{\*\panose 02020609040205080304}@MS Mincho;}
{\f269\froman\fcharset2\fprq2{\*\panose 05050102010205020202}MT Extra;}{\f270\fdecor\fcharset0\fprq2{\*\panose 04030a07091002020d03}NevisonCasD;}{\f271\froman\fcharset0\fprq2{\*\panose 02040603050705020304}New Century Schoolbook;}
{\f272\fdecor\fcharset0\fprq2{\*\panose 04020502070703030202}Niagara Engraved;}{\f273\fdecor\fcharset0\fprq2{\*\panose 04020502070702020202}Niagara Solid;}{\f274\fswiss\fcharset0\fprq2{\*\panose 020b0504020203020204}News Gothic MT;}
{\f275\fmodern\fcharset0\fprq2{\*\panose 02010509020102010303}OCR A Extended;}{\f276\fscript\fcharset0\fprq2{\*\panose 03040902040508030806}Old English Text MT;}{\f277\fswiss\fcharset0\fprq2{\*\panose 020b0603020204030204}Antique Olive;}
{\f278\fdecor\fcharset0\fprq2{\*\panose 04050602080702020203}Onyx;}{\f279\fnil\fcharset0\fprq2{\*\panose 02000504000000000003}Orbus Multiserif;}{\f280\fnil\fcharset0\fprq2{\*\panose 02000306050000000002}Palace Script MT Semi Bold;}
{\f281\froman\fcharset0\fprq2{\*\panose 02040502050505030304}Palatino;}{\f282\fscript\fcharset0\fprq2{\*\panose 030303020206070c0b05}Palace Script MT;}{\f283\fscript\fcharset0\fprq2{\*\panose 03070502060502030205}Papyrus;}
{\f284\fscript\fcharset0\fprq2{\*\panose 03040602040708040804}Parchment;}{\f285\froman\fcharset0\fprq2{\*\panose 02020502060401020303}Perpetua;}{\f286\froman\fcharset0\fprq2{\*\panose 02020502060505020804}Perpetua Titling MT;}
{\f287\fdecor\fcharset0\fprq2{\*\panose 040506030a0602020202}Playbill;}{\f288\fswiss\fcharset0\fprq2{\*\panose 020b0904020202020204}Plump MT;}{\f289\froman\fcharset136\fprq2{\*\panose 02020300000000000000}@PMingLiU;}
{\f290\froman\fcharset0\fprq2{\*\panose 02080502050505020702}Poor Richard;}{\f291\fscript\fcharset0\fprq2{\*\panose 03060402040406080204}Pristina;}{\f292\fscript\fcharset0\fprq2{\*\panose 03070502040507070304}Rage Italic;}
{\f293\fdecor\fcharset0\fprq2{\*\panose 04040805050809020602}Ravie;}{\f294\froman\fcharset0\fprq2{\*\panose 02060603050405020104}Rockwell Condensed;}{\f295\froman\fcharset0\fprq2{\*\panose 02060603020205020403}Rockwell;}
{\f296\froman\fcharset0\fprq2{\*\panose 02060903040505020403}Rockwell Extra Bold;}{\f297\fmodern\fcharset177\fprq1{\*\panose 00000009000000000000}Rod;}{\f298\fscript\fcharset0\fprq2{\*\panose 03040602040607080904}Script MT Bold;}
{\f299\fswiss\fcharset0\fprq2{\*\panose 020b7200000000000000}Solid Edge ANSI;}{\f300\fswiss\fcharset0\fprq2{\*\panose 020b7200000000000000}Solid Edge ISO;}{\f301\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Solid Edge ANSI1 Symbols;}
{\f302\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Solid Edge ANSI2 Symbols;}{\f303\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Solid Edge ANSI3 Symbols;}{\f304\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Solid Edge ISO1 Symbols;}
{\f305\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Solid Edge ISO2 Symbols;}{\f306\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Solid Edge ISO3 Symbols;}{\f307\fdecor\fcharset0\fprq2{\*\panose 04020904020102020604}Showcard Gothic;}
{\f308\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}@SimSun;}{\f309\fdecor\fcharset0\fprq2{\*\panose 04040a07060a02020202}Snap ITC;}{\f310\fmodern\fcharset0\fprq2{\*\panose 02000509000000000005}Space Toaster;}
{\f311\fdecor\fcharset0\fprq2{\*\panose 040409050d0802020404}Stencil;}{\f312\froman\fcharset2\fprq2{\*\panose 05050102010607020607}SymbolPS;}{\f313\fswiss\fcharset0\fprq2{\*\panose 020b0602020104020603}Tw Cen MT;}
{\f314\fswiss\fcharset0\fprq2{\*\panose 020b0606020104020203}Tw Cen MT Condensed;}{\f315\fswiss\fcharset0\fprq2{\*\panose 020b0803020000000004}Tw Cen MT Condensed Extra Bold;}{\f316\fnil\fcharset0\fprq2{\*\panose 02000800000000000004}Team MT;}
{\f317\fscript\fcharset0\fprq2{\*\panose 03050502040202020b03}Technical;}{\f318\fdecor\fcharset0\fprq2{\*\panose 04020404030d07020202}Tempus Sans ITC;}{\f319\froman\fcharset0\fprq2{\*\panose 02020a06060301020303}Times New Roman MT Extra Bold;}
{\f320\fnil\fcharset178\fprq2{\*\panose 02010000000000000000}Traditional Arabic;}{\f321\fswiss\fcharset0\fprq2{\*\panose 020b0502050508020304}ZapfHumnst BT;}{\f322\froman\fcharset0\fprq2{\*\panose 02040502050505030904}ZapfCalligr BT;}
{\f323\froman\fcharset0\fprq2{\*\panose 02070603070706020303}Bodoni Bk BT;}{\f324\froman\fcharset0\fprq2{\*\panose 02070803080706090303}Bodoni Bd BT;}{\f325\froman\fcharset0\fprq2{\*\panose 0202060206050b020903}AmeriGarmnd BT;}
{\f326\fswiss\fcharset0\fprq2{\*\panose 020b0303020202020204}Swis721 Th BT;}{\f327\fswiss\fcharset0\fprq2{\*\panose 020b0804020202020204}Swis721 Hv BT;}{\f328\fswiss\fcharset0\fprq2{\*\panose 020b0708030702060204}Swiss911 XCm BT;}
{\f329\fswiss\fcharset0\fprq2{\*\panose 020b0608020202060204}Swiss911 UCm BT;}{\f330\fscript\fcharset0\fprq2{\*\panose 03060402020202060201}Balloon Lt BT;}{\f331\fdecor\fcharset0\fprq2{\*\panose 04040905080b02020502}Broadway BT;}
{\f332\fswiss\fcharset0\fprq2{\*\panose 020b0402020204020303}Futura Lt BT;}{\f333\fswiss\fcharset0\fprq2{\*\panose 020b0903020204020204}Futura XBlk BT;}{\f334\fswiss\fcharset0\fprq2{\*\panose 020b0903020204090204}Futura XBlkIt BT;}
{\f335\fdecor\fcharset0\fprq2{\*\panose 040b09050c0b02020804}Shotgun BT;}{\f336\fswiss\fcharset0\fprq2{\*\panose 020b0403020202030204}Zurich Lt BT;}{\f337\fswiss\fcharset0\fprq2{\*\panose 020b0603020202030204}Zurich BT;}
{\f338\fdecor\fcharset0\fprq2{\*\panose 040409050d0802020404}Stencil BT;}{\f339\fscript\fcharset0\fprq2{\*\panose 03060802040406070304}BrushScript BT;}{\f340\fswiss\fcharset0\fprq2{\*\panose 020b0408020204030204}Futura LtCn BT;}
{\f341\fswiss\fcharset0\fprq2{\*\panose 020b0806020204020204}Futura XBlkCn BT;}{\f342\fswiss\fcharset0\fprq2{\*\panose 020b0806020204090204}Futura XBlkCnIt BT;}{\f343\fdecor\fcharset0\fprq2{\*\panose 040409050d0b02020403}FuturaBlack BT;}
{\f344\fscript\fcharset0\fprq2{\*\panose 03040702020708020505}AmericanText BT;}{\f345\fdecor\fcharset0\fprq2{\*\panose 040b09050c0b03040804}ShotgunBlanks BT;}{\f346\fswiss\fcharset0\fprq2{\*\panose 020b0504020202060204}Square721 BT;}
{\f347\fswiss\fcharset0\fprq2{\*\panose 020b0806030502060204}Square721 Cn BT;}{\f348\fswiss\fcharset0\fprq2{\*\panose 020b0907040502030204}Zurich UBlkEx BT;}{\f349\froman\fcharset0\fprq2{\*\panose 02040706040505040204}Humanst521 Lt BT;}
{\f350\fswiss\fcharset0\fprq2{\*\panose 020b0602020204020204}Humanst521 BT;}{\f351\fswiss\fcharset0\fprq2{\*\panose 020b0902020204020204}Humanst521 XBd BT;}{\f352\fswiss\fcharset0\fprq2{\*\panose 020b0a03020203020204}Humanst521 UBd BT;}
{\f353\fswiss\fcharset0\fprq2{\*\panose 020b0506020202040204}Zurich Cn BT;}{\f354\froman\fcharset0\fprq2{\*\panose 02060403020205020403}GeoSlab703 Lt BT;}{\f355\froman\fcharset0\fprq2{\*\panose 02060603020205020403}GeoSlab703 Md BT;}
{\f356\fmodern\fcharset2\fprq1{\*\panose 020f0509020204020304}OCR-A BT;}{\f357\froman\fcharset0\fprq2{\*\panose 02060506020206060203}SquareSlab711 Lt BT;}{\f358\froman\fcharset0\fprq2{\*\panose 02060806030906060203}SquareSlab711 Bd BT;}
{\f359\fswiss\fcharset0\fprq2{\*\panose 020e0605020203020404}CopprplGoth BT;}{\f360\fswiss\fcharset0\fprq2{\*\panose 020e0907030503020404}CopprplGoth Hv BT;}{\f361\fswiss\fcharset0\fprq2{\*\panose 020e0704020203020404}CopprplGoth BdCn BT;}
{\f362\fswiss\fcharset0\fprq2{\*\panose 020b0506020204030204}Humanst521 Cn BT;}{\f363\fswiss\fcharset0\fprq2{\*\panose 020b0906030504020204}Humanst521 XBdCn BT;}{\f364\fswiss\fcharset0\fprq2{\*\panose 020b0608020202050204}AlternateGothic2 BT;}
{\f365\fswiss\fcharset0\fprq2{\*\panose 020b0806030502050204}Swiss921 BT;}{\f366\fscript\fcharset0\fprq2{\*\panose 03060902030302020204}DomCasual BT;}{\f367\fmodern\fcharset2\fprq1{\*\panose 020b0609020202020204}OCR-B-10 BT;}
{\f368\fscript\fcharset0\fprq2{\*\panose 03060702020302060201}Balloon Bd BT;}{\f369\fscript\fcharset0\fprq2{\*\panose 03060902030402060201}Balloon XBd BT;}{\f370\fswiss\fcharset0\fprq2{\*\panose 020f0702020204020204}VAGRounded BT;}
{\f371\fscript\fcharset0\fprq2{\*\panose 03040802040608030504}CloisterBlack BT;}{\f372\fscript\fcharset0\fprq2{\*\panose 03060902030202020203}DomBold BT;}{\f373\fdecor\fcharset0\fprq2{\*\panose 04040905090b02050503}BroadwayEngraved BT;}
{\f374\fswiss\fcharset0\fprq2{\*\panose 020f0806020204040204}Gothic821 Cn BT;}{\f375\fscript\fcharset0\fprq2{\*\panose 03060802030302060203}DomDiagonal BT;}{\f376\fscript\fcharset0\fprq2{\*\panose 03060902030202060203}DomDiagonal Bd BT;}
{\f377\fswiss\fcharset0\fprq2{\*\panose 020b0608020202060204}Swiss924 BT;}{\f378\froman\fcharset0\fprq2{\*\panose 02070706070706020303}Bodoni BdCn BT;}{\f379\fscript\fcharset0\fprq2{\*\panose 03040702040608040804}WeddingText BT;}
{\f380\froman\fcharset0\fprq2{\*\panose 02060506020205050403}GeoSlab703 MdCn BT;}{\f381\fswiss\fcharset0\fprq2{\*\panose 020b0706020207050204}Aurora BdCn BT;}{\f382\fdecor\fcharset0\fprq2{\*\panose 04040805040b02020603}AdLib BT;}
{\f383\fscript\fcharset0\fprq2{\*\panose 03080702020302020206}OzHandicraft BT;}{\f384\fscript\fcharset0\fprq2{\*\panose 03080802020302020203}MisterEarl BT;}{\f385\fdecor\fcharset0\fprq2{\*\panose 04040807060d02020704}Bremen Bd BT;}
{\f386\fdecor\fcharset0\fprq2{\*\panose 04040b07060d02020704}Bremen Blk BT;}{\f387\fnil\fcharset0\fprq2{\*\panose 02000702030000020004}Twentieth Century Poster1;}{\f388\fswiss\fcharset0\fprq2{\*\panose 020b0603020202030204}Univers;}
{\f389\fswiss\fcharset0\fprq2{\*\panose 020b0606020202060204}Univers Condensed;}{\f390\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Verdana Ref;}{\f391\fscript\fcharset0\fprq2{\*\panose 03070502030502020203}Viner Hand ITC;}
{\f392\fscript\fcharset0\fprq2{\*\panose 03020602050506090804}Vivaldi;}{\f393\fscript\fcharset0\fprq2{\*\panose 03050402040407070305}Vladimir Script;}{\f394\fscript\fcharset0\fprq2{\*\panose 03010101010101010101}Wendy Medium;}
{\f395\fdecor\fcharset0\fprq2{\*\panose 04040506030f02020702}Westminster;}{\f396\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Jokerman LET;}{\f397\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}John Handy LET;}
{\f398\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Orange LET;}{\f399\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Academy Engraved LET;}{\f400\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}University Roman LET;}
{\f401\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Victorian LET;}{\f402\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Milano LET;}{\f403\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Smudger LET;}
{\f404\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Westwood LET;}{\f405\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Ruach LET;}{\f406\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Rage Italic LET;}
{\f407\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}La Bamba LET;}{\f408\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Quixley LET;}{\f409\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Pump Demi Bold LET;}
{\f410\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Tiranti Solid LET;}{\f411\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Mekanik LET;}{\f412\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}One Stroke Script LET;}
{\f413\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Highlight LET;}{\f414\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Odessa LET;}{\f415\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Scruff LET;}
{\f416\fscript\fcharset0\fprq2{\*\panose 03020602050506080705}ParkAvenue BT;}{\f417\fscript\fcharset0\fprq2{\*\panose 03090702030407020403}Staccato222 BT;}{\f418\fscript\fcharset0\fprq2{\*\panose 03020802040502060804}Cataneo BT;}
{\f419\fscript\fcharset0\fprq2{\*\panose 03040802020608040804}Blackletter686 BT;}{\f420\fscript\fcharset0\fprq2{\*\panose 03060702050402020204}Calligraph421 BT;}{\f421\fdecor\fcharset0\fprq2{\*\panose 04080805060107010802}OldDreadfulNo7 BT;}
{\f422\fswiss\fcharset2\fprq2{\*\panose 050c0102010209020202}HolidayPi BT;}{\f423\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}Jokerman Alts LET;}{\f424\fnil\fcharset0\fprq2{\*\panose 00000000000000000000}University Roman Alts LET;}
{\f425\froman\fcharset238\fprq2 Times New Roman CE;}{\f426\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f428\froman\fcharset161\fprq2 Times New Roman Greek;}{\f429\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f430\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f431\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f432\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f433\fswiss\fcharset238\fprq2 Arial CE;}
{\f434\fswiss\fcharset204\fprq2 Arial Cyr;}{\f436\fswiss\fcharset161\fprq2 Arial Greek;}{\f437\fswiss\fcharset162\fprq2 Arial Tur;}{\f438\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f439\fswiss\fcharset178\fprq2 Arial (Arabic);}
{\f440\fswiss\fcharset186\fprq2 Arial Baltic;}{\f441\fmodern\fcharset238\fprq1 Courier New CE;}{\f442\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f444\fmodern\fcharset161\fprq1 Courier New Greek;}{\f445\fmodern\fcharset162\fprq1 Courier New Tur;}
{\f446\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f447\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f448\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f457\froman\fcharset238\fprq2 Times CE;}{\f461\froman\fcharset162\fprq2 Times Tur;}
{\f464\froman\fcharset186\fprq2 Times Baltic;}{\f465\fswiss\fcharset238\fprq2 Helvetica CE;}{\f469\fswiss\fcharset162\fprq2 Helvetica Tur;}{\f472\fswiss\fcharset186\fprq2 Helvetica Baltic;}{\f555\froman\fcharset0\fprq2 Batang Western{\*\falt ??};}
{\f553\froman\fcharset238\fprq2 Batang CE{\*\falt ??};}{\f554\froman\fcharset204\fprq2 Batang Cyr{\*\falt ??};}{\f556\froman\fcharset161\fprq2 Batang Greek{\*\falt ??};}{\f557\froman\fcharset162\fprq2 Batang Tur{\*\falt ??};}
{\f560\froman\fcharset186\fprq2 Batang Baltic{\*\falt ??};}{\f563\fnil\fcharset0\fprq2 SimSun Western{\*\falt ??};}{\f571\froman\fcharset0\fprq2 PMingLiU Western{\*\falt ????};}{\f611\fmodern\fcharset0\fprq1 MS Mincho Western{\*\falt MS ??};}
{\f609\fmodern\fcharset238\fprq1 MS Mincho CE{\*\falt MS ??};}{\f610\fmodern\fcharset204\fprq1 MS Mincho Cyr{\*\falt MS ??};}{\f612\fmodern\fcharset161\fprq1 MS Mincho Greek{\*\falt MS ??};}{\f613\fmodern\fcharset162\fprq1 MS Mincho Tur{\*\falt MS ??};}
{\f616\fmodern\fcharset186\fprq1 MS Mincho Baltic{\*\falt MS ??};}{\f633\froman\fcharset238\fprq2 Century CE;}{\f634\froman\fcharset204\fprq2 Century Cyr;}{\f636\froman\fcharset161\fprq2 Century Greek;}{\f637\froman\fcharset162\fprq2 Century Tur;}
{\f640\froman\fcharset186\fprq2 Century Baltic;}{\f641\fswiss\fcharset238\fprq2 Tahoma CE;}{\f642\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f644\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f645\fswiss\fcharset162\fprq2 Tahoma Tur;}
{\f646\fswiss\fcharset177\fprq2 Tahoma (Hebrew);}{\f647\fswiss\fcharset178\fprq2 Tahoma (Arabic);}{\f648\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f657\fmodern\fcharset238\fprq1 Lucida Console CE;}{\f658\fmodern\fcharset204\fprq1 Lucida Console Cyr;}
{\f660\fmodern\fcharset161\fprq1 Lucida Console Greek;}{\f661\fmodern\fcharset162\fprq1 Lucida Console Tur;}{\f665\fswiss\fcharset238\fprq2 Lucida Sans Unicode CE;}{\f666\fswiss\fcharset204\fprq2 Lucida Sans Unicode Cyr;}
{\f668\fswiss\fcharset161\fprq2 Lucida Sans Unicode Greek;}{\f669\fswiss\fcharset162\fprq2 Lucida Sans Unicode Tur;}{\f670\fswiss\fcharset177\fprq2 Lucida Sans Unicode (Hebrew);}{\f673\fswiss\fcharset238\fprq2 Verdana CE;}
{\f674\fswiss\fcharset204\fprq2 Verdana Cyr;}{\f676\fswiss\fcharset161\fprq2 Verdana Greek;}{\f677\fswiss\fcharset162\fprq2 Verdana Tur;}{\f680\fswiss\fcharset186\fprq2 Verdana Baltic;}{\f681\fswiss\fcharset238\fprq2 Arial Black CE;}
{\f682\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f684\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f685\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f688\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f689\fscript\fcharset238\fprq2 Comic Sans MS CE;}
{\f690\fscript\fcharset204\fprq2 Comic Sans MS Cyr;}{\f692\fscript\fcharset161\fprq2 Comic Sans MS Greek;}{\f693\fscript\fcharset162\fprq2 Comic Sans MS Tur;}{\f696\fscript\fcharset186\fprq2 Comic Sans MS Baltic;}
{\f697\fswiss\fcharset238\fprq2 Impact CE;}{\f698\fswiss\fcharset204\fprq2 Impact Cyr;}{\f700\fswiss\fcharset161\fprq2 Impact Greek;}{\f701\fswiss\fcharset162\fprq2 Impact Tur;}{\f704\fswiss\fcharset186\fprq2 Impact Baltic;}
{\f705\froman\fcharset238\fprq2 Georgia CE;}{\f706\froman\fcharset204\fprq2 Georgia Cyr;}{\f708\froman\fcharset161\fprq2 Georgia Greek;}{\f709\froman\fcharset162\fprq2 Georgia Tur;}{\f712\froman\fcharset186\fprq2 Georgia Baltic;}
{\f713\fswiss\fcharset238\fprq2 Franklin Gothic Medium CE;}{\f714\fswiss\fcharset204\fprq2 Franklin Gothic Medium Cyr;}{\f716\fswiss\fcharset161\fprq2 Franklin Gothic Medium Greek;}{\f717\fswiss\fcharset162\fprq2 Franklin Gothic Medium Tur;}
{\f720\fswiss\fcharset186\fprq2 Franklin Gothic Medium Baltic;}{\f721\froman\fcharset238\fprq2 Palatino Linotype CE;}{\f722\froman\fcharset204\fprq2 Palatino Linotype Cyr;}{\f724\froman\fcharset161\fprq2 Palatino Linotype Greek;}
{\f725\froman\fcharset162\fprq2 Palatino Linotype Tur;}{\f728\froman\fcharset186\fprq2 Palatino Linotype Baltic;}{\f729\fswiss\fcharset238\fprq2 Trebuchet MS CE;}{\f730\fswiss\fcharset204\fprq2 Trebuchet MS Cyr;}
{\f732\fswiss\fcharset161\fprq2 Trebuchet MS Greek;}{\f733\fswiss\fcharset162\fprq2 Trebuchet MS Tur;}{\f736\fswiss\fcharset186\fprq2 Trebuchet MS Baltic;}{\f809\froman\fcharset238\fprq2 Sylfaen CE;}{\f810\froman\fcharset204\fprq2 Sylfaen Cyr;}
{\f812\froman\fcharset161\fprq2 Sylfaen Greek;}{\f813\froman\fcharset162\fprq2 Sylfaen Tur;}{\f816\froman\fcharset186\fprq2 Sylfaen Baltic;}{\f817\fswiss\fcharset238\fprq2 Microsoft Sans Serif CE;}{\f818\fswiss\fcharset204\fprq2 Microsoft Sans Serif Cyr;}
{\f820\fswiss\fcharset161\fprq2 Microsoft Sans Serif Greek;}{\f821\fswiss\fcharset162\fprq2 Microsoft Sans Serif Tur;}{\f822\fswiss\fcharset177\fprq2 Microsoft Sans Serif (Hebrew);}{\f823\fswiss\fcharset178\fprq2 Microsoft Sans Serif (Arabic);}
{\f824\fswiss\fcharset186\fprq2 Microsoft Sans Serif Baltic;}{\f825\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f826\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f828\fswiss\fcharset161\fprq2 Arial Narrow Greek;}
{\f829\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f832\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f833\froman\fcharset238\fprq2 Book Antiqua CE;}{\f834\froman\fcharset204\fprq2 Book Antiqua Cyr;}{\f836\froman\fcharset161\fprq2 Book Antiqua Greek;}
{\f837\froman\fcharset162\fprq2 Book Antiqua Tur;}{\f840\froman\fcharset186\fprq2 Book Antiqua Baltic;}{\f841\froman\fcharset238\fprq2 Bookman Old Style CE;}{\f842\froman\fcharset204\fprq2 Bookman Old Style Cyr;}
{\f844\froman\fcharset161\fprq2 Bookman Old Style Greek;}{\f845\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f848\froman\fcharset186\fprq2 Bookman Old Style Baltic;}{\f849\fswiss\fcharset238\fprq2 Century Gothic CE;}
{\f850\fswiss\fcharset204\fprq2 Century Gothic Cyr;}{\f852\fswiss\fcharset161\fprq2 Century Gothic Greek;}{\f853\fswiss\fcharset162\fprq2 Century Gothic Tur;}{\f856\fswiss\fcharset186\fprq2 Century Gothic Baltic;}
{\f857\froman\fcharset238\fprq2 Garamond CE;}{\f858\froman\fcharset204\fprq2 Garamond Cyr;}{\f860\froman\fcharset161\fprq2 Garamond Greek;}{\f861\froman\fcharset162\fprq2 Garamond Tur;}{\f864\froman\fcharset186\fprq2 Garamond Baltic;}
{\f865\fswiss\fcharset238\fprq2 Haettenschweiler CE;}{\f866\fswiss\fcharset204\fprq2 Haettenschweiler Cyr;}{\f868\fswiss\fcharset161\fprq2 Haettenschweiler Greek;}{\f869\fswiss\fcharset162\fprq2 Haettenschweiler Tur;}
{\f872\fswiss\fcharset186\fprq2 Haettenschweiler Baltic;}{\f873\fscript\fcharset238\fprq2 Monotype Corsiva CE;}{\f874\fscript\fcharset204\fprq2 Monotype Corsiva Cyr;}{\f876\fscript\fcharset161\fprq2 Monotype Corsiva Greek;}
{\f877\fscript\fcharset162\fprq2 Monotype Corsiva Tur;}{\f880\fscript\fcharset186\fprq2 Monotype Corsiva Baltic;}{\f905\froman\fcharset238\fprq2 WW Font CE;}{\f909\froman\fcharset162\fprq2 WW Font Tur;}{\f929\fswiss\fcharset238\fprq2 BankGothic Lt BT CE;}
{\f932\fswiss\fcharset161\fprq2 BankGothic Lt BT Greek;}{\f933\fswiss\fcharset162\fprq2 BankGothic Lt BT Tur;}{\f937\fswiss\fcharset238\fprq2 BankGothic Md BT CE;}{\f940\fswiss\fcharset161\fprq2 BankGothic Md BT Greek;}
{\f941\fswiss\fcharset162\fprq2 BankGothic Md BT Tur;}{\f961\fnil\fcharset238\fprq2 Complex CE;}{\f962\fnil\fcharset204\fprq2 Complex Cyr;}{\f964\fnil\fcharset161\fprq2 Complex Greek;}{\f969\fscript\fcharset238\fprq2 CommercialScript BT CE;}
{\f972\fscript\fcharset161\fprq2 CommercialScript BT Greek;}{\f973\fscript\fcharset162\fprq2 CommercialScript BT Tur;}{\f985\froman\fcharset238\fprq2 Dutch801 Rm BT CE;}{\f988\froman\fcharset161\fprq2 Dutch801 Rm BT Greek;}
{\f989\froman\fcharset162\fprq2 Dutch801 Rm BT Tur;}{\f993\froman\fcharset238\fprq2 Dutch801 XBd BT CE;}{\f996\froman\fcharset161\fprq2 Dutch801 XBd BT Greek;}{\f997\froman\fcharset162\fprq2 Dutch801 XBd BT Tur;}{\f1017\fnil\fcharset238\fprq2 GothicI CE;}
{\f1018\fnil\fcharset204\fprq2 GothicI Cyr;}{\f1020\fnil\fcharset161\fprq2 GothicI Greek;}{\f1073\fnil\fcharset238\fprq2 Italic CE;}{\f1074\fnil\fcharset204\fprq2 Italic Cyr;}{\f1076\fnil\fcharset161\fprq2 Italic Greek;}
{\f1081\fnil\fcharset238\fprq2 ItalicC CE;}{\f1082\fnil\fcharset204\fprq2 ItalicC Cyr;}{\f1084\fnil\fcharset161\fprq2 ItalicC Greek;}{\f1089\fmodern\fcharset238\fprq1 Monospac821 BT CE;}{\f1092\fmodern\fcharset161\fprq1 Monospac821 BT Greek;}
{\f1093\fmodern\fcharset162\fprq1 Monospac821 BT Tur;}{\f1097\fnil\fcharset238\fprq2 Monotxt CE;}{\f1098\fnil\fcharset204\fprq2 Monotxt Cyr;}{\f1100\fnil\fcharset161\fprq2 Monotxt Greek;}{\f1137\fnil\fcharset238\fprq2 RomanS CE;}
{\f1138\fnil\fcharset204\fprq2 RomanS Cyr;}{\f1140\fnil\fcharset161\fprq2 RomanS Greek;}{\f1153\fnil\fcharset238\fprq2 ScriptC CE;}{\f1154\fnil\fcharset204\fprq2 ScriptC Cyr;}{\f1156\fnil\fcharset161\fprq2 ScriptC Greek;}
{\f1161\fnil\fcharset238\fprq2 ScriptS CE;}{\f1162\fnil\fcharset204\fprq2 ScriptS Cyr;}{\f1164\fnil\fcharset161\fprq2 ScriptS Greek;}{\f1169\fnil\fcharset238\fprq2 Simplex CE;}{\f1170\fnil\fcharset204\fprq2 Simplex Cyr;}
{\f1172\fnil\fcharset161\fprq2 Simplex Greek;}{\f1177\fswiss\fcharset238\fprq2 Stylus BT CE;}{\f1180\fswiss\fcharset161\fprq2 Stylus BT Greek;}{\f1181\fswiss\fcharset162\fprq2 Stylus BT Tur;}{\f1193\fswiss\fcharset238\fprq2 Swis721 BT CE;}
{\f1196\fswiss\fcharset161\fprq2 Swis721 BT Greek;}{\f1197\fswiss\fcharset162\fprq2 Swis721 BT Tur;}{\f1201\fdecor\fcharset238\fprq2 Swis721 BdOul BT CE;}{\f1204\fdecor\fcharset161\fprq2 Swis721 BdOul BT Greek;}
{\f1205\fdecor\fcharset162\fprq2 Swis721 BdOul BT Tur;}{\f1209\fswiss\fcharset238\fprq2 Swis721 Cn BT CE;}{\f1212\fswiss\fcharset161\fprq2 Swis721 Cn BT Greek;}{\f1213\fswiss\fcharset162\fprq2 Swis721 Cn BT Tur;}
{\f1217\fdecor\fcharset238\fprq2 Swis721 BdCnOul BT CE;}{\f1220\fdecor\fcharset161\fprq2 Swis721 BdCnOul BT Greek;}{\f1221\fdecor\fcharset162\fprq2 Swis721 BdCnOul BT Tur;}{\f1225\fswiss\fcharset238\fprq2 Swis721 BlkCn BT CE;}
{\f1228\fswiss\fcharset161\fprq2 Swis721 BlkCn BT Greek;}{\f1229\fswiss\fcharset162\fprq2 Swis721 BlkCn BT Tur;}{\f1233\fswiss\fcharset238\fprq2 Swis721 LtCn BT CE;}{\f1236\fswiss\fcharset161\fprq2 Swis721 LtCn BT Greek;}
{\f1237\fswiss\fcharset162\fprq2 Swis721 LtCn BT Tur;}{\f1241\fswiss\fcharset238\fprq2 Swis721 Ex BT CE;}{\f1244\fswiss\fcharset161\fprq2 Swis721 Ex BT Greek;}{\f1245\fswiss\fcharset162\fprq2 Swis721 Ex BT Tur;}
{\f1249\fswiss\fcharset238\fprq2 Swis721 BlkEx BT CE;}{\f1252\fswiss\fcharset161\fprq2 Swis721 BlkEx BT Greek;}{\f1253\fswiss\fcharset162\fprq2 Swis721 BlkEx BT Tur;}{\f1257\fswiss\fcharset238\fprq2 Swis721 LtEx BT CE;}
{\f1260\fswiss\fcharset161\fprq2 Swis721 LtEx BT Greek;}{\f1261\fswiss\fcharset162\fprq2 Swis721 LtEx BT Tur;}{\f1265\fswiss\fcharset238\fprq2 Swis721 Blk BT CE;}{\f1268\fswiss\fcharset161\fprq2 Swis721 Blk BT Greek;}
{\f1269\fswiss\fcharset162\fprq2 Swis721 Blk BT Tur;}{\f1273\fdecor\fcharset238\fprq2 Swis721 BlkOul BT CE;}{\f1276\fdecor\fcharset161\fprq2 Swis721 BlkOul BT Greek;}{\f1277\fdecor\fcharset162\fprq2 Swis721 BlkOul BT Tur;}
{\f1281\fswiss\fcharset238\fprq2 Swis721 Lt BT CE;}{\f1284\fswiss\fcharset161\fprq2 Swis721 Lt BT Greek;}{\f1285\fswiss\fcharset162\fprq2 Swis721 Lt BT Tur;}{\f1313\fnil\fcharset238\fprq2 Txt CE;}{\f1314\fnil\fcharset204\fprq2 Txt Cyr;}
{\f1316\fnil\fcharset161\fprq2 Txt Greek;}{\f1329\fdecor\fcharset238\fprq2 Vineta BT CE;}{\f1332\fdecor\fcharset161\fprq2 Vineta BT Greek;}{\f1333\fdecor\fcharset162\fprq2 Vineta BT Tur;}{\f1337\fnil\fcharset238\fprq2 GothicE CE;}
{\f1338\fnil\fcharset204\fprq2 GothicE Cyr;}{\f1340\fnil\fcharset161\fprq2 GothicE Greek;}{\f1346\fnil\fcharset204\fprq2 GothicG Cyr;}{\f1348\fnil\fcharset161\fprq2 GothicG Greek;}{\f1356\fnil\fcharset161\fprq2 GreekC Greek;}
{\f1364\fnil\fcharset161\fprq2 GreekS Greek;}{\f1369\fnil\fcharset238\fprq2 ItalicT CE;}{\f1370\fnil\fcharset204\fprq2 ItalicT Cyr;}{\f1372\fnil\fcharset161\fprq2 ItalicT Greek;}{\f1377\fnil\fcharset238\fprq2 RomanC CE;}
{\f1378\fnil\fcharset204\fprq2 RomanC Cyr;}{\f1380\fnil\fcharset161\fprq2 RomanC Greek;}{\f1385\fnil\fcharset238\fprq2 RomanD CE;}{\f1386\fnil\fcharset204\fprq2 RomanD Cyr;}{\f1388\fnil\fcharset161\fprq2 RomanD Greek;}
{\f1393\fnil\fcharset238\fprq2 RomanT CE;}{\f1394\fnil\fcharset204\fprq2 RomanT Cyr;}{\f1396\fnil\fcharset161\fprq2 RomanT Greek;}{\f1497\fswiss\fcharset238\fprq2 Myriad Condensed Web CE;}{\f1501\fswiss\fcharset162\fprq2 Myriad Condensed Web Tur;}
{\f1504\fswiss\fcharset186\fprq2 Myriad Condensed Web Baltic;}{\f1505\fswiss\fcharset238\fprq2 Myriad Web CE;}{\f1509\fswiss\fcharset162\fprq2 Myriad Web Tur;}{\f1512\fswiss\fcharset186\fprq2 Myriad Web Baltic;}
{\f1513\fdecor\fcharset238\fprq2 AlgerianD CE;}{\f1517\fdecor\fcharset162\fprq2 AlgerianD Tur;}{\f1521\fdecor\fcharset238\fprq2 AlgerianBasD CE;}{\f1525\fdecor\fcharset162\fprq2 AlgerianBasD Tur;}{\f1553\fswiss\fcharset238\fprq2 Albertus Medium CE;}
{\f1557\fswiss\fcharset162\fprq2 Albertus Medium Tur;}{\f1560\fswiss\fcharset186\fprq2 Albertus Medium Baltic;}{\f1561\fswiss\fcharset238\fprq2 Albertus Extra Bold CE;}{\f1565\fswiss\fcharset162\fprq2 Albertus Extra Bold Tur;}
{\f1568\fswiss\fcharset186\fprq2 Albertus Extra Bold Baltic;}{\f1577\fmodern\fcharset238\fprq1 Andale Mono CE;}{\f1578\fmodern\fcharset204\fprq1 Andale Mono Cyr;}{\f1580\fmodern\fcharset161\fprq1 Andale Mono Greek;}
{\f1581\fmodern\fcharset162\fprq1 Andale Mono Tur;}{\f1584\fmodern\fcharset186\fprq1 Andale Mono Baltic;}{\f1595\fswiss\fcharset0\fprq2 Arial Unicode MS Western;}{\f1593\fswiss\fcharset238\fprq2 Arial Unicode MS CE;}
{\f1594\fswiss\fcharset204\fprq2 Arial Unicode MS Cyr;}{\f1596\fswiss\fcharset161\fprq2 Arial Unicode MS Greek;}{\f1597\fswiss\fcharset162\fprq2 Arial Unicode MS Tur;}{\f1598\fswiss\fcharset177\fprq2 Arial Unicode MS (Hebrew);}
{\f1599\fswiss\fcharset178\fprq2 Arial Unicode MS (Arabic);}{\f1600\fswiss\fcharset186\fprq2 Arial Unicode MS Baltic;}{\f1603\fswiss\fcharset0\fprq2 @Arial Unicode MS Western;}{\f1601\fswiss\fcharset238\fprq2 @Arial Unicode MS CE;}
{\f1602\fswiss\fcharset204\fprq2 @Arial Unicode MS Cyr;}{\f1604\fswiss\fcharset161\fprq2 @Arial Unicode MS Greek;}{\f1605\fswiss\fcharset162\fprq2 @Arial Unicode MS Tur;}{\f1606\fswiss\fcharset177\fprq2 @Arial Unicode MS (Hebrew);}
{\f1607\fswiss\fcharset178\fprq2 @Arial Unicode MS (Arabic);}{\f1608\fswiss\fcharset186\fprq2 @Arial Unicode MS Baltic;}{\f1625\fswiss\fcharset238\fprq2 ITC Avant Garde Gothic CE;}{\f1629\fswiss\fcharset162\fprq2 ITC Avant Garde Gothic Tur;}
{\f1632\fswiss\fcharset186\fprq2 ITC Avant Garde Gothic Baltic;}{\f1633\fswiss\fcharset238\fprq2 ITC Avant Garde Gothic Demi CE;}{\f1637\fswiss\fcharset162\fprq2 ITC Avant Garde Gothic Demi Tur;}
{\f1640\fswiss\fcharset186\fprq2 ITC Avant Garde Gothic Demi Baltic;}{\f1641\fswiss\fcharset238\fprq2 BibleScrT CE;}{\f1645\fswiss\fcharset162\fprq2 BibleScrT Tur;}{\f1649\fswiss\fcharset238\fprq2 BinnerD CE;}{\f1653\fswiss\fcharset162\fprq2 BinnerD Tur;}
{\f1683\froman\fcharset0\fprq2 @Batang Western;}{\f1681\froman\fcharset238\fprq2 @Batang CE;}{\f1682\froman\fcharset204\fprq2 @Batang Cyr;}{\f1684\froman\fcharset161\fprq2 @Batang Greek;}{\f1685\froman\fcharset162\fprq2 @Batang Tur;}
{\f1688\froman\fcharset186\fprq2 @Batang Baltic;}{\f1721\froman\fcharset238\fprq2 ITC Bookman Light CE;}{\f1725\froman\fcharset162\fprq2 ITC Bookman Light Tur;}{\f1728\froman\fcharset186\fprq2 ITC Bookman Light Baltic;}
{\f1729\froman\fcharset238\fprq2 ITC Bookman Demi CE;}{\f1733\froman\fcharset162\fprq2 ITC Bookman Demi Tur;}{\f1736\froman\fcharset186\fprq2 ITC Bookman Demi Baltic;}{\f1785\froman\fcharset238\fprq2 CityDLig CE;}
{\f1789\froman\fcharset162\fprq2 CityDLig Tur;}{\f1793\froman\fcharset238\fprq2 CityDMed CE;}{\f1797\froman\fcharset162\fprq2 CityDMed Tur;}{\f1801\froman\fcharset238\fprq2 CityDBol CE;}{\f1805\froman\fcharset162\fprq2 CityDBol Tur;}
{\f1833\froman\fcharset238\fprq2 Century Schoolbook CE;}{\f1834\froman\fcharset204\fprq2 Century Schoolbook Cyr;}{\f1836\froman\fcharset161\fprq2 Century Schoolbook Greek;}{\f1837\froman\fcharset162\fprq2 Century Schoolbook Tur;}
{\f1840\froman\fcharset186\fprq2 Century Schoolbook Baltic;}{\f1849\fswiss\fcharset238\fprq2 CG Omega CE;}{\f1853\fswiss\fcharset162\fprq2 CG Omega Tur;}{\f1856\fswiss\fcharset186\fprq2 CG Omega Baltic;}{\f1857\froman\fcharset238\fprq2 CG Times CE;}
{\f1861\froman\fcharset162\fprq2 CG Times Tur;}{\f1864\froman\fcharset186\fprq2 CG Times Baltic;}{\f1865\fscript\fcharset238\fprq2 ITC Zapf Chancery CE;}{\f1869\fscript\fcharset162\fprq2 ITC Zapf Chancery Tur;}
{\f1872\fscript\fcharset186\fprq2 ITC Zapf Chancery Baltic;}{\f1881\froman\fcharset238\fprq2 Clarendon Condensed CE;}{\f1885\froman\fcharset162\fprq2 Clarendon Condensed Tur;}{\f1888\froman\fcharset186\fprq2 Clarendon Condensed Baltic;}
{\f1921\fscript\fcharset238\fprq2 Coronet CE;}{\f1925\fscript\fcharset162\fprq2 Coronet Tur;}{\f1928\fscript\fcharset186\fprq2 Coronet Baltic;}{\f1929\fmodern\fcharset238\fprq1 CourierPS CE;}{\f1933\fmodern\fcharset162\fprq1 CourierPS Tur;}
{\f1936\fmodern\fcharset186\fprq1 CourierPS Baltic;}{\f1937\fdecor\fcharset238\fprq2 Creepy CE;}{\f1941\fdecor\fcharset162\fprq2 Creepy Tur;}{\f1977\fdecor\fcharset238\fprq2 EwieD CE;}{\f1981\fdecor\fcharset162\fprq2 EwieD Tur;}
{\f2017\fswiss\fcharset238\fprq2 EraserDust CE;}{\f2021\fswiss\fcharset162\fprq2 EraserDust Tur;}{\f2073\fswiss\fcharset238\fprq2 Franklin Gothic Book CE;}{\f2074\fswiss\fcharset204\fprq2 Franklin Gothic Book Cyr;}
{\f2076\fswiss\fcharset161\fprq2 Franklin Gothic Book Greek;}{\f2077\fswiss\fcharset162\fprq2 Franklin Gothic Book Tur;}{\f2080\fswiss\fcharset186\fprq2 Franklin Gothic Book Baltic;}{\f2081\fswiss\fcharset238\fprq2 Franklin Gothic Demi CE;}
{\f2082\fswiss\fcharset204\fprq2 Franklin Gothic Demi Cyr;}{\f2084\fswiss\fcharset161\fprq2 Franklin Gothic Demi Greek;}{\f2085\fswiss\fcharset162\fprq2 Franklin Gothic Demi Tur;}{\f2088\fswiss\fcharset186\fprq2 Franklin Gothic Demi Baltic;}
{\f2089\fswiss\fcharset238\fprq2 Franklin Gothic Demi Cond CE;}{\f2090\fswiss\fcharset204\fprq2 Franklin Gothic Demi Cond Cyr;}{\f2092\fswiss\fcharset161\fprq2 Franklin Gothic Demi Cond Greek;}
{\f2093\fswiss\fcharset162\fprq2 Franklin Gothic Demi Cond Tur;}{\f2096\fswiss\fcharset186\fprq2 Franklin Gothic Demi Cond Baltic;}{\f2097\fswiss\fcharset238\fprq2 Franklin Gothic Heavy CE;}{\f2098\fswiss\fcharset204\fprq2 Franklin Gothic Heavy Cyr;}
{\f2100\fswiss\fcharset161\fprq2 Franklin Gothic Heavy Greek;}{\f2101\fswiss\fcharset162\fprq2 Franklin Gothic Heavy Tur;}{\f2104\fswiss\fcharset186\fprq2 Franklin Gothic Heavy Baltic;}{\f2105\fswiss\fcharset238\fprq2 Franklin Gothic Medium Cond CE;}
{\f2106\fswiss\fcharset204\fprq2 Franklin Gothic Medium Cond Cyr;}{\f2108\fswiss\fcharset161\fprq2 Franklin Gothic Medium Cond Greek;}{\f2109\fswiss\fcharset162\fprq2 Franklin Gothic Medium Cond Tur;}
{\f2112\fswiss\fcharset186\fprq2 Franklin Gothic Medium Cond Baltic;}{\f2137\fswiss\fcharset238\fprq2 GlaserSteD CE;}{\f2141\fswiss\fcharset162\fprq2 GlaserSteD Tur;}{\f2153\fswiss\fcharset238\fprq2 Gill Sans MT CE;}
{\f2161\fswiss\fcharset238\fprq2 Gill Sans MT Condensed CE;}{\f2169\fswiss\fcharset238\fprq2 Gill Sans Ultra Bold Condensed CE;}{\f2177\fswiss\fcharset238\fprq2 Gill Sans Ultra Bold CE;}{\f2193\fswiss\fcharset238\fprq2 Gill Sans MT Ext Condensed Bold CE;}
{\f2217\fdecor\fcharset238\fprq2 HorndonD CE;}{\f2221\fdecor\fcharset162\fprq2 HorndonD Tur;}{\f2241\fswiss\fcharset238\fprq2 Helvetica Narrow CE;}{\f2245\fswiss\fcharset162\fprq2 Helvetica Narrow Tur;}
{\f2248\fswiss\fcharset186\fprq2 Helvetica Narrow Baltic;}{\f2297\fswiss\fcharset238\fprq2 ISOCPEUR CE;}{\f2298\fswiss\fcharset204\fprq2 ISOCPEUR Cyr;}{\f2300\fswiss\fcharset161\fprq2 ISOCPEUR Greek;}{\f2301\fswiss\fcharset162\fprq2 ISOCPEUR Tur;}
{\f2304\fswiss\fcharset186\fprq2 ISOCPEUR Baltic;}{\f2305\fmodern\fcharset238\fprq1 ISOCTEUR CE;}{\f2306\fmodern\fcharset204\fprq1 ISOCTEUR Cyr;}{\f2308\fmodern\fcharset161\fprq1 ISOCTEUR Greek;}{\f2309\fmodern\fcharset162\fprq1 ISOCTEUR Tur;}
{\f2312\fmodern\fcharset186\fprq1 ISOCTEUR Baltic;}{\f2409\fmodern\fcharset238\fprq1 Letter Gothic CE;}{\f2413\fmodern\fcharset162\fprq1 Letter Gothic Tur;}{\f2416\fmodern\fcharset186\fprq1 Letter Gothic Baltic;}
{\f2449\fscript\fcharset238\fprq2 MariageD CE;}{\f2453\fscript\fcharset162\fprq2 MariageD Tur;}{\f2457\fswiss\fcharset238\fprq2 MicrogrammaDMedExt CE;}{\f2461\fswiss\fcharset162\fprq2 MicrogrammaDMedExt Tur;}
{\f2465\fswiss\fcharset238\fprq2 MicrogrammaDBolExt CE;}{\f2469\fswiss\fcharset162\fprq2 MicrogrammaDBolExt Tur;}{\f2497\fscript\fcharset238\fprq2 Marigold CE;}{\f2501\fscript\fcharset162\fprq2 Marigold Tur;}
{\f2504\fscript\fcharset186\fprq2 Marigold Baltic;}{\f2521\fscript\fcharset238\fprq2 Mistral CE;}{\f2522\fscript\fcharset204\fprq2 Mistral Cyr;}{\f2524\fscript\fcharset161\fprq2 Mistral Greek;}{\f2525\fscript\fcharset162\fprq2 Mistral Tur;}
{\f2528\fscript\fcharset186\fprq2 Mistral Baltic;}{\f2571\fmodern\fcharset0\fprq1 @MS Mincho Western;}{\f2569\fmodern\fcharset238\fprq1 @MS Mincho CE;}{\f2570\fmodern\fcharset204\fprq1 @MS Mincho Cyr;}{\f2572\fmodern\fcharset161\fprq1 @MS Mincho Greek;}
{\f2573\fmodern\fcharset162\fprq1 @MS Mincho Tur;}{\f2576\fmodern\fcharset186\fprq1 @MS Mincho Baltic;}{\f2585\fdecor\fcharset238\fprq2 NevisonCasD CE;}{\f2589\fdecor\fcharset162\fprq2 NevisonCasD Tur;}
{\f2593\froman\fcharset238\fprq2 New Century Schoolbook CE;}{\f2597\froman\fcharset162\fprq2 New Century Schoolbook Tur;}{\f2600\froman\fcharset186\fprq2 New Century Schoolbook Baltic;}{\f2641\fswiss\fcharset238\fprq2 Antique Olive CE;}
{\f2645\fswiss\fcharset162\fprq2 Antique Olive Tur;}{\f2648\fswiss\fcharset186\fprq2 Antique Olive Baltic;}{\f2673\froman\fcharset238\fprq2 Palatino CE;}{\f2677\froman\fcharset162\fprq2 Palatino Tur;}{\f2680\froman\fcharset186\fprq2 Palatino Baltic;}
{\f2739\froman\fcharset0\fprq2 @PMingLiU Western;}{\f2891\fnil\fcharset0\fprq2 @SimSun Western;}{\f2929\fswiss\fcharset238\fprq2 Tw Cen MT CE;}{\f2937\fswiss\fcharset238\fprq2 Tw Cen MT Condensed CE;}
{\f2945\fswiss\fcharset238\fprq2 Tw Cen MT Condensed Extra Bold CE;}{\f2993\fswiss\fcharset238\fprq2 ZapfHumnst BT CE;}{\f2996\fswiss\fcharset161\fprq2 ZapfHumnst BT Greek;}{\f2997\fswiss\fcharset162\fprq2 ZapfHumnst BT Tur;}
{\f3001\froman\fcharset238\fprq2 ZapfCalligr BT CE;}{\f3004\froman\fcharset161\fprq2 ZapfCalligr BT Greek;}{\f3005\froman\fcharset162\fprq2 ZapfCalligr BT Tur;}{\f3009\froman\fcharset238\fprq2 Bodoni Bk BT CE;}
{\f3012\froman\fcharset161\fprq2 Bodoni Bk BT Greek;}{\f3013\froman\fcharset162\fprq2 Bodoni Bk BT Tur;}{\f3017\froman\fcharset238\fprq2 Bodoni Bd BT CE;}{\f3020\froman\fcharset161\fprq2 Bodoni Bd BT Greek;}
{\f3021\froman\fcharset162\fprq2 Bodoni Bd BT Tur;}{\f3025\froman\fcharset238\fprq2 AmeriGarmnd BT CE;}{\f3028\froman\fcharset161\fprq2 AmeriGarmnd BT Greek;}{\f3029\froman\fcharset162\fprq2 AmeriGarmnd BT Tur;}
{\f3033\fswiss\fcharset238\fprq2 Swis721 Th BT CE;}{\f3036\fswiss\fcharset161\fprq2 Swis721 Th BT Greek;}{\f3037\fswiss\fcharset162\fprq2 Swis721 Th BT Tur;}{\f3041\fswiss\fcharset238\fprq2 Swis721 Hv BT CE;}
{\f3044\fswiss\fcharset161\fprq2 Swis721 Hv BT Greek;}{\f3045\fswiss\fcharset162\fprq2 Swis721 Hv BT Tur;}{\f3049\fswiss\fcharset238\fprq2 Swiss911 XCm BT CE;}{\f3052\fswiss\fcharset161\fprq2 Swiss911 XCm BT Greek;}
{\f3053\fswiss\fcharset162\fprq2 Swiss911 XCm BT Tur;}{\f3057\fswiss\fcharset238\fprq2 Swiss911 UCm BT CE;}{\f3060\fswiss\fcharset161\fprq2 Swiss911 UCm BT Greek;}{\f3061\fswiss\fcharset162\fprq2 Swiss911 UCm BT Tur;}
{\f3065\fscript\fcharset238\fprq2 Balloon Lt BT CE;}{\f3068\fscript\fcharset161\fprq2 Balloon Lt BT Greek;}{\f3069\fscript\fcharset162\fprq2 Balloon Lt BT Tur;}{\f3073\fdecor\fcharset238\fprq2 Broadway BT CE;}
{\f3076\fdecor\fcharset161\fprq2 Broadway BT Greek;}{\f3077\fdecor\fcharset162\fprq2 Broadway BT Tur;}{\f3081\fswiss\fcharset238\fprq2 Futura Lt BT CE;}{\f3084\fswiss\fcharset161\fprq2 Futura Lt BT Greek;}
{\f3085\fswiss\fcharset162\fprq2 Futura Lt BT Tur;}{\f3089\fswiss\fcharset238\fprq2 Futura XBlk BT CE;}{\f3092\fswiss\fcharset161\fprq2 Futura XBlk BT Greek;}{\f3093\fswiss\fcharset162\fprq2 Futura XBlk BT Tur;}
{\f3097\fswiss\fcharset238\fprq2 Futura XBlkIt BT CE;}{\f3100\fswiss\fcharset161\fprq2 Futura XBlkIt BT Greek;}{\f3101\fswiss\fcharset162\fprq2 Futura XBlkIt BT Tur;}{\f3105\fdecor\fcharset238\fprq2 Shotgun BT CE;}
{\f3108\fdecor\fcharset161\fprq2 Shotgun BT Greek;}{\f3109\fdecor\fcharset162\fprq2 Shotgun BT Tur;}{\f3113\fswiss\fcharset238\fprq2 Zurich Lt BT CE;}{\f3116\fswiss\fcharset161\fprq2 Zurich Lt BT Greek;}{\f3117\fswiss\fcharset162\fprq2 Zurich Lt BT Tur;}
{\f3121\fswiss\fcharset238\fprq2 Zurich BT CE;}{\f3124\fswiss\fcharset161\fprq2 Zurich BT Greek;}{\f3125\fswiss\fcharset162\fprq2 Zurich BT Tur;}{\f3129\fdecor\fcharset238\fprq2 Stencil BT CE;}{\f3132\fdecor\fcharset161\fprq2 Stencil BT Greek;}
{\f3133\fdecor\fcharset162\fprq2 Stencil BT Tur;}{\f3137\fscript\fcharset238\fprq2 BrushScript BT CE;}{\f3140\fscript\fcharset161\fprq2 BrushScript BT Greek;}{\f3141\fscript\fcharset162\fprq2 BrushScript BT Tur;}
{\f3145\fswiss\fcharset238\fprq2 Futura LtCn BT CE;}{\f3148\fswiss\fcharset161\fprq2 Futura LtCn BT Greek;}{\f3149\fswiss\fcharset162\fprq2 Futura LtCn BT Tur;}{\f3153\fswiss\fcharset238\fprq2 Futura XBlkCn BT CE;}
{\f3156\fswiss\fcharset161\fprq2 Futura XBlkCn BT Greek;}{\f3157\fswiss\fcharset162\fprq2 Futura XBlkCn BT Tur;}{\f3161\fswiss\fcharset238\fprq2 Futura XBlkCnIt BT CE;}{\f3164\fswiss\fcharset161\fprq2 Futura XBlkCnIt BT Greek;}
{\f3165\fswiss\fcharset162\fprq2 Futura XBlkCnIt BT Tur;}{\f3169\fdecor\fcharset238\fprq2 FuturaBlack BT CE;}{\f3172\fdecor\fcharset161\fprq2 FuturaBlack BT Greek;}{\f3173\fdecor\fcharset162\fprq2 FuturaBlack BT Tur;}
{\f3177\fscript\fcharset238\fprq2 AmericanText BT CE;}{\f3180\fscript\fcharset161\fprq2 AmericanText BT Greek;}{\f3181\fscript\fcharset162\fprq2 AmericanText BT Tur;}{\f3185\fdecor\fcharset238\fprq2 ShotgunBlanks BT CE;}
{\f3188\fdecor\fcharset161\fprq2 ShotgunBlanks BT Greek;}{\f3189\fdecor\fcharset162\fprq2 ShotgunBlanks BT Tur;}{\f3193\fswiss\fcharset238\fprq2 Square721 BT CE;}{\f3196\fswiss\fcharset161\fprq2 Square721 BT Greek;}
{\f3197\fswiss\fcharset162\fprq2 Square721 BT Tur;}{\f3201\fswiss\fcharset238\fprq2 Square721 Cn BT CE;}{\f3204\fswiss\fcharset161\fprq2 Square721 Cn BT Greek;}{\f3205\fswiss\fcharset162\fprq2 Square721 Cn BT Tur;}
{\f3209\fswiss\fcharset238\fprq2 Zurich UBlkEx BT CE;}{\f3212\fswiss\fcharset161\fprq2 Zurich UBlkEx BT Greek;}{\f3213\fswiss\fcharset162\fprq2 Zurich UBlkEx BT Tur;}{\f3217\froman\fcharset238\fprq2 Humanst521 Lt BT CE;}
{\f3220\froman\fcharset161\fprq2 Humanst521 Lt BT Greek;}{\f3221\froman\fcharset162\fprq2 Humanst521 Lt BT Tur;}{\f3225\fswiss\fcharset238\fprq2 Humanst521 BT CE;}{\f3228\fswiss\fcharset161\fprq2 Humanst521 BT Greek;}
{\f3229\fswiss\fcharset162\fprq2 Humanst521 BT Tur;}{\f3233\fswiss\fcharset238\fprq2 Humanst521 XBd BT CE;}{\f3236\fswiss\fcharset161\fprq2 Humanst521 XBd BT Greek;}{\f3237\fswiss\fcharset162\fprq2 Humanst521 XBd BT Tur;}
{\f3241\fswiss\fcharset238\fprq2 Humanst521 UBd BT CE;}{\f3244\fswiss\fcharset161\fprq2 Humanst521 UBd BT Greek;}{\f3245\fswiss\fcharset162\fprq2 Humanst521 UBd BT Tur;}{\f3249\fswiss\fcharset238\fprq2 Zurich Cn BT CE;}
{\f3252\fswiss\fcharset161\fprq2 Zurich Cn BT Greek;}{\f3253\fswiss\fcharset162\fprq2 Zurich Cn BT Tur;}{\f3257\froman\fcharset238\fprq2 GeoSlab703 Lt BT CE;}{\f3260\froman\fcharset161\fprq2 GeoSlab703 Lt BT Greek;}
{\f3261\froman\fcharset162\fprq2 GeoSlab703 Lt BT Tur;}{\f3265\froman\fcharset238\fprq2 GeoSlab703 Md BT CE;}{\f3268\froman\fcharset161\fprq2 GeoSlab703 Md BT Greek;}{\f3269\froman\fcharset162\fprq2 GeoSlab703 Md BT Tur;}
{\f3281\froman\fcharset238\fprq2 SquareSlab711 Lt BT CE;}{\f3284\froman\fcharset161\fprq2 SquareSlab711 Lt BT Greek;}{\f3285\froman\fcharset162\fprq2 SquareSlab711 Lt BT Tur;}{\f3289\froman\fcharset238\fprq2 SquareSlab711 Bd BT CE;}
{\f3292\froman\fcharset161\fprq2 SquareSlab711 Bd BT Greek;}{\f3293\froman\fcharset162\fprq2 SquareSlab711 Bd BT Tur;}{\f3297\fswiss\fcharset238\fprq2 CopprplGoth BT CE;}{\f3300\fswiss\fcharset161\fprq2 CopprplGoth BT Greek;}
{\f3301\fswiss\fcharset162\fprq2 CopprplGoth BT Tur;}{\f3305\fswiss\fcharset238\fprq2 CopprplGoth Hv BT CE;}{\f3308\fswiss\fcharset161\fprq2 CopprplGoth Hv BT Greek;}{\f3309\fswiss\fcharset162\fprq2 CopprplGoth Hv BT Tur;}
{\f3313\fswiss\fcharset238\fprq2 CopprplGoth BdCn BT CE;}{\f3316\fswiss\fcharset161\fprq2 CopprplGoth BdCn BT Greek;}{\f3317\fswiss\fcharset162\fprq2 CopprplGoth BdCn BT Tur;}{\f3321\fswiss\fcharset238\fprq2 Humanst521 Cn BT CE;}
{\f3324\fswiss\fcharset161\fprq2 Humanst521 Cn BT Greek;}{\f3325\fswiss\fcharset162\fprq2 Humanst521 Cn BT Tur;}{\f3329\fswiss\fcharset238\fprq2 Humanst521 XBdCn BT CE;}{\f3332\fswiss\fcharset161\fprq2 Humanst521 XBdCn BT Greek;}
{\f3333\fswiss\fcharset162\fprq2 Humanst521 XBdCn BT Tur;}{\f3337\fswiss\fcharset238\fprq2 AlternateGothic2 BT CE;}{\f3340\fswiss\fcharset161\fprq2 AlternateGothic2 BT Greek;}{\f3341\fswiss\fcharset162\fprq2 AlternateGothic2 BT Tur;}
{\f3345\fswiss\fcharset238\fprq2 Swiss921 BT CE;}{\f3348\fswiss\fcharset161\fprq2 Swiss921 BT Greek;}{\f3349\fswiss\fcharset162\fprq2 Swiss921 BT Tur;}{\f3353\fscript\fcharset238\fprq2 DomCasual BT CE;}
{\f3356\fscript\fcharset161\fprq2 DomCasual BT Greek;}{\f3357\fscript\fcharset162\fprq2 DomCasual BT Tur;}{\f3369\fscript\fcharset238\fprq2 Balloon Bd BT CE;}{\f3372\fscript\fcharset161\fprq2 Balloon Bd BT Greek;}
{\f3373\fscript\fcharset162\fprq2 Balloon Bd BT Tur;}{\f3377\fscript\fcharset238\fprq2 Balloon XBd BT CE;}{\f3380\fscript\fcharset161\fprq2 Balloon XBd BT Greek;}{\f3381\fscript\fcharset162\fprq2 Balloon XBd BT Tur;}
{\f3385\fswiss\fcharset238\fprq2 VAGRounded BT CE;}{\f3388\fswiss\fcharset161\fprq2 VAGRounded BT Greek;}{\f3389\fswiss\fcharset162\fprq2 VAGRounded BT Tur;}{\f3393\fscript\fcharset238\fprq2 CloisterBlack BT CE;}
{\f3396\fscript\fcharset161\fprq2 CloisterBlack BT Greek;}{\f3397\fscript\fcharset162\fprq2 CloisterBlack BT Tur;}{\f3401\fscript\fcharset238\fprq2 DomBold BT CE;}{\f3404\fscript\fcharset161\fprq2 DomBold BT Greek;}
{\f3405\fscript\fcharset162\fprq2 DomBold BT Tur;}{\f3409\fdecor\fcharset238\fprq2 BroadwayEngraved BT CE;}{\f3412\fdecor\fcharset161\fprq2 BroadwayEngraved BT Greek;}{\f3413\fdecor\fcharset162\fprq2 BroadwayEngraved BT Tur;}
{\f3417\fswiss\fcharset238\fprq2 Gothic821 Cn BT CE;}{\f3420\fswiss\fcharset161\fprq2 Gothic821 Cn BT Greek;}{\f3421\fswiss\fcharset162\fprq2 Gothic821 Cn BT Tur;}{\f3425\fscript\fcharset238\fprq2 DomDiagonal BT CE;}
{\f3428\fscript\fcharset161\fprq2 DomDiagonal BT Greek;}{\f3429\fscript\fcharset162\fprq2 DomDiagonal BT Tur;}{\f3433\fscript\fcharset238\fprq2 DomDiagonal Bd BT CE;}{\f3436\fscript\fcharset161\fprq2 DomDiagonal Bd BT Greek;}
{\f3437\fscript\fcharset162\fprq2 DomDiagonal Bd BT Tur;}{\f3441\fswiss\fcharset238\fprq2 Swiss924 BT CE;}{\f3444\fswiss\fcharset161\fprq2 Swiss924 BT Greek;}{\f3445\fswiss\fcharset162\fprq2 Swiss924 BT Tur;}
{\f3449\froman\fcharset238\fprq2 Bodoni BdCn BT CE;}{\f3452\froman\fcharset161\fprq2 Bodoni BdCn BT Greek;}{\f3453\froman\fcharset162\fprq2 Bodoni BdCn BT Tur;}{\f3457\fscript\fcharset238\fprq2 WeddingText BT CE;}
{\f3460\fscript\fcharset161\fprq2 WeddingText BT Greek;}{\f3461\fscript\fcharset162\fprq2 WeddingText BT Tur;}{\f3465\froman\fcharset238\fprq2 GeoSlab703 MdCn BT CE;}{\f3468\froman\fcharset161\fprq2 GeoSlab703 MdCn BT Greek;}
{\f3469\froman\fcharset162\fprq2 GeoSlab703 MdCn BT Tur;}{\f3473\fswiss\fcharset238\fprq2 Aurora BdCn BT CE;}{\f3476\fswiss\fcharset161\fprq2 Aurora BdCn BT Greek;}{\f3477\fswiss\fcharset162\fprq2 Aurora BdCn BT Tur;}
{\f3481\fdecor\fcharset238\fprq2 AdLib BT CE;}{\f3484\fdecor\fcharset161\fprq2 AdLib BT Greek;}{\f3485\fdecor\fcharset162\fprq2 AdLib BT Tur;}{\f3489\fscript\fcharset238\fprq2 OzHandicraft BT CE;}{\f3492\fscript\fcharset161\fprq2 OzHandicraft BT Greek;}
{\f3493\fscript\fcharset162\fprq2 OzHandicraft BT Tur;}{\f3497\fscript\fcharset238\fprq2 MisterEarl BT CE;}{\f3500\fscript\fcharset161\fprq2 MisterEarl BT Greek;}{\f3501\fscript\fcharset162\fprq2 MisterEarl BT Tur;}
{\f3505\fdecor\fcharset238\fprq2 Bremen Bd BT CE;}{\f3508\fdecor\fcharset161\fprq2 Bremen Bd BT Greek;}{\f3509\fdecor\fcharset162\fprq2 Bremen Bd BT Tur;}{\f3513\fdecor\fcharset238\fprq2 Bremen Blk BT CE;}
{\f3516\fdecor\fcharset161\fprq2 Bremen Blk BT Greek;}{\f3517\fdecor\fcharset162\fprq2 Bremen Blk BT Tur;}{\f3529\fswiss\fcharset238\fprq2 Univers CE;}{\f3533\fswiss\fcharset162\fprq2 Univers Tur;}{\f3536\fswiss\fcharset186\fprq2 Univers Baltic;}
{\f3537\fswiss\fcharset238\fprq2 Univers Condensed CE;}{\f3541\fswiss\fcharset162\fprq2 Univers Condensed Tur;}{\f3544\fswiss\fcharset186\fprq2 Univers Condensed Baltic;}{\f3545\fswiss\fcharset238\fprq2 Verdana Ref CE;}
{\f3546\fswiss\fcharset204\fprq2 Verdana Ref Cyr;}{\f3548\fswiss\fcharset161\fprq2 Verdana Ref Greek;}{\f3549\fswiss\fcharset162\fprq2 Verdana Ref Tur;}{\f3552\fswiss\fcharset186\fprq2 Verdana Ref Baltic;}
{\f3596\fnil\fcharset161\fprq2 Jokerman LET Greek;}{\f3604\fnil\fcharset161\fprq2 John Handy LET Greek;}{\f3612\fnil\fcharset161\fprq2 Orange LET Greek;}{\f3620\fnil\fcharset161\fprq2 Academy Engraved LET Greek;}
{\f3628\fnil\fcharset161\fprq2 University Roman LET Greek;}{\f3636\fnil\fcharset161\fprq2 Victorian LET Greek;}{\f3644\fnil\fcharset161\fprq2 Milano LET Greek;}{\f3652\fnil\fcharset161\fprq2 Smudger LET Greek;}
{\f3660\fnil\fcharset161\fprq2 Westwood LET Greek;}{\f3668\fnil\fcharset161\fprq2 Ruach LET Greek;}{\f3676\fnil\fcharset161\fprq2 Rage Italic LET Greek;}{\f3684\fnil\fcharset161\fprq2 La Bamba LET Greek;}{\f3692\fnil\fcharset161\fprq2 Quixley LET Greek;}
{\f3700\fnil\fcharset161\fprq2 Pump Demi Bold LET Greek;}{\f3708\fnil\fcharset161\fprq2 Tiranti Solid LET Greek;}{\f3716\fnil\fcharset161\fprq2 Mekanik LET Greek;}{\f3724\fnil\fcharset161\fprq2 One Stroke Script LET Greek;}
{\f3732\fnil\fcharset161\fprq2 Highlight LET Greek;}{\f3740\fnil\fcharset161\fprq2 Odessa LET Greek;}{\f3748\fnil\fcharset161\fprq2 Scruff LET Greek;}{\f3753\fscript\fcharset238\fprq2 ParkAvenue BT CE;}
{\f3756\fscript\fcharset161\fprq2 ParkAvenue BT Greek;}{\f3757\fscript\fcharset162\fprq2 ParkAvenue BT Tur;}{\f3761\fscript\fcharset238\fprq2 Staccato222 BT CE;}{\f3764\fscript\fcharset161\fprq2 Staccato222 BT Greek;}
{\f3765\fscript\fcharset162\fprq2 Staccato222 BT Tur;}{\f3769\fscript\fcharset238\fprq2 Cataneo BT CE;}{\f3772\fscript\fcharset161\fprq2 Cataneo BT Greek;}{\f3773\fscript\fcharset162\fprq2 Cataneo BT Tur;}
{\f3777\fscript\fcharset238\fprq2 Blackletter686 BT CE;}{\f3780\fscript\fcharset161\fprq2 Blackletter686 BT Greek;}{\f3781\fscript\fcharset162\fprq2 Blackletter686 BT Tur;}{\f3785\fscript\fcharset238\fprq2 Calligraph421 BT CE;}
{\f3788\fscript\fcharset161\fprq2 Calligraph421 BT Greek;}{\f3789\fscript\fcharset162\fprq2 Calligraph421 BT Tur;}{\f3793\fdecor\fcharset238\fprq2 OldDreadfulNo7 BT CE;}{\f3796\fdecor\fcharset161\fprq2 OldDreadfulNo7 BT Greek;}
{\f3797\fdecor\fcharset162\fprq2 OldDreadfulNo7 BT Tur;}{\f3812\fnil\fcharset161\fprq2 Jokerman Alts LET Greek;}{\f3820\fnil\fcharset161\fprq2 University Roman Alts LET Greek;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 header;}{\s16\ql \li0\ri0\widctlpar
\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext16 footer;}{\*\cs17 \additive \sbasedon10 page number;}}{\*\revtbl {Unknown;}}{\info
{\title // Copyright 2005 WaveBreak Software}{\author Randy}{\operator Randy}{\creatim\yr2005\mo1\dy24\min11}{\revtim\yr2005\mo1\dy24\min16}{\version2}{\edmins5}{\nofpages276}{\nofwords43289}{\nofchars246752}{\*\company None}{\nofcharsws303028}
{\vern8269}}\margl720\margr720\margt720\margb720 \widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin720\dgvorigin720\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale90\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \linex0\endnhere\sectlinegrid360\sectdefaultcl {\footer \pard\plain 
\s16\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\pvpara\phmrg\posxc\posy0\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\field{\*\fldinst {\cs17 PAGE  }}{\fldrslt {
\cs17\lang1024\langfe1024\noproof 1}}}{\cs17 
\par }\pard \s16\ql \li0\ri0\widctlpar\tqc\tx4320\tqr\tx8640\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f2 // Copyright 2005 WaveBreak Software
\par 
\par // swanlake.cpp -- swan lake screensaver functions
\par 
\par // includes //
\par 
\par #include"..\\\\engine\\\\r3dwin.h"
\par #include"swanlake.h"
\par 
\par #ifdef DEBUG_MODE
\par // work-arounds for debug mode (due to absence of DirectInput)
\par BOOL AddDefaultInputSettings(BOOL b) \{ return(TRUE); \}
\par BOOL IsButtonDown(DWORD dw) \{ return(FALSE); \}
\par DWORD g_dwDefSelectBtn=0;
\par DWORD AddInputButton(void) \{ return(0); \}
\par DWORD AddInputButtonTrigger(DWORD dw1,DWORD dw2) \{ return(0); \}
\par DWORD DIK_T=0;
\par void ReadUserInput(void) \{\}
\par float GetAxisPos(DWORD dw) \{ return(0); \}
\par DWORD g_dwDefXAxis=0;
\par DWORD g_dwDefYAxis=0;
\par #endif
\par 
\par // globals //
\par 
\par // water surface buffers
\par DWORD g_dwWaterVtxBuf=NO_OBJECT;
\par DWORD g_dwWaterIdxBuf=NO_OBJECT;
\par DWORD g_dwWaterMat=NO_OBJECT;
\par DWORD g_dwWaterTex=NO_OBJECT;
\par // terrain mesh data
\par DWORD g_dwTerrainMesh=NO_OBJECT;
\par DWORD g_dwTerrainMtx=NO_OBJECT;
\par // sky mesh data
\par DWORD g_dwSkyMesh=NO_OBJECT;
\par DWORD g_dwSkyMtx=NO_OBJECT;
\par #ifdef DEBUG_MODE
\par // top view data
\par DWORD g_dwTopViewMtx=NO_OBJECT;
\par DWORD g_dwTopViewBtn=NO_OBJECT;
\par #endif
\par // initial updates flag
\par BOOL g_bInitUpdates=FALSE;
\par // creature animations & meshes
\par DWORD g_dwSwanAnim=NO_OBJECT;
\par DWORD g_dwBBSwanAnim=NO_OBJECT;
\par DWORD g_dwTurtleAnim=NO_OBJECT;
\par DWORD g_dwDragonflyMesh=NO_OBJECT;
\par DWORD g_dwDragonflyWingAnim=NO_OBJECT;
\par DWORD g_dwFishTex=NO_OBJECT;
\par DWORD g_dwBirdAnim=NO_OBJECT;
\par // swan counters
\par DWORD g_dwNumSwan=0;
\par DWORD g_dwMaxSwan=0;
\par // swan data
\par LPDWORD g_lpdwSwanMtx=NULL;
\par LPDWORD g_lpdwSwanPriState=NULL;
\par LPDWORD g_lpdwSwanActState=NULL;
\par LPDWORD g_lpdwSwanNavState=NULL;
\par LPDWORD g_lpdwSwanKeyframe1=NULL;
\par LPDWORD g_lpdwSwanKeyframe2=NULL;
\par float* g_lpfSwanTweenVal=NULL;
\par float* g_lpfSwanTailPos=NULL;
\par float* g_lpfSwanTailDir=NULL;
\par float* g_lpfSwanTransPos=NULL;
\par float* g_lpfSwanTransSpeed=NULL;
\par LPDWORD g_lpdwSwanTransKey1=NULL;
\par LPDWORD g_lpdwSwanTransKey2=NULL;
\par float* g_lpfSwanNavSpeed=NULL;
\par LPDWORD g_lpdwSwanNavPos=NULL;
\par LPDWORD g_lpdwSwanNavMax=NULL;
\par LPDWORD g_lpdwSwanMateIdx=NULL;
\par // baby swan counters
\par DWORD g_dwNumBBSwan=0;
\par DWORD g_dwMaxBBSwan=0;
\par // baby swan data
\par LPDWORD g_lpdwBBSwanMtx=NULL;
\par LPDWORD g_lpdwBBSwanPriState=NULL;
\par LPDWORD g_lpdwBBSwanActState=NULL;
\par LPDWORD g_lpdwBBSwanNavState=NULL;
\par LPDWORD g_lpdwBBSwanKeyframe1=NULL;
\par LPDWORD g_lpdwBBSwanKeyframe2=NULL;
\par float* g_lpfBBSwanTweenVal=NULL;
\par float* g_lpfBBSwanTailPos=NULL;
\par float* g_lpfBBSwanTailDir=NULL;
\par float* g_lpfBBSwanTransPos=NULL;
\par float* g_lpfBBSwanTransSpeed=NULL;
\par LPDWORD g_lpdwBBSwanTransKey1=NULL;
\par LPDWORD g_lpdwBBSwanTransKey2=NULL;
\par float* g_lpfBBSwanNavSpeed=NULL;
\par LPDWORD g_lpdwBBSwanNavPos=NULL;
\par LPDWORD g_lpdwBBSwanNavMax=NULL;
\par LPDWORD g_lpdwBBSwanParent1Idx=NULL;
\par LPDWORD g_lpdwBBSwanParent2Idx=NULL;
\par // turtle counters
\par DWORD g_dwNumTurtle=0;
\par DWORD g_dwMaxTurtle=0;
\par // turtle data
\par LPDWORD g_lpdwTurtleMtx=NULL;
\par LPDWORD g_lpdwTurtlePriState=NULL;
\par LPDWORD g_lpdwTurtleActState=NULL;
\par LPDWORD g_lpdwTurtleNavState=NULL;
\par LPDWORD g_lpdwTurtleKeyframe1=NULL;
\par LPDWORD g_lpdwTurtleKeyframe2=NULL;
\par float* g_lpfTurtleTweenVal=NULL;
\par float* g_lpfTurtleTransPos=NULL;
\par float* g_lpfTurtleTransSpeed=NULL;
\par float* g_lpfTurtleNavSpeed=NULL;
\par LPDWORD g_lpdwTurtleNavPos=NULL;
\par LPDWORD g_lpdwTurtleNavMax=NULL;
\par // dragonfly counters
\par DWORD g_dwNumDFly=0;
\par DWORD g_dwMaxDFly=0;
\par // dragonfly data
\par LPDWORD g_lpdwDFlyMtx=NULL;
\par LPDWORD g_lpdwDFlyPriState=NULL;
\par LPDWORD g_lpdwDFlyNavState=NULL;
\par float* g_lpfDFlyNavSpeed=NULL;
\par LPDWORD g_lpdwDFlyNavPos=NULL;
\par LPDWORD g_lpdwDFlyNavMax=NULL;
\par LPD3DXVECTOR3 g_lpvDFlyDartVec=NULL;
\par LPDWORD g_lpdwDFlyMateIdx=NULL;
\par LPDWORD g_lpdwDFlyAPathID=NULL;
\par LPDWORD g_lpdwDFlyBuzzIdx=NULL;
\par LPBOOL g_lpbDFlyPlayback=NULL;
\par // fish counters
\par DWORD g_dwNumFish=0;
\par DWORD g_dwMaxFish=0;
\par // fish data
\par LPD3DXVECTOR3 g_lpvFishPos=NULL;
\par float* g_lpfFishScale=0;
\par LPDWORD g_lpdwFishPriState=NULL;
\par LPDWORD g_lpdwFishAnimFrame=NULL;
\par LPDWORD g_lpdwFishAPathID=NULL;
\par LPDWORD g_lpdwFishSplashIdx=NULL;
\par LPBOOL g_lpbFishPlayback=NULL;
\par // bird counters
\par DWORD g_dwNumBird=0;
\par DWORD g_dwMaxBird=0;
\par // bird data
\par LPDWORD g_lpdwBirdMtx=NULL;
\par float* g_lpfBirdWingPos=NULL;
\par float* g_lpfBirdWingDir=NULL;
\par LPDWORD g_lpdwBirdNavState=NULL;
\par float* g_lpfBirdNavSpeed=NULL;
\par LPDWORD g_lpdwBirdNavPos=NULL;
\par LPDWORD g_lpdwBirdNavMax=NULL;
\par LPDWORD g_lpdwBirdKeyframe1=NULL;
\par LPDWORD g_lpdwBirdKeyframe2=NULL;
\par float* g_lpfBirdTweenVal=NULL;
\par // lens flare data
\par LENSFLAREDATA g_lfd;
\par // ripple rendering data
\par DWORD g_dwRippleVtxBuf;
\par DWORD g_dwRippleIdxBuf;
\par DWORD g_dwRippleMat;
\par DWORD g_lpdwRippleTex[4];
\par DWORD g_dwRippleMtx;
\par // ripple counters
\par DWORD g_dwNumRipple=0;
\par DWORD g_dwMaxRipple=0;
\par // ripple data
\par float* g_lpfRippleX=NULL;
\par float* g_lpfRippleZ=NULL;
\par float* g_lpfRipplePos=NULL;
\par float* g_lpfRippleSpeed=NULL;
\par // creature ripple indices
\par LPDWORD g_lpdwSwanRipple1Idx=NULL;
\par LPDWORD g_lpdwSwanRipple2Idx=NULL;
\par LPDWORD g_lpdwBBSwanRipple1Idx=NULL;
\par LPDWORD g_lpdwBBSwanRipple2Idx=NULL;
\par LPDWORD g_lpdwTurtleRipple1Idx=NULL;
\par LPDWORD g_lpdwTurtleRipple2Idx=NULL;
\par LPDWORD g_lpdwFishRipple1Idx=NULL;
\par LPDWORD g_lpdwFishRipple2Idx=NULL;
\par // camera data
\par DWORD g_dwCamMtx=NO_OBJECT;
\par DWORD g_dwCamOutputMtx=NO_OBJECT;
\par DWORD g_dwCamPriState=NULL;
\par DWORD g_dwCamNavState=NULL;
\par float g_fCamNavSpeed=NULL;
\par DWORD g_dwCamNavPos=NULL;
\par DWORD g_dwCamNavMax=NULL;
\par D3DXVECTOR3 g_vCamAhead=D3DXVECTOR3(0,0,0);
\par float g_fCamTurnInc=NULL;
\par float g_fCamClimbInc=NULL;
\par DWORD g_dwCamTargetMtx=NO_OBJECT;
\par // sound data
\par BOOL g_bUse3DSound=FALSE;
\par DWORD g_dwLeCygneMus=NO_OBJECT;
\par DWORD g_dwEagleSFX=NO_OBJECT;
\par DWORD g_dwBirds1SFX=NO_OBJECT;
\par DWORD g_dwBirds2SFX=NO_OBJECT;
\par DWORD g_dwSwan1SFX=NO_OBJECT;
\par DWORD g_dwSwan2SFX=NO_OBJECT;
\par DWORD g_dwSwan3SFX=NO_OBJECT;
\par DWORD g_dwSplashSFX=NO_OBJECT;
\par DWORD g_dwBBSwan1SFX=NO_OBJECT;
\par DWORD g_dwBBSwan2SFX=NO_OBJECT;
\par DWORD g_dwBuzzSFX=NO_OBJECT;
\par SOUNDPOSDATA g_spdEagle;
\par SOUNDPOSDATA g_spdBirds1;
\par SOUNDPOSDATA g_spdBirds2;
\par SOUNDPOSDATA g_spdSwan1;
\par SOUNDPOSDATA g_spdSwan2;
\par SOUNDPOSDATA g_spdSwan3;
\par SOUNDPOSDATA g_spdSplash;
\par SOUNDPOSDATA g_spdBBSwan1;
\par SOUNDPOSDATA g_spdBBSwan2;
\par SOUNDPOSDATA g_spdBuzz;
\par // sound source matrices
\par DWORD g_lpdwSndSrcMtx[SNDSRC_NUMSOURCES];
\par // frame rate font
\par DWORD g_dwFPSFont=NO_OBJECT;
\par // screensaver options
\par BOOL g_bPriorityMode=FALSE;
\par DWORD g_dwHorzRes=0;
\par DWORD g_dwVertRes=0;
\par DWORD g_dwBufferCnt=0;
\par BOOL g_bFogMode=FALSE;
\par float g_fMasterVol=0;
\par float g_fPrimaryVol=0;
\par float g_fSecondaryVol=0;
\par BOOL g_bFrameRate=FALSE;
\par BOOL g_bSpeedMode=FALSE;
\par BOOL g_bTexSmooth=FALSE;
\par BOOL g_bShadeSmooth=FALSE;
\par DWORD g_dwSceneNumSwans=0;
\par BOOL g_bSceneBBSwans=FALSE;
\par DWORD g_dwSceneNumTurtles=0;
\par DWORD g_dwSceneNumDFlies=0;
\par DWORD g_dwSceneNumFish=0;
\par DWORD g_dwSceneNumBirds=0;
\par BOOL g_bLensFlareMode=FALSE;
\par BOOL g_bUseRipples=FALSE;
\par BOOL g_bTerrainHiRes=FALSE;
\par BOOL g_bUseMusic=FALSE;
\par BOOL g_bUseSFX=FALSE;
\par BOOL g_bShowClock=FALSE;
\par // clock digits
\par DWORD g_dwClockDigit[10];
\par DWORD g_dwClockAM=NO_OBJECT;
\par DWORD g_dwClockPM=NO_OBJECT;
\par DWORD g_dwClockColon=NO_OBJECT;
\par // fade-in data
\par float g_fFadeIn=0.0F;
\par // "phantom" swan flag
\par BOOL g_bPhantomSwan=FALSE;
\par // dialog boxes
\par DWORD g_dwConfigDlg=NO_OBJECT;
\par DWORD g_dwAboutDlg=NO_OBJECT;
\par #ifdef SHAREWARE_MODE
\par DWORD g_dwPurchaseDlg=NO_OBJECT;
\par #endif
\par #ifdef SHAREWARE_MODE
\par // days remaining in trial period
\par DWORD g_dwTrialDays=0;
\par // nag screen textures
\par DWORD g_dwNagMain=NO_OBJECT;
\par DWORD g_dwNagTFlash=NO_OBJECT;
\par DWORD g_dwNagClose=NO_OBJECT;
\par DWORD g_dwNagRedX=NO_OBJECT;
\par DWORD g_dwNagDigits[10];
\par DWORD g_dwNagCursor=NO_OBJECT;
\par DWORD g_dwNagBlank=NO_OBJECT;
\par // nag screen sound fx
\par DWORD g_dwNagSnd=NO_OBJECT;
\par // nag screen active flag
\par BOOL g_bNagScreen=FALSE;
\par // misc nag screen values
\par DWORD g_dwNagFreqCur=0;
\par DWORD g_dwNagFreqMax=0;
\par DWORD g_dwNagDelayCur=0;
\par DWORD g_dwNagDelayMax=0;
\par DWORD g_dwNagAnimPos=0;
\par #endif
\par 
\par // functions //
\par 
\par // SwanLakeInit()
\par 
\par BOOL SwanLakeInit(void)
\par \{
\par \tab LoadingOutput("SwanLakeInit");
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par #ifdef DEBUG_MODE
\par \tab // create data files
\par \tab CreateDataFiles();
\par #endif
\par 
\par \tab // enable mouse tracking
\par \tab EnableMouseTracking();
\par 
\par \tab // set data path
\par \tab if(!SwanLakeSetDataPath())
\par \tab \tab return(FALSE);
\par \tab 
\par // this section must be after SetDataPath!
\par #ifdef SHAREWARE_MODE
\par \tab // get days left
\par \tab g_dwTrialDays=GetTrialDaysRemaining();
\par #else
\par \tab // reset leftover timestamps
\par \tab ResetTimeStamps();
\par #endif
\par 
\par \tab // open data file
\par \tab if(!OpenDataFile("swanlake.dat"))
\par \tab \tab return(FALSE);
\par 
\par \tab // initialize lake scene
\par \tab if(!InitLakeScene())
\par \tab \{
\par \tab \tab CloseDataFile();
\par \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // initialize camera object
\par \tab if(!InitCameraObject())
\par \tab \{
\par \tab \tab CloseDataFile();
\par \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // initialize sound effects
\par \tab if(!InitSoundFX())
\par \tab \{
\par \tab \tab CloseDataFile();
\par \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // initialize clock digits
\par \tab if(!InitClockDigits())
\par \tab \{
\par \tab \tab CloseDataFile();
\par \tab \tab return(FALSE);
\par \tab \}
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // initialize nag screen
\par \tab if(!InitNagScreen())
\par \tab \tab return(FALSE);
\par #endif
\par 
\par \tab // close data file
\par \tab CloseDataFile();
\par 
\par #ifdef DEBUG_MODE
\par \tab // add default input
\par \tab AddDefaultInputSettings(TRUE);
\par 
\par \tab // add top view functionality
\par \tab AddTopViewFunctionality();
\par #endif
\par 
\par \tab // add font for fps info
\par \tab g_dwFPSFont=AddFont("Courier New",16);
\par 
\par \tab // check font
\par \tab if(g_dwFPSFont==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // check days left
\par \tab if(g_dwTrialDays!=0)
\par #endif
\par \tab \{
\par \tab \tab // set initial updates flag
\par \tab \tab g_bInitUpdates=TRUE;
\par 
\par \tab \tab // perform initial updates
\par \tab \tab for(dwCount=0;dwCount<NUM_INITUPDATES;dwCount++)
\par \tab \tab \tab SwanLakeUpdate();
\par 
\par \tab \tab // reset initial updates flag
\par \tab \tab g_bInitUpdates=FALSE;
\par 
\par \tab \tab // start music
\par \tab \tab if(g_bUseMusic)
\par \tab \tab \tab PlayPrimaryAudioSegment(g_dwLeCygneMus);
\par \tab \}
\par 
\par \tab // set fade-in value
\par \tab g_fFadeIn=1.5F;
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par #ifdef DEBUG_MODE
\par // CreateDataFiles()
\par 
\par void CreateDataFiles(void)
\par \{
\par \tab LoadingOutput("CreateDataFiles");
\par /*
\par \tab // create water surface textures
\par \tab if(!CreateWaterTextures())
\par \tab \tab return;
\par */
\par /*
\par \tab // compress sky model
\par \tab CompressX("sky.x");
\par 
\par \tab // create swan animation
\par \tab CreateXFAFromX("swan.xfa",
\par \tab \tab \tab \tab    "swan.x");
\par 
\par \tab // create baby swan animation
\par \tab CreateXFAFromX("bbswan.xfa",
\par \tab \tab \tab \tab    "bbswan.x");
\par 
\par \tab // create turtle animation
\par \tab CreateXFAFromX("turtle.xfa",
\par \tab \tab \tab \tab    "turtle.x");
\par 
\par \tab // compress dragonfly model
\par \tab CompressX("drgfly.x");
\par \tab 
\par \tab // create dragonfly wing animation
\par \tab CreateXFAFromX("dflywngs.xfa",
\par \tab \tab \tab \tab    "dflywngs.x");
\par 
\par \tab // create bird animation
\par \tab CreateXFAFromX("bird.xfa",
\par \tab \tab \tab \tab    "bird.x");
\par 
\par \tab // create lens flare textures
\par \tab CreateLensFlareTextures();
\par 
\par \tab // create ripple texture
\par \tab CreateRippleTextures();
\par */
\par /*
\par \tab // create fish textures
\par \tab if(!CreateFishTextures())
\par \tab \tab return;
\par */
\par /*
\par \tab // create cursor texture
\par \tab CreateDDSFromImage("n_cursor.dds",
\par \tab \tab \tab \tab \tab    "n_cursor.bmp",
\par \tab \tab \tab \tab \tab    TRUE,
\par \tab \tab \tab \tab \tab    D3DCOLOR_RGBA(255,0,0,255));
\par */\tab 
\par #ifdef COMPILE_DATAFILES
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // create data file
\par \tab OpenDataCompiler("..\\\\swanlake.dat");
\par 
\par \tab // add data
\par \tab for(dwCount=0;dwCount<9;dwCount++)
\par \tab \{
\par \tab \tab sprintf(g_lpMsg,"flare%d.dds",dwCount);
\par \tab \tab AddDataFileRef(g_lpMsg);
\par \tab \}
\par \tab for(dwCount=1;dwCount<31;dwCount++)
\par \tab \{
\par \tab \tab sprintf(g_lpMsg,"jfish%d.dds",dwCount);
\par \tab \tab AddDataFileRef(g_lpMsg);
\par \tab \}
\par \tab for(dwCount=0;dwCount<4;dwCount++)
\par \tab \{
\par \tab \tab sprintf(g_lpMsg,"ripple%d.dds",dwCount);
\par \tab \tab AddDataFileRef(g_lpMsg);
\par \tab \}
\par \tab for(dwCount=0;dwCount<64;dwCount++)
\par \tab \{
\par \tab \tab sprintf(g_lpMsg,"water%d.dds",dwCount);
\par \tab \tab AddDataFileRef(g_lpMsg);
\par \tab \}
\par 
\par \tab AddDataFileRef("bbswan.jpg");
\par \tab AddDataFileRef("bird.jpg");
\par \tab AddDataFileRef("dflywngs.jpg");
\par \tab AddDataFileRef("drgfly.jpg");
\par \tab AddDataFileRef("sky.jpg");
\par \tab AddDataFileRef("swan.jpg");
\par \tab AddDataFileRef("trnmap.jpg");
\par \tab AddDataFileRef("trnmap2.jpg");
\par \tab AddDataFileRef("turtle.jpg");
\par 
\par \tab AddDataFileRef("bbswan1.wav");
\par \tab AddDataFileRef("bbswan2.wav");
\par \tab AddDataFileRef("birds1.wav");
\par \tab AddDataFileRef("birds2.wav");
\par \tab AddDataFileRef("buzz1.wav");
\par \tab AddDataFileRef("eagle1.wav");
\par \tab AddDataFileRef("splash1.wav");
\par \tab AddDataFileRef("swan1.wav");
\par \tab AddDataFileRef("swan2.wav");
\par \tab AddDataFileRef("swan3.wav");
\par \tab AddDataFileRef("lecygne1.mid");
\par 
\par \tab AddDataFileRef("drgfly.x");
\par \tab AddDataFileRef("sky.x");
\par \tab AddDataFileRef("terrain.x");
\par \tab AddDataFileRef("bbswan.xfa");
\par \tab AddDataFileRef("bird.xfa");
\par \tab AddDataFileRef("dflywngs.xfa");
\par \tab AddDataFileRef("swan.xfa");
\par \tab AddDataFileRef("turtle.xfa");
\par 
\par \tab AddDataFileRef("clock0.jpg");
\par \tab AddDataFileRef("clock1.jpg");
\par \tab AddDataFileRef("clock2.jpg");
\par \tab AddDataFileRef("clock3.jpg");
\par \tab AddDataFileRef("clock4.jpg");
\par \tab AddDataFileRef("clock5.jpg");
\par \tab AddDataFileRef("clock6.jpg");
\par \tab AddDataFileRef("clock7.jpg");
\par \tab AddDataFileRef("clock8.jpg");
\par \tab AddDataFileRef("clock9.jpg");
\par \tab AddDataFileRef("clockam.jpg");
\par \tab AddDataFileRef("clockpm.jpg");
\par \tab AddDataFileRef("clockcln.jpg");
\par 
\par \tab AddDataFileRef("n_thanks.jpg");
\par \tab AddDataFileRef("n_expsn.jpg");
\par \tab AddDataFileRef("n_expd.jpg");
\par \tab AddDataFileRef("n_tflash.jpg");
\par \tab AddDataFileRef("n_close.jpg");
\par \tab AddDataFileRef("n_redx.jpg");
\par \tab AddDataFileRef("n_blank.bmp");
\par \tab AddDataFileRef("n_digit0.jpg");
\par \tab AddDataFileRef("n_digit1.jpg");
\par \tab AddDataFileRef("n_digit2.jpg");
\par \tab AddDataFileRef("n_digit3.jpg");
\par \tab AddDataFileRef("n_digit4.jpg");
\par \tab AddDataFileRef("n_digit5.jpg");
\par \tab AddDataFileRef("n_digit6.jpg");
\par \tab AddDataFileRef("n_digit7.jpg");
\par \tab AddDataFileRef("n_digit8.jpg");
\par \tab AddDataFileRef("n_digit9.jpg");
\par \tab AddDataFileRef("n_cursor.dds");
\par \tab AddDataFileRef("n_chord1.wav");
\par 
\par \tab // close data file
\par \tab CloseDataCompiler("..\\\\swanlake.dat");
\par #endif
\par \}
\par #endif
\par 
\par // SwanLakeExec()
\par 
\par BOOL SwanLakeExec(void)
\par \{
\par \tab // update scene
\par \tab SwanLakeUpdate();
\par 
\par /*#ifdef DEBUG_MODE
\par \tab // speed up world if necessary
\par \tab if(IsButtonDown(g_dwDefSelectBtn))
\par \tab \tab g_bSpeedMode=TRUE;
\par \tab else
\par \tab \tab g_bSpeedMode=FALSE;
\par #endif*/
\par 
\par \tab // speed up world if necessary
\par \tab if(g_bSpeedMode)
\par \tab \tab for(int n=0;n<9;n++)
\par \tab \tab \tab SwanLakeUpdate();
\par 
\par \tab // render scene
\par \tab SwanLakeRender();
\par 
\par #ifdef DEBUG_MODE
\par \tab // check for exit
\par \tab if(IsKeyDown(VK_ESCAPE))
\par \tab \tab return(FALSE);
\par #endif
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // check for close
\par \tab if(g_bCloseOK)
\par \tab \tab return(FALSE);
\par #endif
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // SwanLakeRelease()
\par 
\par void SwanLakeRelease(void)
\par \{
\par \tab // purge creatures
\par \tab PurgeSwans();
\par \tab PurgeBBSwans();
\par \tab PurgeTurtles();
\par \tab PurgeDragonflies();
\par \tab PurgeFish();
\par \tab PurgeBirds();
\par \tab PurgeRipples();
\par 
\par \tab // release sound effects
\par \tab ReleaseSoundFX();
\par \}
\par 
\par #ifdef DEBUG_MODE
\par // AddTopViewFunctionality()
\par 
\par void AddTopViewFunctionality(void)
\par \{
\par \tab LoadingOutput("AddTopViewFunctionality");
\par 
\par \tab // add top view matrix
\par \tab g_dwTopViewMtx=AddMatrix(1,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab  0,0,1,0,
\par \tab \tab \tab \tab \tab \tab \tab  0,-1,0,0,
\par \tab \tab \tab \tab \tab \tab \tab  TERRAIN_CENTERX,500,TERRAIN_CENTERZ,1);
\par 
\par \tab // add top view button
\par \tab g_dwTopViewBtn=AddInputButton();
\par 
\par \tab // set button trigger
\par \tab AddInputButtonTrigger(g_dwTopViewBtn,DIK_T);
\par \}
\par #endif
\par 
\par // InitLakeScene()
\par 
\par BOOL InitLakeScene(void)
\par \{
\par \tab LoadingOutput("InitLakeScene");
\par 
\par \tab // initialize environment
\par \tab if(!InitEnvironment())
\par \tab \tab return(FALSE);
\par \tab 
\par \tab // initialize water surface\tab 
\par \tab if(!InitWaterSurface())
\par \tab \tab return(FALSE);
\par 
\par \tab // initialize landscape
\par \tab if(!InitLandscape())
\par \tab \tab return(FALSE);
\par 
\par \tab // initialize creatures
\par \tab if(!InitCreatures())
\par \tab \tab return(FALSE);
\par 
\par \tab // initialize lens flare
\par \tab if(!InitLensFlare())
\par \tab \tab return(FALSE);
\par 
\par \tab // initialize ripples
\par \tab if(!InitRipples())
\par \tab \tab return(FALSE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitWaterSurface()
\par 
\par BOOL InitWaterSurface(void)
\par \{
\par \tab LoadingOutput("InitWaterSurface");
\par 
\par \tab // add water material
\par \tab g_dwWaterMat=AddMaterial(0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab  0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab  0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab  1,1,1,1,
\par \tab \tab \tab \tab \tab \tab \tab  0);
\par 
\par \tab // check material
\par \tab if(g_dwWaterMat==NO_OBJECT)
\par \tab \tab return(FALSE);
\par \tab 
\par \tab // add water textures
\par \tab g_dwWaterTex=AddWaterTextures();
\par 
\par \tab // check texture
\par \tab if(g_dwWaterTex==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add water vertex buffer
\par \tab g_dwWaterVtxBuf=AddWaterVertexBuffer();
\par 
\par \tab // check vertex buffer
\par \tab if(g_dwWaterVtxBuf==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add water index buffer
\par \tab g_dwWaterIdxBuf=AddWaterIndexBuffer();
\par 
\par \tab // check index buffer
\par \tab if(g_dwWaterIdxBuf==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitLandscape()
\par 
\par BOOL InitLandscape(void)
\par \{
\par \tab LoadingOutput("InitLandscape");
\par 
\par \tab // add terrain mesh
\par \tab g_dwTerrainMesh=AddMesh("terrain.x",NULL,TRUE,FALSE);
\par 
\par \tab // check mesh
\par \tab if(g_dwTerrainMesh==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // check for low-res terrain
\par \tab if(g_bTerrainHiRes==FALSE||
\par \tab    g_lpDevCaps.MaxTextureWidth<1024||
\par \tab    g_lpDevCaps.MaxTextureHeight<1024)
\par \tab \{
\par \tab \tab // cast subset info pointer
\par \tab \tab LPMESHSUBSETINFO lpMeshSubsetInfo=g_lplpMeshSubsetInfo[g_dwTerrainMesh];
\par \tab 
\par \tab \tab // release hi-res texture
\par \tab \tab ReleaseCOMPtr(g_lplpTex[lpMeshSubsetInfo[0].dwTex]);
\par 
\par \tab \tab // load low-res texture
\par \tab \tab lpMeshSubsetInfo[0].dwTex=AddTexture("trnmap2.jpg");
\par 
\par \tab \tab // check texture
\par \tab \tab if(lpMeshSubsetInfo[0].dwTex==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // add terrain matrix
\par \tab g_dwTerrainMtx=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_dwTerrainMtx==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // scale terrain matrix
\par \tab MatrixScale(g_dwTerrainMtx,TERRAIN_SCALE);
\par 
\par \tab // add sky mesh
\par \tab g_dwSkyMesh=AddMesh("sky.x",NULL,TRUE,FALSE);
\par 
\par \tab // check mesh
\par \tab if(g_dwSkyMesh==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add sky matrix
\par \tab g_dwSkyMtx=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_dwSkyMtx==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // scale sky matrix
\par \tab MatrixScale(g_dwSkyMtx,SKY_SCALE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitEnvironment()
\par 
\par BOOL InitEnvironment(void)
\par \{
\par \tab LoadingOutput("InitEnvironment");
\par 
\par \tab // set texturing mode
\par \tab if(g_bTexSmooth)
\par \tab \tab EnableLinearFilter();
\par \tab else
\par \tab \tab DisableLinearFilter();
\par 
\par \tab // enable vertical billboards
\par \tab EnableVerticalBillboards();
\par 
\par \tab // set fog parameters
\par \tab if(g_bFogMode)
\par \tab \{
\par \tab \tab SetFogStart(FOG_START*TERRAIN_SCALE);
\par \tab \tab SetFogEnd(FOG_END*TERRAIN_SCALE);
\par \tab \tab SetFogColor(FOG_COLOR);
\par \tab \}
\par 
\par \tab // set ambient light
\par \tab SetAmbientLight(AMBIENT_LIGHT);
\par 
\par \tab // set projection matrix
\par \tab SetDefaultProjectionMatrix(1,SKYBOX_RAD*1.25F);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitCreatures()
\par 
\par BOOL InitCreatures(void)
\par \{
\par \tab LoadingOutput("InitCreatures");
\par 
\par \tab // add swan animation
\par \tab g_dwSwanAnim=AddAnimation("swan.xfa");
\par 
\par \tab // check animation
\par \tab if(g_dwSwanAnim==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add baby swan animation
\par \tab g_dwBBSwanAnim=AddAnimation("bbswan.xfa");
\par 
\par \tab // check animation
\par \tab if(g_dwBBSwanAnim==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add turtle animation
\par \tab g_dwTurtleAnim=AddAnimation("turtle.xfa");
\par 
\par \tab // check animation
\par \tab if(g_dwTurtleAnim==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add dragonfly body
\par \tab g_dwDragonflyMesh=AddMesh("drgfly.x");
\par 
\par \tab // check mesh
\par \tab if(g_dwDragonflyMesh==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add dragonfly wing animation
\par \tab g_dwDragonflyWingAnim=AddAnimation("dflywngs.xfa");
\par 
\par \tab // check animation
\par \tab if(g_dwDragonflyWingAnim==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add fish textures
\par \tab g_dwFishTex=AddFishTextures();
\par 
\par \tab // check texture
\par \tab if(g_dwFishTex==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add bird animation
\par \tab g_dwBirdAnim=AddAnimation("bird.xfa");
\par 
\par \tab // check animation
\par \tab if(g_dwBirdAnim==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add creatures
\par \tab if(!AddCreatures())
\par \tab \tab return(FALSE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitLensFlare()
\par 
\par BOOL InitLensFlare(void)
\par \{
\par \tab LoadingOutput("InitLensFlare");
\par 
\par \tab // init lens flare data
\par \tab InitLensFlareData(&g_lfd,
\par \tab \tab \tab \tab \tab   "flare%d.dds",
\par \tab \tab \tab \tab \tab   NUM_FLARERINGS,
\par \tab \tab \tab \tab \tab   4.0F,
\par \tab \tab \tab \tab \tab   128,
\par \tab \tab \tab \tab \tab   32,
\par \tab \tab \tab \tab \tab   96,
\par \tab \tab \tab \tab \tab   1,1,1,
\par \tab \tab \tab \tab \tab   1.2F,
\par \tab \tab \tab \tab \tab   0.7F,
\par \tab \tab \tab \tab \tab   1.0F);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par #ifdef DEBUG_MODE
\par // CreateWaterTextures()
\par 
\par BOOL CreateWaterTextures(DWORD dwTexSize,
\par \tab \tab \tab \tab \tab \tab  DWORD dwNumTex,
\par \tab \tab \tab \tab \tab \tab  DWORD dwSkip1,
\par \tab \tab \tab \tab \tab \tab  DWORD dwSkip2,
\par \tab \tab \tab \tab \tab \tab  float fR1,
\par \tab \tab \tab \tab \tab \tab  float fG1,
\par \tab \tab \tab \tab \tab \tab  float fB1,
\par \tab \tab \tab \tab \tab \tab  float fR2,
\par \tab \tab \tab \tab \tab \tab  float fG2,
\par \tab \tab \tab \tab \tab \tab  float fB2,
\par \tab \tab \tab \tab \tab \tab  float fAMin,
\par \tab \tab \tab \tab \tab \tab  float fAMax,
\par \tab \tab \tab \tab \tab \tab  int nDropRatio,
\par \tab \tab \tab \tab \tab      float fMaxWaveHeight,
\par \tab \tab \tab \tab \tab      float fDecayFactor,
\par \tab \tab \tab \tab \tab      float fAccelFactor,
\par \tab \tab \tab \tab \tab      float fTransferFactor,
\par \tab \tab \tab \tab \tab \tab  LPCSTR lpFileName)
\par \{
\par \tab // counters
\par \tab DWORD dwCount;
\par 
\par \tab // water surface values
\par \tab float* lpfCur;
\par \tab float* lpfNew;
\par \tab float* lpfSpd;
\par 
\par \tab // compute memory size
\par \tab DWORD dwMemSize=Squared(dwTexSize)*sizeof(float);
\par 
\par \tab // allocate water surface values
\par \tab if(!AllocMem((LPVOID*)&lpfCur,
\par \tab \tab \tab \tab  dwMemSize))
\par \tab \tab return(FALSE);
\par \tab if(!AllocMem((LPVOID*)&lpfNew,
\par \tab \tab \tab \tab  dwMemSize))
\par \tab \tab return(FALSE);
\par \tab if(!AllocMem((LPVOID*)&lpfSpd,
\par \tab \tab \tab \tab  dwMemSize))
\par \tab \tab return(FALSE);
\par 
\par \tab // init water surface values
\par \tab ZeroMemory((LPVOID)lpfCur,
\par \tab \tab \tab    dwMemSize);
\par \tab ZeroMemory((LPVOID)lpfNew,
\par \tab \tab \tab    dwMemSize);
\par \tab ZeroMemory((LPVOID)lpfSpd,
\par \tab \tab \tab    dwMemSize);
\par 
\par \tab // add first rendering texture
\par \tab DWORD dwTexIndex=AddTexture(dwTexSize,
\par \tab \tab \tab \tab \tab \tab \tab \tab dwTexSize,
\par \tab \tab \tab \tab \tab \tab \tab \tab TRUE,
\par \tab \tab \tab \tab \tab \tab \tab \tab TRUE);
\par 
\par \tab // add remaining rendering textures
\par \tab for(dwCount=1;dwCount<dwNumTex;dwCount++)
\par \tab \tab AddTexture(dwTexSize,
\par \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab    TRUE,
\par \tab \tab \tab \tab    TRUE);
\par 
\par \tab // update to first skip value
\par \tab for(dwCount=0;dwCount<dwSkip1;dwCount++)
\par \tab \tab UpdateWaterSurface(lpfCur,
\par \tab \tab \tab \tab \tab \tab    lpfNew,
\par \tab \tab \tab \tab \tab \tab    lpfSpd,
\par \tab \tab \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab \tab \tab    nDropRatio,
\par \tab \tab \tab \tab \tab        fMaxWaveHeight,
\par \tab \tab \tab \tab \tab        fDecayFactor,
\par \tab \tab \tab \tab \tab        fAccelFactor,
\par \tab \tab \tab \tab \tab        fTransferFactor);
\par 
\par \tab // render textures
\par \tab for(dwCount=0;dwCount<dwNumTex;dwCount++)
\par \tab \{
\par \tab \tab // update surface
\par \tab \tab UpdateWaterSurface(lpfCur,
\par \tab \tab \tab \tab \tab \tab    lpfNew,
\par \tab \tab \tab \tab \tab \tab    lpfSpd,
\par \tab \tab \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab \tab \tab    nDropRatio,
\par \tab \tab \tab \tab \tab        fMaxWaveHeight,
\par \tab \tab \tab \tab \tab        fDecayFactor,
\par \tab \tab \tab \tab \tab        fAccelFactor,
\par \tab \tab \tab \tab \tab        fTransferFactor);
\par 
\par \tab \tab // render surface
\par \tab \tab RenderWaterTexture(lpfCur,
\par \tab \tab \tab \tab \tab \tab    dwTexIndex+dwCount,
\par \tab \tab \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab \tab \tab    fR1,
\par \tab \tab \tab \tab \tab \tab    fG1,
\par \tab \tab \tab \tab \tab \tab    fB1,
\par \tab \tab \tab \tab \tab \tab    fR2,
\par \tab \tab \tab \tab \tab \tab    fG2,
\par \tab \tab \tab \tab \tab \tab    fB2,
\par \tab \tab \tab \tab \tab \tab    fAMin,
\par \tab \tab \tab \tab \tab \tab    fAMax,
\par \tab \tab \tab \tab \tab \tab    1);
\par \tab \}
\par 
\par \tab // compute number of textures/2
\par \tab DWORD dwNumTex2=dwNumTex>>1;
\par \tab 
\par \tab // rotate textures
\par \tab for(dwCount=0;dwCount<dwNumTex2;dwCount++)
\par \tab \tab SwapTextureSurfaces(dwTexIndex+dwCount,
\par \tab \tab \tab \tab \tab \tab \tab dwTexIndex+dwCount+dwNumTex2);
\par 
\par \tab // update to second skip value
\par \tab for(dwCount=0;dwCount<dwSkip2;dwCount++)
\par \tab \tab UpdateWaterSurface(lpfCur,
\par \tab \tab \tab \tab \tab \tab    lpfNew,
\par \tab \tab \tab \tab \tab \tab    lpfSpd,
\par \tab \tab \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab \tab \tab    nDropRatio,
\par \tab \tab \tab \tab \tab        fMaxWaveHeight,
\par \tab \tab \tab \tab \tab        fDecayFactor,
\par \tab \tab \tab \tab \tab        fAccelFactor,
\par \tab \tab \tab \tab \tab        fTransferFactor);
\par 
\par \tab // render textures
\par \tab for(dwCount=0;dwCount<dwNumTex;dwCount++)
\par \tab \{
\par \tab \tab // update surface
\par \tab \tab UpdateWaterSurface(lpfCur,
\par \tab \tab \tab \tab \tab \tab    lpfNew,
\par \tab \tab \tab \tab \tab \tab    lpfSpd,
\par \tab \tab \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab \tab \tab    nDropRatio,
\par \tab \tab \tab \tab \tab        fMaxWaveHeight,
\par \tab \tab \tab \tab \tab        fDecayFactor,
\par \tab \tab \tab \tab \tab        fAccelFactor,
\par \tab \tab \tab \tab \tab        fTransferFactor);
\par 
\par \tab \tab // blend value
\par \tab \tab float fBlend;
\par 
\par \tab \tab // compute blend value
\par \tab \tab if(dwCount<dwNumTex2)
\par \tab \tab \tab fBlend=((float)((dwNumTex2-1)-dwCount))/((float)(dwNumTex2-1));
\par \tab \tab else
\par \tab \tab \tab fBlend=((float)(dwCount-dwNumTex2))/((float)(dwNumTex2-1));
\par \tab \tab 
\par \tab \tab // render surface
\par \tab \tab RenderWaterTexture(lpfCur,
\par \tab \tab \tab \tab \tab \tab    dwTexIndex+dwCount,
\par \tab \tab \tab \tab \tab \tab    dwTexSize,
\par \tab \tab \tab \tab \tab \tab    fR1,
\par \tab \tab \tab \tab \tab \tab    fG1,
\par \tab \tab \tab \tab \tab \tab    fB1,
\par \tab \tab \tab \tab \tab \tab    fR2,
\par \tab \tab \tab \tab \tab \tab    fG2,
\par \tab \tab \tab \tab \tab \tab    fB2,
\par \tab \tab \tab \tab \tab \tab    fAMin,
\par \tab \tab \tab \tab \tab \tab    fAMax,
\par \tab \tab \tab \tab \tab \tab    1-fBlend);
\par \tab \}
\par 
\par \tab // release water surface memory
\par \tab FreeMem((LPVOID*)&lpfCur);
\par \tab FreeMem((LPVOID*)&lpfNew);
\par \tab FreeMem((LPVOID*)&lpfSpd);
\par 
\par \tab // output water textures
\par \tab for(dwCount=0;dwCount<dwNumTex;dwCount++)
\par \tab \{
\par \tab \tab // generate filename
\par \tab \tab char lpDestFile[16];
\par \tab \tab sprintf(lpDestFile,
\par \tab \tab \tab \tab lpFileName,
\par \tab \tab \tab \tab dwCount);
\par 
\par \tab \tab // output image
\par \tab \tab CreateDDSFromTexture(lpDestFile,
\par \tab \tab \tab \tab \tab \tab \tab  dwTexIndex+dwCount);
\par \tab \}
\par \tab 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // UpdateWaterSurface()\tab \tab \tab \tab \tab \tab  
\par 
\par void UpdateWaterSurface(float* lpfCur,
\par \tab \tab \tab \tab \tab \tab float* lpfNew,
\par \tab \tab \tab \tab \tab \tab float* lpfSpd,
\par \tab \tab \tab \tab \tab \tab DWORD dwTexSize,
\par \tab \tab \tab \tab \tab \tab int nDropRatio,
\par \tab \tab \tab \tab \tab     float fMaxWaveHeight,
\par \tab \tab \tab \tab \tab     float fDecayFactor,
\par \tab \tab \tab \tab \tab     float fAccelFactor,
\par \tab \tab \tab \tab \tab     float fTransferFactor)
\par \{
\par \tab // counters
\par \tab DWORD dwX;
\par \tab DWORD dwY;
\par 
\par \tab // compute texture size mask
\par \tab DWORD dwTexSizeMask=dwTexSize-1;
\par 
\par \tab // compute accel/transfer factor
\par \tab float fAccTransFactor=fAccelFactor*fTransferFactor;
\par 
\par \tab // add drop if necessary
\par \tab if((abs(GetRandomInt())%nDropRatio)==1)
\par \tab \{
\par \tab \tab // get random position
\par \tab \tab dwX=GetRandomInt()&dwTexSizeMask;
\par \tab \tab dwY=GetRandomInt()&dwTexSizeMask;
\par 
\par \tab \tab // add drop
\par \tab \tab lpfCur[dwX+(dwY*dwTexSize)]=GetRandomFloat()*fMaxWaveHeight;
\par \tab \}
\par 
\par \tab // update water surface
\par \tab for(dwX=0;dwX<dwTexSize;dwX++)
\par \tab \tab for(dwY=0;dwY<dwTexSize;dwY++)
\par \tab \tab \{
\par \tab \tab \tab // compute offset values
\par \tab \tab \tab DWORD dwXP1=(dwX+1)&dwTexSizeMask;
\par \tab \tab \tab DWORD dwXM1=(dwX-1)&dwTexSizeMask;
\par \tab \tab \tab DWORD dwYP1=(dwY+1)&dwTexSizeMask;
\par \tab \tab \tab DWORD dwYM1=(dwY-1)&dwTexSizeMask;
\par 
\par \tab \tab \tab // compute position value
\par \tab \tab \tab DWORD dwCurPos=dwX+(dwY*dwTexSize);
\par 
\par \tab \tab \tab // check height of current position
\par \tab \tab \tab if(lpfCur[dwCurPos]<0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // update speed table
\par \tab \tab \tab \tab lpfSpd[dwCurPos]+=fAccelFactor;
\par \tab \tab \tab \tab lpfSpd[dwXP1+(dwY*dwTexSize)]+=fAccTransFactor;
\par \tab \tab \tab \tab lpfSpd[dwXM1+(dwY*dwTexSize)]+=fAccTransFactor;
\par \tab \tab \tab \tab lpfSpd[dwX+(dwYP1*dwTexSize)]+=fAccTransFactor;
\par \tab \tab \tab \tab lpfSpd[dwX+(dwYM1*dwTexSize)]+=fAccTransFactor;
\par \tab \tab \tab \}
\par \tab \tab \tab else if(lpfCur[dwX+(dwY*dwTexSize)]>0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // update speed table
\par \tab \tab \tab \tab lpfSpd[dwCurPos]-=fAccelFactor;
\par \tab \tab \tab \tab lpfSpd[dwXP1+(dwY*dwTexSize)]-=fAccTransFactor;
\par \tab \tab \tab \tab lpfSpd[dwXM1+(dwY*dwTexSize)]-=fAccTransFactor;
\par \tab \tab \tab \tab lpfSpd[dwX+(dwYP1*dwTexSize)]-=fAccTransFactor;
\par \tab \tab \tab \tab lpfSpd[dwX+(dwYM1*dwTexSize)]-=fAccTransFactor;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // compute new height
\par \tab \tab \tab lpfNew[dwCurPos]=(lpfCur[dwCurPos]+lpfSpd[dwCurPos])*fDecayFactor;
\par \tab \tab \}
\par 
\par \tab // copy new table to current table
\par \tab CopyMemory(lpfCur,
\par \tab \tab \tab    lpfNew,
\par \tab \tab \tab    Squared(dwTexSize)*sizeof(float));
\par \}
\par 
\par // RenderWaterTexture()\tab 
\par 
\par void RenderWaterTexture(float* lpfCur,
\par \tab \tab \tab \tab \tab \tab DWORD dwTexIndex,
\par \tab \tab \tab \tab \tab \tab DWORD dwTexSize,
\par \tab \tab \tab \tab \tab \tab float fR1,
\par \tab \tab \tab \tab \tab \tab float fG1,
\par \tab \tab \tab \tab \tab \tab float fB1,
\par \tab \tab \tab \tab \tab \tab float fR2,
\par \tab \tab \tab \tab \tab \tab float fG2,
\par \tab \tab \tab \tab \tab \tab float fB2,
\par \tab \tab \tab \tab \tab \tab float fAMin,
\par \tab \tab \tab \tab \tab \tab float fAMax,
\par \tab \tab \tab \tab \tab \tab float fBlend)
\par \{
\par \tab // counters
\par \tab DWORD dwX;
\par \tab DWORD dwY;
\par 
\par \tab // compute texture size mask
\par \tab DWORD dwTexSizeMask=dwTexSize-1;
\par 
\par \tab // compute alpha range
\par \tab float fARange=fAMax-fAMin;
\par 
\par \tab // do not allow zero blend
\par \tab if(fBlend<EPSILON)
\par \tab \tab fBlend=EPSILON;
\par 
\par \tab // lock texture
\par \tab D3DLOCKED_RECT lr=LockTexture(dwTexIndex);
\par 
\par \tab // extract data pointer & pitch
\par \tab LPWORD lpData=(LPWORD)lr.pBits;
\par \tab DWORD dwPitch=lr.Pitch>>1;
\par 
\par \tab // render surface
\par \tab for(dwX=0;dwX<dwTexSize;dwX++)
\par \tab \tab for(dwY=0;dwY<dwTexSize;dwY++)
\par \tab \tab \{
\par \tab \tab \tab // get original color
\par \tab \tab \tab WORD wOldColor=lpData[dwX+(dwY*dwPitch)];
\par 
\par \tab \tab \tab // extract components
\par \tab \tab \tab float fROld=GetR444(wOldColor);
\par \tab \tab \tab float fGOld=GetG444(wOldColor);
\par \tab \tab \tab float fBOld=GetB444(wOldColor);
\par \tab \tab \tab float fAOld=GetA444(wOldColor);
\par 
\par \tab \tab \tab // compute offset values
\par \tab \tab \tab DWORD dwXP1=(dwX+1)&dwTexSizeMask;
\par \tab \tab \tab DWORD dwXM1=(dwX-1)&dwTexSizeMask;
\par \tab \tab \tab DWORD dwYP1=(dwY+1)&dwTexSizeMask;
\par \tab \tab \tab DWORD dwYM1=(dwY-1)&dwTexSizeMask;
\par 
\par \tab \tab \tab // compute vertices
\par \tab \tab \tab D3DXVECTOR3 vC=D3DXVECTOR3(0,lpfCur[dwX+(dwY*dwTexSize)],0);
\par \tab \tab \tab D3DXVECTOR3 vL=D3DXVECTOR3(-1,lpfCur[dwXM1+(dwY*dwTexSize)],0);
\par \tab \tab \tab D3DXVECTOR3 vR=D3DXVECTOR3(1,lpfCur[dwXP1+(dwY*dwTexSize)],0);
\par \tab \tab \tab D3DXVECTOR3 vT=D3DXVECTOR3(0,lpfCur[dwX+(dwYM1*dwTexSize)],-1);
\par \tab \tab \tab D3DXVECTOR3 vB=D3DXVECTOR3(0,lpfCur[dwX+(dwYP1*dwTexSize)],1);
\par \tab \tab \tab 
\par \tab \tab \tab // compute plane normals
\par \tab \tab \tab D3DXVECTOR3 vN1,vN2,vN3,vN4;
\par \tab \tab \tab GetPlaneNormal(&vN1,&vT,&vC,&vR);
\par \tab \tab \tab GetPlaneNormal(&vN2,&vR,&vC,&vB);
\par \tab \tab \tab GetPlaneNormal(&vN3,&vB,&vC,&vL);
\par \tab \tab \tab GetPlaneNormal(&vN4,&vL,&vC,&vT);
\par \tab \tab \tab 
\par \tab \tab \tab // compute average normal
\par \tab \tab \tab D3DXVECTOR3 vN=(vN1+vN2+vN3+vN4)*0.25F;
\par \tab \tab \tab 
\par \tab \tab \tab // compute distance from vertical
\par \tab \tab \tab float fDV=sqrtf(Squared(vN.x)+Squared(vN.y));
\par 
\par \tab \tab \tab // compute color values
\par \tab \tab \tab float fR=fR1+((fR2-fR1)*fDV);
\par \tab \tab \tab float fG=fG1+((fG2-fG1)*fDV);
\par \tab \tab \tab float fB=fB1+((fB2-fB1)*fDV);
\par 
\par \tab \tab \tab // compute alpha value
\par \tab \tab \tab float fA=((1-fDV)*fARange)+fAMin;
\par \tab \tab \tab 
\par \tab \tab \tab // interpolate components
\par \tab \tab \tab float fRNew=fROld+((fR-fROld)*fBlend);
\par \tab \tab \tab float fGNew=fGOld+((fG-fGOld)*fBlend);
\par \tab \tab \tab float fBNew=fBOld+((fB-fBOld)*fBlend);
\par \tab \tab \tab float fANew=fAOld+((fA-fAOld)*fBlend);
\par 
\par \tab \tab \tab // set new color
\par \tab \tab \tab SetRGBA444(lpData[dwX+(dwY*dwPitch)],
\par \tab \tab \tab \tab \tab    fRNew,fGNew,fBNew,fANew);
\par \tab \tab \}
\par 
\par \tab // unlock texture
\par \tab UnlockTexture(dwTexIndex);
\par \}
\par #endif
\par 
\par // AddWaterTextures()
\par 
\par DWORD AddWaterTextures(DWORD dwNumTex,
\par \tab \tab \tab \tab \tab    LPCSTR lpFileName)
\par \{
\par \tab LoadingOutput("AddWaterTextures");
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par \tab 
\par \tab // texture index
\par \tab DWORD dwTexIndex=NO_OBJECT;
\par \tab 
\par \tab // add water textures
\par \tab for(dwCount=0;dwCount<dwNumTex;dwCount++)
\par \tab \{
\par \tab \tab // generate filename
\par \tab \tab char lpDestFile[16];
\par \tab \tab sprintf(lpDestFile,
\par \tab \tab \tab \tab lpFileName,
\par \tab \tab \tab \tab dwCount);
\par 
\par \tab \tab // load image
\par \tab \tab DWORD dwIndex=AddTexture(lpDestFile);
\par 
\par \tab \tab // check texture
\par \tab \tab if(dwIndex==NO_OBJECT)
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // check for first texture
\par \tab \tab if(dwCount==0)
\par \tab \tab \tab dwTexIndex=dwIndex;
\par \tab \}
\par 
\par \tab // return index
\par \tab return(dwTexIndex);
\par \}
\par 
\par // AddWaterVertexBuffer()
\par 
\par DWORD AddWaterVertexBuffer(void)
\par \{
\par \tab LoadingOutput("AddWaterVertexBuffer");
\par 
\par \tab // water vertex data
\par \tab LPWATERVERTEX lpWaterVtx;
\par \tab 
\par \tab // create water vertex buffer
\par \tab DWORD dwVtxBuf=AddVertexBuffer(D3DFVF_WATERVERTEX,
\par \tab \tab \tab \tab \tab \tab \tab \tab    sizeof(WATERVERTEX),
\par \tab \tab \tab \tab \tab \tab \tab \tab    4);
\par 
\par \tab // check vertex buffer
\par \tab if(dwVtxBuf==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // lock water vertex buffer
\par \tab lpWaterVtx=(LPWATERVERTEX)LockVertexBuffer(dwVtxBuf);
\par 
\par \tab // check for error
\par \tab if(!lpWaterVtx)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // fill in vertices
\par \tab SET_WATERVERTEX(lpWaterVtx[0],
\par \tab \tab \tab \tab \tab -WSURF_RAD,0,-WSURF_RAD,
\par \tab \tab \tab \tab \tab -(WSURF_RAD/WSURF_SIZE),-(WSURF_RAD/WSURF_SIZE));
\par \tab SET_WATERVERTEX(lpWaterVtx[1],
\par \tab \tab \tab \tab \tab WSURF_RAD,0,-WSURF_RAD,
\par \tab \tab \tab \tab \tab (WSURF_RAD/WSURF_SIZE),-(WSURF_RAD/WSURF_SIZE));
\par \tab SET_WATERVERTEX(lpWaterVtx[2],
\par \tab \tab \tab \tab \tab -WSURF_RAD,0,WSURF_RAD,
\par \tab \tab \tab \tab \tab -(WSURF_RAD/WSURF_SIZE),(WSURF_RAD/WSURF_SIZE));
\par \tab SET_WATERVERTEX(lpWaterVtx[3],
\par \tab \tab \tab \tab \tab WSURF_RAD,0,WSURF_RAD,
\par \tab \tab \tab \tab \tab (WSURF_RAD/WSURF_SIZE),(WSURF_RAD/WSURF_SIZE));
\par 
\par \tab // unlock vertex buffer
\par \tab UnlockVertexBuffer(dwVtxBuf);
\par 
\par \tab // return index
\par \tab return(dwVtxBuf);
\par \}
\par 
\par // AddWaterIndexBuffer()
\par 
\par DWORD AddWaterIndexBuffer(void)
\par \{
\par \tab LoadingOutput("AddWaterIndexBuffer");
\par 
\par \tab // water index data
\par \tab LPWORD lpwWaterIdx;
\par \tab 
\par \tab // create water index buffer
\par \tab DWORD dwIdxBuf=AddIndexBuffer(D3DPT_TRIANGLESTRIP,
\par \tab \tab \tab \tab \tab \tab \tab \tab   2);
\par 
\par \tab // check index buffer
\par \tab if(dwIdxBuf==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // lock water index buffer
\par \tab lpwWaterIdx=(LPWORD)LockIndexBuffer(dwIdxBuf);
\par \tab 
\par \tab // check for error
\par \tab if(!lpwWaterIdx)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // fill in indices
\par \tab lpwWaterIdx[0]=0;
\par \tab lpwWaterIdx[1]=2;
\par \tab lpwWaterIdx[2]=1;
\par \tab lpwWaterIdx[3]=3;
\par 
\par \tab // unlock index buffer
\par \tab UnlockIndexBuffer(dwIdxBuf);
\par 
\par \tab // return index
\par \tab return(dwIdxBuf);
\par \}
\par 
\par // GetWaterTexture()
\par 
\par DWORD GetWaterTexture(void)
\par \{
\par \tab // texture counter
\par \tab static DWORD dwTexCount=0;
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // check for nag screen
\par \tab if(!g_bNagScreen)
\par #endif
\par \tab \{
\par \tab \tab // update texture counter
\par \tab \tab dwTexCount+=g_dwFrameSkip;
\par \tab \}
\par 
\par \tab // compute texture number
\par \tab DWORD dwTexNum=(dwTexCount>>WSURF_SLOWDOWN)&(WSURF_NUMTEX-1);
\par 
\par \tab // return texture number
\par \tab return(dwTexNum);
\par \}
\par 
\par // GetWaterPosition()
\par 
\par float GetWaterPosition(void)
\par \{
\par \tab // water position
\par \tab static float fWaterPos=0;
\par \tab 
\par #ifdef SHAREWARE_MODE
\par \tab // check for nag screen
\par \tab if(!g_bNagScreen)
\par #endif
\par \tab \{
\par \tab \tab // update water position
\par \tab \tab fWaterPos+=(WSURF_MOVEINC*((float)g_dwFrameSkip));
\par \tab \}
\par \tab 
\par \tab // check for overflow
\par \tab while(fWaterPos>WSURF_SIZE)
\par \tab \tab fWaterPos-=WSURF_SIZE;
\par 
\par \tab // return position
\par \tab return(fWaterPos);
\par \}
\par 
\par // RenderWaterSurface()
\par 
\par void RenderWaterSurface(void)
\par \{
\par \tab // get water texture
\par \tab DWORD dwTexNum=GetWaterTexture();
\par 
\par \tab // get water position
\par \tab float fWaterPos=GetWaterPosition();
\par 
\par \tab // prepare matrix
\par \tab D3DXMATRIX mtx=D3DXMATRIX(1,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab   0,1,0,0,
\par \tab \tab \tab \tab \tab \tab \tab   0,0,1,0,
\par \tab \tab \tab \tab \tab \tab \tab   fWaterPos,0,fWaterPos,1);
\par 
\par \tab // set matrix
\par \tab SetWorldMatrix(&mtx);
\par 
\par \tab // set material
\par \tab SetMaterial(g_dwWaterMat);
\par 
\par \tab // set texture
\par \tab SetTexture(g_dwWaterTex+dwTexNum);
\par 
\par \tab // set vertex buffer
\par \tab SetVertexBuffer(g_dwWaterVtxBuf);
\par 
\par \tab // set index buffer
\par \tab SetIndexBuffer(g_dwWaterIdxBuf);
\par 
\par \tab // render water
\par \tab RenderPrimitive();
\par \}
\par 
\par // SwanLakeUpdate()
\par 
\par void SwanLakeUpdate(void)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // update nag screen
\par \tab if(!g_bInitUpdates)
\par \tab \tab for(dwCount=0;dwCount<g_dwFrameSkip;dwCount++)
\par \tab \tab \tab UpdateNagScreen();
\par 
\par \tab // check nag screen flag
\par \tab if(g_bNagScreen)
\par \tab \tab return;
\par 
\par \tab // check days left
\par \tab if(g_dwTrialDays==0)
\par \tab \tab return;
\par #endif
\par 
\par \tab // update based on frame skip
\par \tab for(dwCount=0;dwCount<g_dwFrameSkip;dwCount++)
\par \tab \{
\par \tab \tab // update creatures
\par \tab \tab UpdateSwans();
\par \tab \tab UpdateBBSwans();
\par \tab \tab UpdateTurtles();
\par \tab \tab UpdateDragonflies();
\par \tab \tab UpdateFish();
\par \tab \tab UpdateBirds();
\par 
\par \tab \tab // update ripples
\par \tab \tab UpdateRipples();
\par 
\par \tab \tab // update camera
\par \tab \tab UpdateCameraObject();
\par 
\par \tab \tab // update sound effects
\par \tab \tab if(!g_bInitUpdates)
\par \tab \tab \tab UpdateSoundFX();
\par 
\par \tab \tab // update fade-in value
\par \tab \tab if(g_fFadeIn>0.0F)
\par \tab \tab \tab g_fFadeIn-=CAMERA_FADEININC;
\par \tab \}
\par \}
\par 
\par // SwanLakeRender()
\par 
\par void SwanLakeRender(void)
\par \{
\par \tab // frame rate display buffer
\par \tab char lpFPS[12];
\par 
\par \tab // clear z-buffer
\par \tab ClearZBuffer();
\par 
\par \tab // set camera to view matrix
\par \tab SetCameraObjectToViewMatrix();
\par 
\par \tab // begin render
\par \tab if(BeginScene())
\par \tab \{
\par \tab \tab // render sky
\par \tab \tab RenderMesh(g_dwSkyMesh,g_dwSkyMtx);
\par 
\par \tab \tab // enable fog
\par \tab \tab if(g_bFogMode)
\par \tab \tab \tab EnableFog();
\par 
\par \tab \tab // enable smooth shading
\par \tab \tab if(g_bShadeSmooth)
\par \tab \tab \tab EnableGouraud();
\par 
\par \tab \tab // render terrain
\par \tab \tab RenderMesh(g_dwTerrainMesh,g_dwTerrainMtx);
\par 
\par \tab \tab // render swans, baby swans, birds & dragonfly bodies
\par \tab \tab RenderSwans();
\par \tab \tab RenderBBSwans();
\par \tab \tab RenderBirds();
\par \tab \tab RenderDragonfliesA();
\par 
\par \tab \tab // enable alpha blend
\par \tab \tab EnableAlphaBlend();
\par 
\par \tab \tab // render turtles
\par \tab \tab RenderTurtles();
\par 
\par \tab \tab // disable fog
\par \tab \tab if(g_bFogMode)
\par \tab \tab \tab DisableFog();
\par 
\par \tab \tab // disable smooth shading
\par \tab \tab if(g_bShadeSmooth)
\par \tab \tab \tab DisableGouraud();
\par 
\par \tab \tab // enable alpha textures
\par \tab \tab EnableAlphaTextures();
\par 
\par \tab \tab // enable alpha testing
\par \tab \tab EnableAlphaTest();
\par 
\par \tab \tab // render fish
\par \tab \tab RenderFish();
\par 
\par \tab \tab // render ripples
\par \tab \tab if(g_bUseRipples)
\par \tab \tab \tab RenderRipples();
\par 
\par \tab \tab // disable alpha testing
\par \tab \tab DisableAlphaTest();
\par \tab \tab 
\par \tab \tab // render water surface
\par \tab \tab RenderWaterSurface();
\par 
\par \tab \tab // render lens flare
\par \tab \tab if(g_bLensFlareMode)
\par \tab \tab \tab RenderLensFlare(&g_lfd,
\par \tab \tab \tab \tab \tab \tab \tab SUN_XPOS,
\par \tab \tab \tab \tab \tab \tab \tab SUN_YPOS,
\par \tab \tab \tab \tab \tab \tab \tab SUN_ZPOS);
\par 
\par \tab \tab // disable alpha textures
\par \tab \tab DisableAlphaTextures();
\par 
\par \tab \tab // render dragonfly wings
\par \tab \tab RenderDragonfliesB();
\par 
\par // uncomment to render boundaries
\par /*\tab \tab 
\par static DWORD m=NO_OBJECT;
\par static DWORD m1=NO_OBJECT;
\par static DWORD m2=NO_OBJECT;
\par if(m==NO_OBJECT)
\par \{
\par \tab m=AddMeshSphere(TERRAIN_XRANGE,8,8,AddMaterial(1,0,0,0.3F,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    1,0,0,0.3F,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    0));
\par \tab m1=AddMatrix(1,0,0,0,
\par \tab \tab \tab \tab  0,1,0,0,
\par \tab \tab \tab \tab  0,0,1,0,
\par \tab \tab \tab \tab  TERRAIN_CENTERX,0,TERRAIN_CENTERZ+TERRAIN_ZRANGE,1);
\par \tab m2=AddMatrix(1,0,0,0,
\par \tab \tab \tab \tab  0,1,0,0,
\par \tab \tab \tab \tab  0,0,1,0,
\par \tab \tab \tab \tab  TERRAIN_CENTERX,0,TERRAIN_CENTERZ-TERRAIN_ZRANGE,1);
\par \}
\par RenderMesh(m,m1);
\par RenderMesh(m,m2);
\par */
\par \tab \tab 
\par \tab \tab // render clock if necessary
\par \tab \tab if(g_bShowClock)
\par \tab \tab \tab RenderClock();
\par 
\par \tab \tab // fade screen if necessary
\par \tab \tab if(g_fFadeIn>0.0F)
\par \tab \tab \tab if(g_fFadeIn>1.0F)
\par \tab \tab \tab \tab FadeScreen(D3DCOLOR_COLORVALUE(0.0F,0.0F,0.0F,1.0F));
\par \tab \tab \tab else
\par \tab \tab \tab \tab FadeScreen(D3DCOLOR_COLORVALUE(0.0F,0.0F,0.0F,g_fFadeIn));
\par 
\par \tab \tab // disable alpha blend
\par \tab \tab DisableAlphaBlend();
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab // check nag screen flag
\par \tab \tab if(g_bNagScreen)
\par \tab \tab \{
\par \tab \tab \tab // render nag screen
\par \tab \tab \tab RenderNagScreen();
\par 
\par \tab \tab \tab // render mouse cursor
\par \tab \tab \tab RenderMouseCursor();
\par \tab \tab \}
\par #endif
\par 
\par \tab \tab // end scene
\par \tab \tab EndScene();
\par \tab \}
\par 
\par \tab // render sound effects
\par \tab RenderSoundFX();
\par 
\par \tab // present scene
\par \tab PresentScene();
\par 
\par \tab // display fps info if necessary
\par \tab if(g_bFrameRate)
\par \tab \tab if(BeginText(g_dwFPSFont))
\par \tab \tab \{
\par \tab \tab \tab sprintf(lpFPS,"%d",g_dwFPS);
\par \tab \tab \tab OutputText(lpFPS,0,0);
\par #ifdef DEBUG_MODE
\par \tab \tab \tab sprintf(lpFPS,"%d",g_dwUPS);
\par \tab \tab \tab OutputText(lpFPS,0,16);
\par #endif
\par \tab \tab \tab EndText();
\par \tab \tab \}
\par \}
\par 
\par // GetNextSwan()
\par 
\par DWORD GetNextSwan(void)
\par \{
\par \tab LoadingOutput("GetNextSwan");
\par 
\par \tab // check counter
\par \tab if(g_dwNumSwan==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanMtx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanPriState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanActState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanNavState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanKeyframe1,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanKeyframe2,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfSwanTweenVal,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfSwanTailPos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfSwanTailDir,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfSwanTransPos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfSwanTransSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanTransKey1,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanTransKey2,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfSwanNavSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanNavPos,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanNavMax,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanMateIdx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanRipple1Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwSwanRipple2Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxSwan=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumSwan>=g_dwMaxSwan)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanMtx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanPriState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanActState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanNavState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanKeyframe1,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanKeyframe2,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfSwanTweenVal,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfSwanTailPos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfSwanTailDir,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfSwanTransPos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfSwanTransSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanTransKey1,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanTransKey2,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfSwanNavSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanNavPos,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanNavMax,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanMateIdx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanRipple1Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwSwanRipple2Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxSwan+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumSwan;
\par 
\par \tab // increment counter
\par \tab g_dwNumSwan++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddSwan()
\par 
\par DWORD AddSwan(void)
\par \{
\par \tab LoadingOutput("AddSwan");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextSwan();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add swan matrix
\par \tab g_lpdwSwanMtx[dwIndex]=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_lpdwSwanMtx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // scale matrix by swan scale
\par \tab MatrixScale(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab SWAN_SCALE+(GetRandomFloat()*SWAN_SCALEVAR));
\par 
\par \tab // set default values
\par \tab g_lpdwSwanPriState[dwIndex]=PRST_SWAN_REST;
\par \tab g_lpdwSwanActState[dwIndex]=ACST_SWAN_JUSTSWIM;
\par \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab g_lpdwSwanKeyframe1[dwIndex]=KEYF_SWAN_HCTR;
\par \tab g_lpdwSwanKeyframe2[dwIndex]=KEYF_SWAN_HCTL;
\par \tab g_lpfSwanTweenVal[dwIndex]=0;
\par \tab g_lpfSwanTailPos[dwIndex]=0;
\par \tab g_lpfSwanTailDir[dwIndex]=SWAN_TAILSPEED;
\par \tab g_lpfSwanTransPos[dwIndex]=0;
\par \tab g_lpfSwanTransSpeed[dwIndex]=0;
\par \tab g_lpdwSwanTransKey1[dwIndex]=NO_OBJECT;
\par \tab g_lpdwSwanTransKey2[dwIndex]=NO_OBJECT;
\par \tab g_lpfSwanNavSpeed[dwIndex]=0;
\par \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab g_lpdwSwanNavMax[dwIndex]=0;
\par \tab g_lpdwSwanMateIdx[dwIndex]=NO_OBJECT;
\par \tab 
\par \tab // add ripple #1
\par \tab g_lpdwSwanRipple1Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #1
\par \tab if(g_lpdwSwanRipple1Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add ripple #2
\par \tab g_lpdwSwanRipple2Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #2
\par \tab if(g_lpdwSwanRipple2Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // SetSwanMatrix()
\par 
\par void SetSwanMatrix(DWORD dwIndex,
\par \tab \tab \tab \tab    LPD3DXMATRIX lpMtx)
\par \{
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwIndex>=g_dwNumSwan)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid swan index.",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "SetSwanMatrix()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \tab return;
\par \tab \}
\par #endif
\par 
\par \tab // set matrix
\par \tab SetMatrix(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab   lpMtx);
\par \}
\par 
\par // PurgeSwans()
\par 
\par void PurgeSwans(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpdwSwanMtx);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanPriState);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanActState);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanNavState);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanKeyframe1);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanKeyframe2);
\par \tab FreeMem((LPVOID*)&g_lpfSwanTweenVal);
\par \tab FreeMem((LPVOID*)&g_lpfSwanTailPos);
\par \tab FreeMem((LPVOID*)&g_lpfSwanTailDir);
\par \tab FreeMem((LPVOID*)&g_lpfSwanTransPos);
\par \tab FreeMem((LPVOID*)&g_lpfSwanTransSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanTransKey1);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanTransKey2);
\par \tab FreeMem((LPVOID*)&g_lpfSwanNavSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanNavPos);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanNavMax);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanMateIdx);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanRipple1Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwSwanRipple2Idx);
\par 
\par \tab // reset counters
\par \tab g_dwNumSwan=0;
\par \tab g_dwMaxSwan=0;
\par \}
\par 
\par // RenderSwans()
\par 
\par void RenderSwans(void)
\par \{
\par \tab // swan index
\par \tab DWORD dwIndex;
\par 
\par \tab // check "phantom" swan flag
\par \tab if(g_bPhantomSwan)
\par \tab \tab return;
\par 
\par #ifndef REFLECTION_OPTIMIZATION
\par \tab // render swans
\par \tab for(dwIndex=0;dwIndex<g_dwNumSwan;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwSwanKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwSwanKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfSwanTweenVal[dwIndex]);
\par 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanMtx[dwIndex]);
\par \tab \}
\par 
\par \tab // enable frontface cull
\par \tab EnableFrontfaceCull();
\par \tab 
\par \tab // render swan reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumSwan;dwIndex++)
\par \tab \{
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwSwanKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwSwanKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfSwanTweenVal[dwIndex]);
\par \tab \tab 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale;
\par \tab \}
\par \tab 
\par \tab // enable backface cull
\par \tab EnableBackfaceCull();
\par #else
\par \tab // render swans & reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumSwan;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwSwanKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwSwanKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfSwanTweenVal[dwIndex]);
\par 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanMtx[dwIndex]);
\par 
\par \tab \tab // enable frontface cull
\par \tab \tab EnableFrontfaceCull();
\par \tab \tab 
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale;
\par \tab \tab 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwSwanMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // enable backface cull
\par \tab \tab EnableBackfaceCull();
\par \tab \}
\par #endif
\par \}
\par 
\par // AddSwanLoner()
\par 
\par DWORD AddSwanLoner(void)
\par \{
\par \tab LoadingOutput("AddSwanLoner");
\par 
\par \tab // swan index
\par \tab DWORD dwIndex;
\par 
\par \tab // polar coordinate values
\par \tab float fAngle;
\par \tab float fDist;
\par \tab 
\par \tab // position values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // done flag
\par \tab BOOL bDone;
\par \tab 
\par \tab // add swan
\par \tab dwIndex=AddSwan();
\par 
\par \tab // check swan
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // reset done flag
\par \tab bDone=FALSE;
\par 
\par \tab // loop until suitable position is found
\par \tab while(!bDone)
\par \tab \{
\par \tab \tab // create random position
\par \tab \tab switch(abs(GetRandomInt())%3)
\par \tab \tab \{
\par \tab \tab // upper round portion of boundary
\par \tab \tab case(0):
\par \tab \tab \tab // set polar coordinates
\par \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab fDist=fabsf(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab 
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX-(cosf(fAngle)*fDist);
\par \tab \tab \tab fZ=(TERRAIN_CENTERZ-TERRAIN_ZRANGE)-(sinf(fAngle)*fDist);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // center rectangular portion of boundary
\par \tab \tab case(1):
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX+(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab fZ=TERRAIN_CENTERZ+(GetRandomFloat()*TERRAIN_ZRANGE);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // lower round portion of boundary
\par \tab \tab case(2):
\par \tab \tab \tab // set polar coordinates
\par \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab fDist=fabsf(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab 
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX+(cosf(fAngle)*fDist);
\par \tab \tab \tab fZ=(TERRAIN_CENTERZ+TERRAIN_ZRANGE)+(sinf(fAngle)*fDist);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // assume that we will be done
\par \tab \tab bDone=TRUE;
\par \tab \tab 
\par \tab \tab // compare position with other swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // skip this swan
\par \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get swan position
\par \tab \tab \tab \tab float fSwanX=g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab float fSwanZ=g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab // compare distance with separation distance
\par \tab \tab \tab \tab if(SquareMagnitudeXZ(fSwanX-fX,fSwanZ-fZ)<Squared(SWAN_SEPARATIONDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // reset done flag
\par \tab \tab \tab \tab \tab bDone=FALSE;
\par 
\par \tab \tab \tab \tab \tab // end loop
\par \tab \tab \tab \tab \tab dwCount=g_dwNumSwan;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // set swan position
\par \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41=fX;
\par \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43=fZ;
\par 
\par \tab // randomize yaw
\par \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab // set primary state
\par \tab g_lpdwSwanPriState[dwIndex]=(DWORD)(abs(GetRandomInt())%SWAN_NUMPRIMARYSTATES);
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddSwanCouple()
\par 
\par DWORD AddSwanCouple(void)
\par \{
\par \tab LoadingOutput("AddSwanCouple");
\par 
\par \tab // swan indices
\par \tab DWORD dwIndex1;
\par \tab DWORD dwIndex2;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // add swan #1
\par \tab dwIndex1=AddSwanLoner();
\par 
\par \tab // check swan #1
\par \tab if(dwIndex1==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add swan #1
\par \tab dwIndex2=AddSwan();
\par 
\par \tab // check swan #2
\par \tab if(dwIndex2==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // set mate values
\par \tab g_lpdwSwanMateIdx[dwIndex1]=dwIndex2;
\par \tab g_lpdwSwanMateIdx[dwIndex2]=dwIndex1;
\par 
\par \tab // set primary state & position of swan #2
\par \tab switch(g_lpdwSwanPriState[dwIndex1])
\par \tab \{
\par \tab // swan #1 leading
\par \tab case(PRST_SWAN_LEAD):
\par \tab \tab // set swan #2 to follow
\par \tab \tab g_lpdwSwanPriState[dwIndex2]=PRST_SWAN_FOLLOW;
\par 
\par \tab \tab // copy swan #1's position to swan #2
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._41=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._42=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._43=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._43;
\par 
\par \tab \tab // randomize yaw of swan #2
\par \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex2],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move swan #2 back by follow distance
\par \tab \tab MatrixAhead(g_lpdwSwanMtx[dwIndex2],
\par \tab \tab \tab \tab \tab SWAN_MAXFOLLOWDISTANCE);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // swan #1 following
\par \tab case(PRST_SWAN_FOLLOW):
\par \tab \tab // set swan #2 to lead
\par \tab \tab g_lpdwSwanPriState[dwIndex2]=PRST_SWAN_LEAD;
\par 
\par \tab \tab // copy swan #1's position to swan #2
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._41=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._42=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._43=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._43;
\par 
\par \tab \tab // randomize yaw of swan #2
\par \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex2],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move swan #1 back by follow distance
\par \tab \tab MatrixAhead(g_lpdwSwanMtx[dwIndex1],
\par \tab \tab \tab \tab \tab SWAN_MAXFOLLOWDISTANCE);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // swan #1 resting
\par \tab case(PRST_SWAN_REST):
\par \tab \tab // set swan #2 to rest
\par \tab \tab g_lpdwSwanPriState[dwIndex2]=PRST_SWAN_REST;
\par 
\par \tab \tab // copy swan #1's position to swan #2
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._41=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._42=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex2]].mtx._43=g_lpMtx[g_lpdwSwanMtx[dwIndex1]].mtx._43;
\par 
\par \tab \tab // randomize yaw of swan #2
\par \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex2],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move swan #2 back by follow distance
\par \tab \tab MatrixAhead(g_lpdwSwanMtx[dwIndex2],
\par \tab \tab \tab \tab \tab SWAN_MAXFOLLOWDISTANCE);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // return index #1
\par \tab return(dwIndex1);
\par \}
\par 
\par // RandomizeSwanPrimaryState()
\par 
\par void RandomizeSwanPrimaryState(DWORD dwIndex)
\par \{
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwIndex>=g_dwNumSwan)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid swan index.",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "RandomizeSwanPrimaryState()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \tab return;
\par \tab \}
\par #endif
\par 
\par \tab // set new state
\par \tab g_lpdwSwanPriState[dwIndex]=(DWORD)(abs(GetRandomInt())%SWAN_NUMPRIMARYSTATES);
\par 
\par \tab // check for mate
\par \tab if(g_lpdwSwanMateIdx[dwIndex]!=NO_OBJECT)
\par \tab \{
\par \tab \tab // set mate's state accordingly
\par \tab \tab switch(g_lpdwSwanPriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // this swan leading
\par \tab \tab case(PRST_SWAN_LEAD):
\par \tab \tab \tab // set mate to follow
\par \tab \tab \tab g_lpdwSwanPriState[g_lpdwSwanMateIdx[dwIndex]]=PRST_SWAN_FOLLOW;
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // this swan following
\par \tab \tab case(PRST_SWAN_FOLLOW):
\par \tab \tab \tab // set mate to lead
\par \tab \tab \tab g_lpdwSwanPriState[g_lpdwSwanMateIdx[dwIndex]]=PRST_SWAN_LEAD;
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // this swan resting
\par \tab \tab case(PRST_SWAN_REST):
\par \tab \tab \tab // set mate to rest
\par \tab \tab \tab g_lpdwSwanPriState[g_lpdwSwanMateIdx[dwIndex]]=PRST_SWAN_REST;
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \}
\par \}
\par 
\par // IsPointOutOfUpperBounds()
\par 
\par BOOL IsPointOutOfUpperBounds(float fX,
\par \tab \tab \tab \tab \tab \tab \tab  float fZ)
\par \{
\par \tab // distance value
\par \tab float fDist;
\par \tab 
\par \tab // check z value
\par \tab if(fZ<=(TERRAIN_CENTERZ-TERRAIN_ZRANGE))
\par \tab \{
\par \tab \tab // compute distance to center of boundary
\par \tab \tab fDist=SquareMagnitudeXZ(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab     fZ-(TERRAIN_CENTERZ-TERRAIN_ZRANGE));
\par 
\par \tab \tab // check distance
\par \tab \tab if(fDist>Squared(TERRAIN_XRANGE))
\par \tab \tab \tab return(TRUE);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(FALSE);
\par \}
\par 
\par // IsPointOutOfCenterBounds()
\par 
\par BOOL IsPointOutOfCenterBounds(float fX,
\par \tab \tab \tab \tab \tab \tab \tab   float fZ)
\par \{
\par \tab // check z value
\par \tab if(fZ>=(TERRAIN_CENTERZ-TERRAIN_ZRANGE)&&
\par \tab    fZ<=(TERRAIN_CENTERZ+TERRAIN_ZRANGE))
\par \tab \{
\par \tab \tab // check x value
\par \tab \tab if(fX<=(TERRAIN_CENTERX-TERRAIN_XRANGE)||
\par \tab \tab    fX>=(TERRAIN_CENTERX+TERRAIN_XRANGE))
\par \tab \tab \tab return(TRUE);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(FALSE);
\par \}
\par 
\par // IsPointOutOfLowerBounds()
\par 
\par BOOL IsPointOutOfLowerBounds(float fX,
\par  \tab \tab \tab \tab \tab \tab \tab  float fZ)
\par \{
\par \tab // distance value
\par \tab float fDist;
\par \tab 
\par \tab // check z value
\par \tab if(fZ>=(TERRAIN_CENTERZ+TERRAIN_ZRANGE))
\par \tab \{
\par \tab \tab // compute distance to center of boundary
\par \tab \tab fDist=SquareMagnitudeXZ(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab     fZ-(TERRAIN_CENTERZ+TERRAIN_ZRANGE));
\par 
\par \tab \tab // check distance
\par \tab \tab if(fDist>Squared(TERRAIN_XRANGE))
\par \tab \tab \tab return(TRUE);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(FALSE);
\par \}
\par 
\par // IsPointOutOfBounds()
\par 
\par BOOL IsPointOutOfBounds(float fX,
\par  \tab \tab \tab \tab \tab \tab float fZ)
\par \{
\par \tab // check each boundary
\par \tab if(IsPointOutOfUpperBounds(fX,fZ))
\par \tab \tab return(TRUE);
\par \tab if(IsPointOutOfLowerBounds(fX,fZ))
\par \tab \tab return(TRUE);
\par \tab if(IsPointOutOfCenterBounds(fX,fZ))
\par \tab \tab return(TRUE);
\par \tab 
\par \tab // ok
\par \tab return(FALSE);
\par \}
\par 
\par // UpdateSwans()
\par 
\par void UpdateSwans(void)
\par \{
\par \tab // alternating counter
\par \tab static DWORD dwAltCount=0;
\par 
\par \tab // swan index
\par \tab DWORD dwIndex;
\par 
\par \tab // mate index
\par \tab DWORD dwMateIndex;
\par 
\par \tab // navigation update flag
\par \tab BOOL bNavFlag;
\par 
\par \tab // vectors for comparisons
\par \tab D3DXVECTOR3 vV1;
\par \tab D3DXVECTOR3 vV2;
\par \tab D3DXVECTOR3 vV3;
\par 
\par \tab // distance value
\par \tab float fDist;
\par 
\par \tab // tracking value
\par \tab float fTrackingVal;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // boundary flags
\par \tab BOOL bUpper;
\par \tab BOOL bLower;
\par \tab BOOL bCenter;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // update alternating counter
\par \tab dwAltCount=(dwAltCount+1)&1;
\par 
\par \tab // update swans
\par \tab for(dwIndex=0;dwIndex<g_dwNumSwan;dwIndex++)
\par \tab \{
\par \tab \tab // get mate index
\par \tab \tab dwMateIndex=g_lpdwSwanMateIdx[dwIndex];
\par 
\par \tab \tab // set coordinate values
\par \tab \tab fX=g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41;
\par \tab \tab fZ=g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43;
\par 
\par \tab \tab // compare swan position with other swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // skip this swan
\par \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // skip this swan's mate
\par \tab \tab \tab \tab if(dwCount!=dwMateIndex)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab // save distance
\par \tab \tab \tab \tab \tab fDist=SquareMagnitudeXZ(&vV1);
\par 
\par \tab \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab \tab if(fDist<Squared(SWAN_SEPARATIONDISTANCE))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // compute distance
\par \tab \tab \tab \tab \tab \tab float fInvDist=1.0F/sqrtf(fDist);
\par \tab \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab \tab vV2.x=vV1.x*fInvDist;
\par \tab \tab \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab \tab \tab vV2.z=vV1.z*fInvDist;
\par 
\par \tab \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41+=vV2.x*g_lpfSwanNavSpeed[dwCount];
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43+=vV2.z*g_lpfSwanNavSpeed[dwCount];
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check primary state
\par \tab \tab switch(g_lpdwSwanPriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // lead
\par \tab \tab case(PRST_SWAN_LEAD):
\par \tab \tab \tab // get boundary flags
\par \tab \tab \tab bUpper=IsPointOutOfUpperBounds(fX,fZ);
\par \tab \tab \tab bLower=IsPointOutOfLowerBounds(fX,fZ);
\par \tab \tab \tab bCenter=IsPointOutOfCenterBounds(fX,fZ);
\par 
\par \tab \tab \tab // check boundaries
\par \tab \tab \tab if(bUpper||bLower||bCenter)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get vector from center of boundary to swan
\par \tab \tab \tab \tab if(bUpper)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // center of upper boundary
\par \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab fZ-(TERRAIN_CENTERZ-TERRAIN_ZRANGE));
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(bLower)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // center of lower boundary
\par \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab fZ-(TERRAIN_CENTERZ+TERRAIN_ZRANGE));
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // center of center boundary
\par \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab fZ-TERRAIN_CENTERZ);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab Normalize(&vV1,&vV2);
\par 
\par \tab \tab \tab \tab // get perpendicular vector
\par \tab \tab \tab \tab vV2.x=vV1.z;
\par \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab vV2.z=-vV1.x;
\par 
\par \tab \tab \tab \tab // get swan ahead vector
\par \tab \tab \tab \tab vV3=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._33);
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV2,&vV3)>0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_HARDRIGHT;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_HARDLEFT;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV1,&vV3)<0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]<(SWAN_MAXSPEED*0.25F))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]<(SWAN_MAXSPEED*0.25F))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwSwanNavState[dwIndex]==NVST_SWAN_JUSTSWIM)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%SWAN_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%SWAN_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%SWAN_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // check for mate
\par \tab \tab \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get swan position
\par \tab \tab \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab \tab \tab // get mate position
\par \tab \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwMateIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwMateIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab \tab \tab // get distance to mate
\par \tab \tab \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab \tab \tab if(fDist>Squared(SWAN_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]>(SWAN_MAXSPEED*0.5F))
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // change primary state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%SWAN_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab RandomizeSwanPrimaryState(dwIndex);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // follow
\par \tab \tab case(PRST_SWAN_FOLLOW):
\par \tab \tab \tab // single swans must be leaders
\par \tab \tab \tab if(dwMateIndex==NO_OBJECT)
\par \tab \tab \tab \tab g_lpdwSwanPriState[dwIndex]=PRST_SWAN_LEAD;
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get swan position
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get mate position
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwMateIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwMateIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get distance to mate
\par \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab if(fDist<Squared(SWAN_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab \tab if(fDist<Squared(SWAN_MINSWANDISTANCE))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get vector from mate to swan
\par \tab \tab \tab \tab \tab \tab vV3=vV1-vV2;
\par 
\par \tab \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab \tab Normalize(&vV1,&vV3);
\par 
\par \tab \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41+=vV1.x*g_lpfSwanNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43+=vV1.z*g_lpfSwanNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]>(g_lpfSwanNavSpeed[dwMateIndex]*SWAN_TRACKINGSPEEDVAL)+SWAN_TRACKINGSPEEDINC)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else if(g_lpfSwanNavSpeed[dwIndex]<(g_lpfSwanNavSpeed[dwMateIndex]*SWAN_TRACKINGSPEEDVAL1)-SWAN_TRACKINGSPEEDINC1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpdwSwanNavState[dwIndex]==NVST_SWAN_JUSTSWIM)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%SWAN_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%SWAN_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%SWAN_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par   \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector from swan to mate
\par \tab \tab \tab \tab \tab vV3=vV2-vV1;
\par 
\par \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab Normalize(&vV2,&vV3);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // get swan ahead vector
\par \tab \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._33);
\par 
\par \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab if(DotProduct(&vV1,&vV2)>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par  
\par \tab \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab \tab if(DotProduct(&vV3,&vV2)>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab \tab // save tracking value
\par \tab \tab \tab \tab \tab \tab fTrackingVal=DotProduct(&vV3,&vV2);
\par 
\par \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab if(fabsf(fTrackingVal)>SWAN_FOLLOWTRACKINGVAL)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab \tab if(fTrackingVal>0)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]<((g_lpfSwanNavSpeed[dwMateIndex]*SWAN_TRACKINGSPEEDVAL)+SWAN_TRACKINGSPEEDINC)-SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else if(g_lpfSwanNavSpeed[dwIndex]>((g_lpfSwanNavSpeed[dwMateIndex]*SWAN_TRACKINGSPEEDVAL)+SWAN_TRACKINGSPEEDINC)+SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab \tab \tab \tab if(fDist>Squared(SWAN_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]<((g_lpfSwanNavSpeed[dwMateIndex]*SWAN_TRACKINGSPEEDVAL2)+SWAN_TRACKINGSPEEDINC2)-SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \tab else if(g_lpfSwanNavSpeed[dwIndex]>((g_lpfSwanNavSpeed[dwMateIndex]*SWAN_TRACKINGSPEEDVAL2)+SWAN_TRACKINGSPEEDINC2)+SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // rest
\par \tab \tab case(PRST_SWAN_REST):
\par \tab \tab \tab // check for mate
\par \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get swan position
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get mate position
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_lpdwSwanMtx[dwMateIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwMateIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get distance to mate
\par \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab if(fDist<Squared(SWAN_MINSWANDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector from mate to swan
\par \tab \tab \tab \tab \tab vV3=vV1-vV2;
\par 
\par \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab Normalize(&vV1,&vV3);
\par 
\par \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41+=vV1.x*g_lpfSwanNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43+=vV1.z*g_lpfSwanNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(fDist>Squared(SWAN_MAXRESTDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set swan to lead
\par \tab \tab \tab \tab \tab g_lpdwSwanPriState[dwIndex]=PRST_SWAN_LEAD;
\par 
\par \tab \tab \tab \tab \tab // set mate to follow if necessary
\par \tab \tab \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab g_lpdwSwanPriState[dwMateIndex]=PRST_SWAN_FOLLOW;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check boundaries
\par \tab \tab \tab if(IsPointOutOfBounds(fX,fZ))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set swan to lead
\par \tab \tab \tab \tab g_lpdwSwanPriState[dwIndex]=PRST_SWAN_LEAD;
\par 
\par \tab \tab \tab \tab // set mate to follow if necessary
\par \tab \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \tab \tab g_lpdwSwanPriState[dwMateIndex]=PRST_SWAN_FOLLOW;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]>SWAN_MAXRESTSPEED)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwSwanNavState[dwIndex]==NVST_SWAN_JUSTSWIM)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%SWAN_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%SWAN_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwSwanNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%SWAN_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // change primary state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%SWAN_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab RandomizeSwanPrimaryState(dwIndex);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab if(g_lpdwSwanNavState[dwIndex]!=NVST_SWAN_JUSTSWIM)
\par \tab \tab \{
\par \tab \tab \tab // check navigation position
\par \tab \tab \tab if(g_lpdwSwanNavPos[dwIndex]<g_lpdwSwanNavMax[dwIndex])
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bNavFlag=TRUE;
\par 
\par \tab \tab \tab \tab // increment navigation position
\par \tab \tab \tab \tab g_lpdwSwanNavPos[dwIndex]++;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset flag
\par \tab \tab \tab \tab bNavFlag=FALSE;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab switch(g_lpdwSwanNavState[dwIndex])
\par \tab \tab \{
\par \tab \tab // speed up
\par \tab \tab case(NVST_SWAN_SPEEDUP):
\par \tab \tab \tab // increase speed
\par \tab \tab \tab g_lpfSwanNavSpeed[dwIndex]+=SWAN_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]>SWAN_MAXSPEED)
\par \tab \tab \tab \tab g_lpfSwanNavSpeed[dwIndex]=SWAN_MAXSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // slow down
\par \tab \tab case(NVST_SWAN_SLOWDOWN):
\par \tab \tab \tab // decrease speed
\par \tab \tab \tab g_lpfSwanNavSpeed[dwIndex]-=SWAN_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfSwanNavSpeed[dwIndex]<0)
\par \tab \tab \tab \tab g_lpfSwanNavSpeed[dwIndex]=0;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn left
\par \tab \tab case(NVST_SWAN_TURNLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab \tab   SWAN_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn right
\par \tab \tab case(NVST_SWAN_TURNRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -SWAN_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard left
\par \tab \tab case(NVST_SWAN_HARDLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab \tab   SWAN_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard right
\par \tab \tab case(NVST_SWAN_HARDRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -SWAN_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwSwanNavState[dwIndex]=NVST_SWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // move swan
\par \tab \tab MatrixBack(g_lpdwSwanMtx[dwIndex],
\par \tab \tab \tab \tab    g_lpfSwanNavSpeed[dwIndex]);
\par 
\par \tab \tab // update tail
\par \tab \tab g_lpfSwanTailPos[dwIndex]+=g_lpfSwanTailDir[dwIndex]+g_lpfSwanNavSpeed[dwIndex];
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_lpfSwanTailPos[dwIndex]>=1.0F)
\par \tab \tab \{
\par \tab \tab \tab // clip position
\par \tab \tab \tab g_lpfSwanTailPos[dwIndex]=1.0F;
\par 
\par \tab \tab \tab // reverse direction
\par \tab \tab \tab g_lpfSwanTailDir[dwIndex]=-g_lpfSwanTailDir[dwIndex];
\par \tab \tab \}
\par \tab \tab else if(g_lpfSwanTailPos[dwIndex]<=-1.0F)
\par \tab \tab \{
\par \tab \tab \tab // clip position
\par \tab \tab \tab g_lpfSwanTailPos[dwIndex]=-1.0F;
\par 
\par \tab \tab \tab // reverse direction
\par \tab \tab \tab g_lpfSwanTailDir[dwIndex]=-g_lpfSwanTailDir[dwIndex];
\par \tab \tab \}
\par 
\par \tab \tab // check action state
\par \tab \tab switch(g_lpdwSwanActState[dwIndex])
\par \tab \tab \{
\par \tab \tab // just swim
\par \tab \tab case(ACST_SWAN_JUSTSWIM):
\par \tab \tab \tab // set tween value
\par \tab \tab \tab g_lpfSwanTweenVal[dwIndex]=GetNaturalizedTweenValue((g_lpfSwanTailPos[dwIndex]+1.0F)*0.5F);
\par 
\par \tab \tab \tab // change states if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%SWAN_ACTIONCHANGERATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab switch(abs(GetRandomInt())%SWAN_NUMACTIONSTATES)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab // head up
\par \tab \tab \tab \tab case(ACST_SWAN_HEADUP):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HUTR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HUTL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down
\par \tab \tab \tab \tab case(ACST_SWAN_HEADDOWN):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HDTR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HDTL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head left
\par \tab \tab \tab \tab case(ACST_SWAN_HEADLEFT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HL1TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HL1TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head right
\par \tab \tab \tab \tab case(ACST_SWAN_HEADRIGHT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HR1TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HR1TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head left #2
\par \tab \tab \tab \tab case(ACST_SWAN_HEADLEFT2):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HL2TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HL2TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head right #2
\par \tab \tab \tab \tab case(ACST_SWAN_HEADRIGHT2):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HR2TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HR2TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down-left
\par \tab \tab \tab \tab case(ACST_SWAN_HEADDOWNLEFT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HDL1TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HDL1TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down-right
\par \tab \tab \tab \tab case(ACST_SWAN_HEADDOWNRIGHT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HDR1TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HDR1TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down-left #2
\par \tab \tab \tab \tab case(ACST_SWAN_HEADDOWNLEFT2):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HDL2TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HDL2TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down-right #2
\par \tab \tab \tab \tab case(ACST_SWAN_HEADDOWNRIGHT2):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HDR2TR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HDR2TL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // look ahead
\par \tab \tab \tab \tab default:
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey1[dwIndex]=KEYF_SWAN_HCTR;
\par \tab \tab \tab \tab \tab g_lpdwSwanTransKey2[dwIndex]=KEYF_SWAN_HCTL;
\par \tab \tab \tab \tab \tab g_lpfSwanTransSpeed[dwIndex]=SWAN_TRANSITIONSPEED+(GetRandomFloat()*SWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set state to transition
\par \tab \tab \tab \tab g_lpdwSwanActState[dwIndex]=ACST_SWAN_TRANSITION;
\par 
\par \tab \tab \tab \tab // set transition position flag
\par \tab \tab \tab \tab g_lpfSwanTransPos[dwIndex]=-1.0F;
\par \tab \tab \tab \}
\par \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab 
\par \tab \tab // perform transition
\par \tab \tab case(ACST_SWAN_TRANSITION):
\par \tab \tab \tab // check position flag
\par \tab \tab \tab if(g_lpfSwanTransPos[dwIndex]<0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab g_lpfSwanTweenVal[dwIndex]=GetNaturalizedTweenValue((g_lpfSwanTailPos[dwIndex]+1.0F)*0.5F);
\par 
\par \tab \tab \tab \tab // continue until keyframe is reached
\par \tab \tab \tab \tab if(IsNearEqual(g_lpfSwanTweenVal[dwIndex],1))
\par \tab \tab \tab \tab \tab g_lpfSwanTransPos[dwIndex]=2;
\par \tab \tab \tab \}
\par \tab \tab \tab else if(g_lpfSwanTransPos[dwIndex]>1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab g_lpfSwanTweenVal[dwIndex]=0;
\par 
\par \tab \tab \tab \tab // set new keyframes
\par \tab \tab \tab \tab g_lpdwSwanKeyframe1[dwIndex]=g_lpdwSwanKeyframe2[dwIndex];
\par \tab \tab \tab \tab g_lpdwSwanKeyframe2[dwIndex]=g_lpdwSwanTransKey1[dwIndex];
\par 
\par \tab \tab \tab \tab // set position value
\par \tab \tab \tab \tab g_lpfSwanTransPos[dwIndex]=0;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // increment transition position
\par \tab \tab \tab \tab g_lpfSwanTransPos[dwIndex]+=g_lpfSwanTransSpeed[dwIndex];
\par 
\par \tab \tab \tab \tab // check for overflow
\par \tab \tab \tab \tab if(g_lpfSwanTransPos[dwIndex]>1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab \tab g_lpfSwanTweenVal[dwIndex]=0;
\par 
\par \tab \tab \tab \tab \tab // reset tail position & direction
\par \tab \tab \tab \tab \tab g_lpfSwanTailPos[dwIndex]=-1;
\par \tab \tab \tab \tab \tab g_lpfSwanTailDir[dwIndex]=fabsf(g_lpfSwanTailDir[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab // set final keyframes
\par \tab \tab \tab \tab \tab g_lpdwSwanKeyframe1[dwIndex]=g_lpdwSwanTransKey1[dwIndex];
\par \tab \tab \tab \tab \tab g_lpdwSwanKeyframe2[dwIndex]=g_lpdwSwanTransKey2[dwIndex];
\par 
\par \tab \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab \tab g_lpdwSwanActState[dwIndex]=ACST_SWAN_JUSTSWIM;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab \tab g_lpfSwanTweenVal[dwIndex]=GetNaturalizedTweenValue(g_lpfSwanTransPos[dwIndex]);
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // start ripples if necessary
\par \tab \tab if(IsRippleComplete(g_lpdwSwanRipple1Idx[dwIndex]))
\par \tab \tab \tab StartRipple(g_lpdwSwanRipple1Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43,
\par \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \tab if(IsRippleComplete(g_lpdwSwanRipple2Idx[dwIndex]))
\par \tab \tab \tab StartRipple(g_lpdwSwanRipple2Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43,
\par \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \}
\par \}
\par 
\par // AddSwanSPFamily()
\par 
\par DWORD AddSwanSPFamily(DWORD dwNumBBSwans)
\par \{
\par \tab LoadingOutput("AddSwanSPFamily");
\par 
\par \tab // parent index
\par \tab DWORD dwIndex;
\par \tab 
\par \tab // counters
\par \tab DWORD dwCount1;
\par \tab DWORD dwCount2;
\par 
\par \tab // baby index
\par \tab DWORD dwBBIndex;
\par 
\par \tab // matrix
\par \tab D3DXMATRIX mtx;
\par \tab 
\par \tab // add parent & save index
\par \tab dwIndex=AddSwanLoner();
\par 
\par \tab // check swan
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add baby swans
\par \tab for(dwCount1=0;dwCount1<dwNumBBSwans;dwCount1++)
\par \tab \{
\par \tab \tab // add baby swan
\par \tab \tab dwBBIndex=AddBBSwan();
\par 
\par \tab \tab // check baby swan
\par \tab \tab if(dwBBIndex==NO_OBJECT)
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // copy parent's position to baby swan
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwBBIndex]].mtx._41=g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwBBIndex]].mtx._42=g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwBBIndex]].mtx._43=g_lpMtx[g_lpdwSwanMtx[dwIndex]].mtx._43;
\par 
\par \tab \tab // randomize yaw of baby swan
\par \tab \tab for(dwCount2=0;dwCount2<8;dwCount2++)
\par \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwBBIndex],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move baby swan back to ensure no others occupy this same position
\par \tab \tab MatrixAhead(g_lpdwBBSwanMtx[dwBBIndex],
\par \tab \tab \tab \tab \tab (BBSWAN_PANICDISTANCE*0.5F)+((float)(dwCount1)));
\par 
\par \tab \tab // set parent indices
\par \tab \tab g_lpdwBBSwanParent1Idx[dwBBIndex]=dwIndex;
\par \tab \tab g_lpdwBBSwanParent2Idx[dwBBIndex]=NO_OBJECT;
\par \tab \}
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddSwanDPFamily()
\par 
\par DWORD AddSwanDPFamily(DWORD dwNumBBSwans)
\par \{
\par \tab LoadingOutput("AddSwanDPFamily");
\par 
\par \tab // parent indices
\par \tab DWORD dwIndex1;
\par \tab DWORD dwIndex2;
\par \tab 
\par \tab // counters
\par \tab DWORD dwCount1;
\par \tab DWORD dwCount2;
\par 
\par \tab // baby index
\par \tab DWORD dwBBIndex;
\par 
\par \tab // matrices
\par \tab D3DXMATRIX mtx1;
\par \tab D3DXMATRIX mtx2;
\par \tab 
\par \tab // add parents & save index
\par \tab dwIndex1=AddSwanCouple();
\par 
\par \tab // check index
\par \tab if(dwIndex1==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // save mate's index
\par \tab dwIndex2=g_lpdwSwanMateIdx[dwIndex1];
\par 
\par \tab // get parent #1's matrix
\par \tab GetMatrix(g_lpdwSwanMtx[dwIndex1],
\par \tab \tab \tab   &mtx1);
\par 
\par \tab // get parent #2's matrix
\par \tab GetMatrix(g_lpdwSwanMtx[dwIndex2],
\par \tab \tab \tab   &mtx2);
\par 
\par \tab // compute average position
\par \tab mtx1._41=(mtx1._41+mtx2._41)*0.5F;
\par \tab mtx1._42=(mtx1._42+mtx2._42)*0.5F;
\par \tab mtx1._43=(mtx1._43+mtx2._43)*0.5F;
\par 
\par \tab // add baby swans
\par \tab for(dwCount1=0;dwCount1<dwNumBBSwans;dwCount1++)
\par \tab \{
\par \tab \tab // add baby swan
\par \tab \tab dwBBIndex=AddBBSwan();
\par 
\par \tab \tab // check baby swan
\par \tab \tab if(dwBBIndex==NO_OBJECT)
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // copy parent's position to baby swan
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwBBIndex]].mtx._41=mtx1._41;
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwBBIndex]].mtx._42=mtx1._42;
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwBBIndex]].mtx._43=mtx1._43;
\par 
\par \tab \tab // randomize yaw of baby swan
\par \tab \tab for(dwCount2=0;dwCount2<8;dwCount2++)
\par \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwBBIndex],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move baby swan back to ensure no others occupy this same position
\par \tab \tab MatrixAhead(g_lpdwBBSwanMtx[dwBBIndex],
\par \tab \tab \tab \tab \tab (BBSWAN_PANICDISTANCE*0.5F)+((float)(dwCount1)));
\par 
\par \tab \tab // set parent indices
\par \tab \tab g_lpdwBBSwanParent1Idx[dwBBIndex]=dwIndex1;
\par \tab \tab g_lpdwBBSwanParent2Idx[dwBBIndex]=dwIndex2;
\par \tab \}
\par 
\par \tab // return index
\par \tab return(dwIndex1);
\par \}
\par 
\par // GetNextBBSwan()
\par 
\par DWORD GetNextBBSwan(void)
\par \{
\par \tab LoadingOutput("GetNextBBSwan");
\par 
\par \tab // check counter
\par \tab if(g_dwNumBBSwan==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanMtx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanPriState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanActState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanNavState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanKeyframe1,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanKeyframe2,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBBSwanTweenVal,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBBSwanTailPos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBBSwanTailDir,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBBSwanTransPos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBBSwanTransSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanTransKey1,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanTransKey2,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBBSwanNavSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanNavPos,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanNavMax,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanParent1Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanParent2Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanRipple1Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBBSwanRipple2Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxBBSwan=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumBBSwan>=g_dwMaxBBSwan)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanMtx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanPriState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanActState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanNavState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanKeyframe1,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanKeyframe2,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBBSwanTweenVal,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBBSwanTailPos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBBSwanTailDir,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBBSwanTransPos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBBSwanTransSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanTransKey1,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanTransKey2,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBBSwanNavSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanNavPos,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanNavMax,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanParent1Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanParent2Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanRipple1Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBBSwanRipple2Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBBSwan,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxBBSwan+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumBBSwan;
\par 
\par \tab // increment counter
\par \tab g_dwNumBBSwan++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddBBSwan()
\par 
\par DWORD AddBBSwan(void)
\par \{
\par \tab LoadingOutput("AddBBSwan");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextBBSwan();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add baby swan matrix
\par \tab g_lpdwBBSwanMtx[dwIndex]=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_lpdwBBSwanMtx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // scale matrix by baby swan scale
\par \tab MatrixScale(g_lpdwBBSwanMtx[dwIndex],
\par \tab \tab \tab \tab BBSWAN_SCALE+(GetRandomFloat()*BBSWAN_SCALEVAR));
\par 
\par \tab // set default values
\par \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_REST;
\par \tab g_lpdwBBSwanActState[dwIndex]=ACST_BBSWAN_JUSTSWIM;
\par \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab g_lpdwBBSwanKeyframe1[dwIndex]=KEYF_BBSWAN_HCTR;
\par \tab g_lpdwBBSwanKeyframe2[dwIndex]=KEYF_BBSWAN_HCTL;
\par \tab g_lpfBBSwanTweenVal[dwIndex]=0;
\par \tab g_lpfBBSwanTailPos[dwIndex]=0;
\par \tab g_lpfBBSwanTailDir[dwIndex]=BBSWAN_TAILSPEED;
\par \tab g_lpfBBSwanTransPos[dwIndex]=0;
\par \tab g_lpfBBSwanTransSpeed[dwIndex]=0;
\par \tab g_lpdwBBSwanTransKey1[dwIndex]=NO_OBJECT;
\par \tab g_lpdwBBSwanTransKey2[dwIndex]=NO_OBJECT;
\par \tab g_lpfBBSwanNavSpeed[dwIndex]=0;
\par \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab g_lpdwBBSwanNavMax[dwIndex]=0;
\par \tab g_lpdwBBSwanParent1Idx[dwIndex]=NO_OBJECT;
\par \tab g_lpdwBBSwanParent2Idx[dwIndex]=NO_OBJECT;
\par 
\par \tab // add ripple #1
\par \tab g_lpdwBBSwanRipple1Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #1
\par \tab if(g_lpdwBBSwanRipple1Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add ripple #2
\par \tab g_lpdwBBSwanRipple2Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #2
\par \tab if(g_lpdwBBSwanRipple2Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // PurgeBBSwans()
\par 
\par void PurgeBBSwans(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanMtx);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanPriState);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanActState);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanNavState);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanKeyframe1);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanKeyframe2);
\par \tab FreeMem((LPVOID*)&g_lpfBBSwanTweenVal);
\par \tab FreeMem((LPVOID*)&g_lpfBBSwanTailPos);
\par \tab FreeMem((LPVOID*)&g_lpfBBSwanTailDir);
\par \tab FreeMem((LPVOID*)&g_lpfBBSwanTransPos);
\par \tab FreeMem((LPVOID*)&g_lpfBBSwanTransSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanTransKey1);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanTransKey2);
\par \tab FreeMem((LPVOID*)&g_lpfBBSwanNavSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanNavPos);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanNavMax);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanParent1Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanParent2Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanRipple1Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwBBSwanRipple2Idx);
\par 
\par \tab // reset counters
\par \tab g_dwNumBBSwan=0;
\par \tab g_dwMaxBBSwan=0;
\par \}
\par 
\par // RenderBBSwans()
\par 
\par void RenderBBSwans(void)
\par \{
\par \tab // baby swan index
\par \tab DWORD dwIndex;
\par 
\par #ifndef REFLECTION_OPTIMIZATION
\par \tab // render baby swans
\par \tab for(dwIndex=0;dwIndex<g_dwNumBBSwan;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwBBSwanKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwBBSwanKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfBBSwanTweenVal[dwIndex]);
\par 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanMtx[dwIndex]);
\par \tab \}
\par 
\par \tab // enable frontface cull
\par \tab EnableFrontfaceCull();
\par \tab 
\par \tab // render baby swan reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumBBSwan;dwIndex++)
\par \tab \{
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwBBSwanKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwBBSwanKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfBBSwanTweenVal[dwIndex]);
\par \tab \tab 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale;
\par \tab \}
\par \tab 
\par \tab // enable backface cull
\par \tab EnableBackfaceCull();
\par #else
\par \tab // render baby swans & reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumBBSwan;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwBBSwanKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwBBSwanKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfBBSwanTweenVal[dwIndex]);
\par 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanMtx[dwIndex]);
\par \tab \tab // enable frontface cull
\par \tab \tab EnableFrontfaceCull();
\par \tab 
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // render swan
\par \tab \tab RenderAnimation(g_dwBBSwanAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].fYScale;
\par \tab \tab 
\par \tab \tab // enable backface cull
\par \tab \tab EnableBackfaceCull();
\par \tab \}
\par #endif
\par \}
\par 
\par // UpdateBBSwans()
\par 
\par void UpdateBBSwans(void)
\par \{
\par \tab // alternating counter
\par \tab static DWORD dwAltCount=0;
\par 
\par \tab // baby swan index
\par \tab DWORD dwIndex;
\par 
\par \tab // parent indices
\par \tab DWORD dwParent1Index;
\par \tab DWORD dwParent2Index;
\par 
\par \tab // average parent position coordinates
\par \tab float fParentX;
\par \tab float fParentZ;
\par 
\par \tab // navigation update flag
\par \tab BOOL bNavFlag;
\par 
\par \tab // vectors for comparisons
\par \tab D3DXVECTOR3 vV1;
\par \tab D3DXVECTOR3 vV2;
\par \tab D3DXVECTOR3 vV3;
\par 
\par \tab // distance value
\par \tab float fDist;
\par 
\par \tab // tracking value
\par \tab float fTrackingVal;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // update alternating counter
\par \tab dwAltCount=(dwAltCount+1)&1;
\par 
\par \tab // update baby swans
\par \tab for(dwIndex=0;dwIndex<g_dwNumBBSwan;dwIndex++)
\par \tab \{
\par \tab \tab // get parent indices
\par \tab \tab dwParent1Index=g_lpdwBBSwanParent1Idx[dwIndex];
\par \tab \tab dwParent2Index=g_lpdwBBSwanParent2Idx[dwIndex];
\par 
\par \tab \tab // check for parent #2
\par \tab \tab if(dwParent2Index!=NO_OBJECT)
\par \tab \tab \{
\par \tab \tab \tab // compute average parent position
\par \tab \tab \tab fParentX=(g_lpMtx[g_lpdwSwanMtx[dwParent1Index]].mtx._41+g_lpMtx[g_lpdwSwanMtx[dwParent2Index]].mtx._41)*0.5F;
\par \tab \tab \tab fParentZ=(g_lpMtx[g_lpdwSwanMtx[dwParent1Index]].mtx._43+g_lpMtx[g_lpdwSwanMtx[dwParent2Index]].mtx._43)*0.5F;
\par 
\par \tab \tab \tab // set baby swan to rest if necessary (unless panicking)
\par \tab \tab \tab if(g_lpdwBBSwanPriState[dwIndex]!=PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab if(g_lpdwSwanPriState[dwParent1Index]==PRST_SWAN_REST||
\par \tab \tab \tab \tab    g_lpdwSwanPriState[dwParent2Index]==PRST_SWAN_REST)
\par \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_REST;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // set parent #1 position
\par \tab \tab \tab fParentX=g_lpMtx[g_lpdwSwanMtx[dwParent1Index]].mtx._41;
\par \tab \tab \tab fParentZ=g_lpMtx[g_lpdwSwanMtx[dwParent1Index]].mtx._43;
\par 
\par \tab \tab \tab // set baby swan to rest if necessary (unless panicking)
\par \tab \tab \tab if(g_lpdwBBSwanPriState[dwIndex]!=PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab if(g_lpdwSwanPriState[dwParent1Index]==PRST_SWAN_REST)
\par \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_REST;
\par \tab \tab \}
\par 
\par \tab \tab // set coordinate values
\par \tab \tab fX=g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41;
\par \tab \tab fZ=g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43;
\par 
\par \tab \tab // compare baby swan position with adult swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // set up vector
\par \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab // save distance
\par \tab \tab \tab fDist=SquareMagnitudeXZ(&vV1);
\par 
\par \tab \tab \tab // check distance
\par \tab \tab \tab if(fDist<Squared(BBSWAN_MINSWANDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // compute inverse distance
\par \tab \tab \tab \tab float fInvDist=1.0F/sqrtf(fDist);
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab vV2.x=vV1.x*fInvDist;
\par \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab vV2.z=vV1.z*fInvDist;
\par 
\par \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41+=vV2.x*g_lpfSwanNavSpeed[dwCount];
\par \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43+=vV2.z*g_lpfSwanNavSpeed[dwCount];
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // compare baby swan position with other baby swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumBBSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // skip this swan
\par \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab // save distance
\par \tab \tab \tab \tab fDist=SquareMagnitudeXZ(&vV1);
\par 
\par \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab if(fDist<Squared(BBSWAN_MINBBSWANDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // compute distance
\par \tab \tab \tab \tab \tab float fInvDist=1.0F/sqrtf(fDist);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab vV2.x=vV1.x*fInvDist;
\par \tab \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab \tab vV2.z=vV1.z*fInvDist;
\par 
\par \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41+=vV2.x*g_lpfBBSwanNavSpeed[dwCount];
\par \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43+=vV2.z*g_lpfBBSwanNavSpeed[dwCount];
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check primary state
\par \tab \tab switch(g_lpdwBBSwanPriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // follow
\par \tab \tab case(PRST_BBSWAN_FOLLOW):
\par \tab \tab \tab // get baby swan position
\par \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab // get average parent position
\par \tab \tab \tab vV2=D3DXVECTOR3(fParentX,0,fParentZ);
\par 
\par \tab \tab \tab // get distance to parents
\par \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab vV1.z-vV2.z);
\par 
\par \tab \tab \tab // check distance to parents
\par \tab \tab \tab if(fDist<Squared(BBSWAN_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]>(g_lpfSwanNavSpeed[dwParent1Index]*SWAN_TRACKINGSPEEDVAL)+SWAN_TRACKINGSPEEDINC)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(g_lpfBBSwanNavSpeed[dwIndex]<(g_lpfSwanNavSpeed[dwParent1Index]*SWAN_TRACKINGSPEEDVAL1)-SWAN_TRACKINGSPEEDINC1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==NVST_BBSWAN_JUSTSWIM)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%BBSWAN_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%BBSWAN_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%BBSWAN_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par   \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get vector from swan to parent
\par \tab \tab \tab \tab vV3=vV2-vV1;
\par 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab Normalize(&vV2,&vV3);
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // get baby swan ahead vector
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._33);
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV1,&vV2)>0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab if(DotProduct(&vV3,&vV2)>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDRIGHT;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDLEFT;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab // save tracking value
\par \tab \tab \tab \tab \tab fTrackingVal=DotProduct(&vV3,&vV2);
\par 
\par \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab if(fabsf(fTrackingVal)>SWAN_FOLLOWTRACKINGVAL)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab if(fTrackingVal>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]<((g_lpfSwanNavSpeed[dwParent1Index]*SWAN_TRACKINGSPEEDVAL)+SWAN_TRACKINGSPEEDINC)-SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else if(g_lpfBBSwanNavSpeed[dwIndex]>((g_lpfSwanNavSpeed[dwParent1Index]*SWAN_TRACKINGSPEEDVAL)+SWAN_TRACKINGSPEEDINC)+SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check distance to parents
\par \tab \tab \tab \tab \tab \tab if(fDist>Squared(BBSWAN_PANICDISTANCE))
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to panic
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_PANIC;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else if(fDist>Squared(BBSWAN_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]<((g_lpfSwanNavSpeed[dwParent1Index]*SWAN_TRACKINGSPEEDVAL2)+SWAN_TRACKINGSPEEDINC2)-SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else if(g_lpfBBSwanNavSpeed[dwIndex]>((g_lpfSwanNavSpeed[dwParent1Index]*SWAN_TRACKINGSPEEDVAL2)+SWAN_TRACKINGSPEEDINC2)+SWAN_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // change primary state if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%BBSWAN_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=(DWORD)(abs(GetRandomInt())%BBSWAN_NUMPRIMARYSTATES);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // wander
\par \tab \tab case(PRST_BBSWAN_WANDER):
\par \tab \tab \tab // get baby swan position
\par \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab // compare position with boundaries
\par \tab \tab \tab if(IsPointOutOfBounds(vV1.x,vV1.z))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to panic
\par \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_PANIC;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get average parent position
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(fParentX,0,fParentZ);
\par 
\par \tab \tab \tab \tab // get distance to parents
\par \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab // check distance to parents
\par \tab \tab \tab \tab if(fDist>Squared(BBSWAN_PANICDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to panic
\par \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_PANIC;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==NVST_BBSWAN_JUSTSWIM)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%BBSWAN_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%BBSWAN_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%BBSWAN_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // change primary state if necessary
\par \tab \tab \tab \tab \tab if((abs(GetRandomInt())%BBSWAN_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=(DWORD)(abs(GetRandomInt())%BBSWAN_NUMPRIMARYSTATES);
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // panic
\par \tab \tab case(PRST_BBSWAN_PANIC):
\par \tab \tab \tab // get baby swan position
\par \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab // get average parent position
\par \tab \tab \tab vV2=D3DXVECTOR3(fParentX,0,fParentZ);
\par 
\par \tab \tab \tab // get distance to parents
\par \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab // check distance to parents
\par \tab \tab \tab if(fDist<Squared(BBSWAN_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // no need to panic!
\par \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_FOLLOW;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get vector from swan to parent
\par \tab \tab \tab \tab vV3=vV2-vV1;
\par 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab Normalize(&vV2,&vV3);
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // get baby swan ahead vector
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._33);
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV1,&vV2)>0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab if(DotProduct(&vV3,&vV2)>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDRIGHT;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDLEFT;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]<BBSWAN_MAXSPEED)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab // save tracking value
\par \tab \tab \tab \tab \tab fTrackingVal=DotProduct(&vV3,&vV2);
\par 
\par \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab if(fabsf(fTrackingVal)>SWAN_FOLLOWTRACKINGVAL)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab if(fTrackingVal>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]<BBSWAN_MAXSPEED)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // rest
\par \tab \tab case(PRST_BBSWAN_REST):
\par \tab \tab \tab // swan cannot rest unless parents are resting
\par \tab \tab \tab if(dwParent2Index!=NO_OBJECT)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set baby swan to follow if necessary
\par \tab \tab \tab \tab if(g_lpdwSwanPriState[dwParent1Index]!=PRST_SWAN_REST||
\par \tab \tab \tab \tab    g_lpdwSwanPriState[dwParent2Index]!=PRST_SWAN_REST)
\par \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_FOLLOW;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set baby swan to follow if necessary
\par \tab \tab \tab \tab if(g_lpdwSwanPriState[dwParent1Index]!=PRST_SWAN_REST)
\par \tab \tab \tab \tab \tab g_lpdwBBSwanPriState[dwIndex]=PRST_BBSWAN_FOLLOW;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // get baby swan position
\par \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab // get average parent position
\par \tab \tab \tab vV2=D3DXVECTOR3(fParentX,0,fParentZ);
\par 
\par \tab \tab \tab // get distance to parents
\par \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab // check distance to parents & boundaries
\par \tab \tab \tab if(fDist>Squared(BBSWAN_MAXRESTDISTANCE)||
\par \tab \tab \tab    IsPointOutOfBounds(fX,fZ))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set parent #1 to lead
\par \tab \tab \tab \tab g_lpdwSwanPriState[dwParent1Index]=PRST_SWAN_LEAD;
\par 
\par \tab \tab \tab \tab // set parent #2 to follow if necessary
\par \tab \tab \tab \tab if(dwParent2Index!=NO_OBJECT)
\par \tab \tab \tab \tab \tab g_lpdwSwanPriState[dwParent2Index]=PRST_SWAN_FOLLOW;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]>BBSWAN_MAXRESTSPEED)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==NVST_BBSWAN_JUSTSWIM)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%BBSWAN_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%BBSWAN_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwBBSwanNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%BBSWAN_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab if(g_lpdwBBSwanNavState[dwIndex]!=NVST_BBSWAN_JUSTSWIM)
\par \tab \tab \{
\par \tab \tab \tab // check navigation position
\par \tab \tab \tab if(g_lpdwBBSwanNavPos[dwIndex]<g_lpdwBBSwanNavMax[dwIndex])
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bNavFlag=TRUE;
\par 
\par \tab \tab \tab \tab // increment navigation position
\par \tab \tab \tab \tab g_lpdwBBSwanNavPos[dwIndex]++;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset flag
\par \tab \tab \tab \tab bNavFlag=FALSE;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab switch(g_lpdwBBSwanNavState[dwIndex])
\par \tab \tab \{
\par \tab \tab // speed up
\par \tab \tab case(NVST_SWAN_SPEEDUP):
\par \tab \tab \tab // increase speed
\par \tab \tab \tab g_lpfBBSwanNavSpeed[dwIndex]+=BBSWAN_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]>BBSWAN_MAXSPEED)
\par \tab \tab \tab \tab g_lpfBBSwanNavSpeed[dwIndex]=BBSWAN_MAXSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // slow down
\par \tab \tab case(NVST_BBSWAN_SLOWDOWN):
\par \tab \tab \tab // decrease speed
\par \tab \tab \tab g_lpfBBSwanNavSpeed[dwIndex]-=BBSWAN_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfBBSwanNavSpeed[dwIndex]<0)
\par \tab \tab \tab \tab g_lpfBBSwanNavSpeed[dwIndex]=0;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn left
\par \tab \tab case(NVST_BBSWAN_TURNLEFT):
\par \tab \tab \tab // check for panic mode & turn as needed
\par \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],BBSWAN_TURNINC*BBSWAN_PANICTURNFACTOR);
\par \tab \tab \tab else
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],BBSWAN_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn right
\par \tab \tab case(NVST_BBSWAN_TURNRIGHT):
\par \tab \tab \tab // check for panic mode & turn as needed
\par \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],-(BBSWAN_TURNINC*BBSWAN_PANICTURNFACTOR));
\par \tab \tab \tab else
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],-BBSWAN_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard left
\par \tab \tab case(NVST_BBSWAN_HARDLEFT):
\par \tab \tab \tab // check for panic mode & turn as needed
\par \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],BBSWAN_HARDTURNINC*BBSWAN_PANICTURNFACTOR);
\par \tab \tab \tab else
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],BBSWAN_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard right
\par \tab \tab case(NVST_BBSWAN_HARDRIGHT):
\par \tab \tab \tab // check for panic mode & turn as needed
\par \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],-(BBSWAN_HARDTURNINC*BBSWAN_PANICTURNFACTOR));
\par \tab \tab \tab else
\par \tab \tab \tab \tab MatrixYaw(g_lpdwBBSwanMtx[dwIndex],-BBSWAN_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwBBSwanNavState[dwIndex]=NVST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // check for panic mode & move baby swan
\par \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab MatrixBack(g_lpdwBBSwanMtx[dwIndex],g_lpfBBSwanNavSpeed[dwIndex]*BBSWAN_PANICSPEEDFACTOR);
\par \tab \tab else
\par \tab \tab \tab MatrixBack(g_lpdwBBSwanMtx[dwIndex],g_lpfBBSwanNavSpeed[dwIndex]);
\par 
\par \tab \tab // check for panic mode & update tail
\par \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab g_lpfBBSwanTailPos[dwIndex]+=g_lpfBBSwanTailDir[dwIndex]+(g_lpfBBSwanNavSpeed[dwIndex]*BBSWAN_PANICSPEEDFACTOR);
\par \tab \tab else
\par \tab \tab \tab g_lpfBBSwanTailPos[dwIndex]+=g_lpfBBSwanTailDir[dwIndex]+g_lpfBBSwanNavSpeed[dwIndex];
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_lpfBBSwanTailPos[dwIndex]>=1.0F)
\par \tab \tab \{
\par \tab \tab \tab // clip position
\par \tab \tab \tab g_lpfBBSwanTailPos[dwIndex]=1.0F;
\par 
\par \tab \tab \tab // reverse direction
\par \tab \tab \tab g_lpfBBSwanTailDir[dwIndex]=-g_lpfBBSwanTailDir[dwIndex];
\par \tab \tab \}
\par \tab \tab else if(g_lpfBBSwanTailPos[dwIndex]<=-1.0F)
\par \tab \tab \{
\par \tab \tab \tab // clip position
\par \tab \tab \tab g_lpfBBSwanTailPos[dwIndex]=-1.0F;
\par 
\par \tab \tab \tab // reverse direction
\par \tab \tab \tab g_lpfBBSwanTailDir[dwIndex]=-g_lpfBBSwanTailDir[dwIndex];
\par \tab \tab \}
\par 
\par \tab \tab // check action state
\par \tab \tab switch(g_lpdwBBSwanActState[dwIndex])
\par \tab \tab \{
\par \tab \tab // just swim
\par \tab \tab case(ACST_BBSWAN_JUSTSWIM):
\par \tab \tab \tab // set tween value
\par \tab \tab \tab g_lpfBBSwanTweenVal[dwIndex]=GetNaturalizedTweenValue((g_lpfBBSwanTailPos[dwIndex]+1.0F)*0.5F);
\par 
\par \tab \tab \tab // change states if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%BBSWAN_ACTIONCHANGERATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab switch(abs(GetRandomInt())%BBSWAN_NUMACTIONSTATES)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab // head up
\par \tab \tab \tab \tab case(ACST_BBSWAN_HEADUP):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HUTR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HUTL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down
\par \tab \tab \tab \tab case(ACST_BBSWAN_HEADDOWN):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HDTR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HDTL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head left
\par \tab \tab \tab \tab case(ACST_BBSWAN_HEADLEFT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HL1TR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HL1TL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head right
\par \tab \tab \tab \tab case(ACST_BBSWAN_HEADRIGHT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HR1TR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HR1TL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head left #2
\par \tab \tab \tab \tab case(ACST_BBSWAN_HEADLEFT2):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HL2TR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HL2TL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head right #2
\par \tab \tab \tab \tab case(ACST_BBSWAN_HEADRIGHT2):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HR2TR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HR2TL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // look ahead
\par \tab \tab \tab \tab default:
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey1[dwIndex]=KEYF_BBSWAN_HCTR;
\par \tab \tab \tab \tab \tab g_lpdwBBSwanTransKey2[dwIndex]=KEYF_BBSWAN_HCTL;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransSpeed[dwIndex]=BBSWAN_TRANSITIONSPEED+(GetRandomFloat()*BBSWAN_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set state to transition
\par \tab \tab \tab \tab g_lpdwBBSwanActState[dwIndex]=ACST_BBSWAN_TRANSITION;
\par 
\par \tab \tab \tab \tab // set transition position flag
\par \tab \tab \tab \tab g_lpfBBSwanTransPos[dwIndex]=-1.0F;
\par \tab \tab \tab \}
\par \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab 
\par \tab \tab // perform transition
\par \tab \tab case(ACST_BBSWAN_TRANSITION):
\par \tab \tab \tab // check position flag
\par \tab \tab \tab if(g_lpfBBSwanTransPos[dwIndex]<0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab g_lpfBBSwanTweenVal[dwIndex]=GetNaturalizedTweenValue((g_lpfBBSwanTailPos[dwIndex]+1.0F)*0.5F);
\par 
\par \tab \tab \tab \tab // continue until keyframe is reached
\par \tab \tab \tab \tab if(IsNearEqual(g_lpfBBSwanTweenVal[dwIndex],1))
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransPos[dwIndex]=2;
\par \tab \tab \tab \}
\par \tab \tab \tab else if(g_lpfBBSwanTransPos[dwIndex]>1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab g_lpfBBSwanTweenVal[dwIndex]=0;
\par 
\par \tab \tab \tab \tab // set new keyframes
\par \tab \tab \tab \tab g_lpdwBBSwanKeyframe1[dwIndex]=g_lpdwBBSwanKeyframe2[dwIndex];
\par \tab \tab \tab \tab g_lpdwBBSwanKeyframe2[dwIndex]=g_lpdwBBSwanTransKey1[dwIndex];
\par 
\par \tab \tab \tab \tab // set position value
\par \tab \tab \tab \tab g_lpfBBSwanTransPos[dwIndex]=0;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check for panic mode & increment transition position
\par \tab \tab \tab \tab if(g_lpdwBBSwanNavState[dwIndex]==PRST_BBSWAN_PANIC)
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransPos[dwIndex]+=(g_lpfBBSwanTransSpeed[dwIndex]*BBSWAN_PANICSPEEDFACTOR);
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab g_lpfBBSwanTransPos[dwIndex]+=g_lpfBBSwanTransSpeed[dwIndex];
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // check for overflow
\par \tab \tab \tab \tab if(g_lpfBBSwanTransPos[dwIndex]>1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab \tab g_lpfBBSwanTweenVal[dwIndex]=0;
\par 
\par \tab \tab \tab \tab \tab // reset tail position & direction
\par \tab \tab \tab \tab \tab g_lpfBBSwanTailPos[dwIndex]=-1;
\par \tab \tab \tab \tab \tab g_lpfBBSwanTailDir[dwIndex]=fabsf(g_lpfBBSwanTailDir[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab // set final keyframes
\par \tab \tab \tab \tab \tab g_lpdwBBSwanKeyframe1[dwIndex]=g_lpdwBBSwanTransKey1[dwIndex];
\par \tab \tab \tab \tab \tab g_lpdwBBSwanKeyframe2[dwIndex]=g_lpdwBBSwanTransKey2[dwIndex];
\par 
\par \tab \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab \tab g_lpdwBBSwanActState[dwIndex]=ACST_BBSWAN_JUSTSWIM;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab \tab g_lpfBBSwanTweenVal[dwIndex]=GetNaturalizedTweenValue(g_lpfBBSwanTransPos[dwIndex]);
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // start ripples if necessary
\par \tab \tab if(IsRippleComplete(g_lpdwBBSwanRipple1Idx[dwIndex]))
\par \tab \tab \tab StartRipple(g_lpdwBBSwanRipple1Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43,
\par \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \tab if(IsRippleComplete(g_lpdwBBSwanRipple2Idx[dwIndex]))
\par \tab \tab \tab StartRipple(g_lpdwBBSwanRipple2Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwBBSwanMtx[dwIndex]].mtx._43,
\par \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \}
\par \}
\par 
\par // GetNextTurtle()
\par 
\par DWORD GetNextTurtle(void)
\par \{
\par \tab LoadingOutput("GetNextTurtle");
\par 
\par \tab // check counter
\par \tab if(g_dwNumTurtle==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleMtx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtlePriState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleActState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleNavState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleKeyframe1,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleKeyframe2,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfTurtleTweenVal,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfTurtleTransPos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfTurtleTransSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfTurtleNavSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleNavPos,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleNavMax,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleRipple1Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwTurtleRipple2Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxTurtle=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumTurtle>=g_dwMaxTurtle)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleMtx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtlePriState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleActState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleNavState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleKeyframe1,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleKeyframe2,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfTurtleTweenVal,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfTurtleTransPos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfTurtleTransSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfTurtleNavSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleNavPos,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleNavMax,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleRipple1Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwTurtleRipple2Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxTurtle,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxTurtle+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumTurtle;
\par 
\par \tab // increment counter
\par \tab g_dwNumTurtle++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddTurtle()
\par 
\par DWORD AddTurtle(void)
\par \{
\par \tab LoadingOutput("AddTurtle");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextTurtle();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add turtle matrix
\par \tab g_lpdwTurtleMtx[dwIndex]=AddMatrix(1,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,1,0,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,0,1,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,TURTLE_MAXDIVEDEPTH,0,1);
\par 
\par \tab // check matrix
\par \tab if(g_lpdwTurtleMtx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // scale matrix by turtle scale
\par \tab MatrixScale(g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab TURTLE_SCALE+(GetRandomFloat()*TURTLE_SCALEVAR));
\par 
\par \tab // set default values
\par \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_TRANSFER;
\par \tab g_lpdwTurtleActState[dwIndex]=ACST_TURTLE_JUSTSWIM;
\par \tab g_lpdwTurtleNavState[dwIndex]=NVST_TURTLE_JUSTSWIM;
\par \tab g_lpdwTurtleKeyframe1[dwIndex]=KEYF_TURTLE_HC;
\par \tab g_lpdwTurtleKeyframe2[dwIndex]=KEYF_TURTLE_HC;
\par \tab g_lpfTurtleTweenVal[dwIndex]=0;
\par \tab g_lpfTurtleTransPos[dwIndex]=0;
\par \tab g_lpfTurtleTransSpeed[dwIndex]=0;
\par \tab g_lpfTurtleNavSpeed[dwIndex]=TURTLE_MINSPEED;
\par \tab g_lpdwTurtleNavPos[dwIndex]=0;
\par \tab g_lpdwTurtleNavMax[dwIndex]=0;
\par 
\par \tab // add ripple #1
\par \tab g_lpdwTurtleRipple1Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #1
\par \tab if(g_lpdwTurtleRipple1Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add ripple #2
\par \tab g_lpdwTurtleRipple2Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #2
\par \tab if(g_lpdwTurtleRipple2Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // UpdateTurtles()
\par 
\par void UpdateTurtles(void)
\par \{
\par \tab // turtle index
\par \tab DWORD dwIndex;
\par 
\par \tab // navigation update flag
\par \tab BOOL bNavFlag;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // comparison vector
\par \tab D3DXVECTOR3 vV1;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // polar coordinates
\par \tab float fAngle;
\par \tab float fDist;
\par 
\par \tab // update turtles
\par \tab for(dwIndex=0;dwIndex<g_dwNumTurtle;dwIndex++)
\par \tab \{
\par \tab \tab // set coordinate values
\par \tab \tab fX=g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._41;
\par \tab \tab fZ=g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._43;
\par 
\par \tab \tab // check for transfer state
\par \tab \tab if(g_lpdwTurtlePriState[dwIndex]!=PRST_TURTLE_TRANSFER)
\par \tab \tab \{
\par \tab \tab \tab // compare turtle position with other turtles
\par \tab \tab \tab for(dwCount=0;dwCount<g_dwNumTurtle;dwCount++)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // skip this turtle
\par \tab \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwTurtleMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwTurtleMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(TURTLE_MINTURTLEDISTANCE))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set primary state to dive
\par \tab \tab \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_DIVE;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // compare turtle position with swans
\par \tab \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(TURTLE_MINSWANDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set primary state to dive
\par \tab \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_DIVE;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // compare turtle position with baby swans
\par \tab \tab \tab for(dwCount=0;dwCount<g_dwNumBBSwan;dwCount++)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(TURTLE_MINBBSWANDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set primary state to dive
\par \tab \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_DIVE;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check boundaries
\par \tab \tab \tab if(IsPointOutOfBounds(fX,fZ))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set primary state to dive
\par \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_DIVE;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check primary state
\par \tab \tab switch(g_lpdwTurtlePriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // surface
\par \tab \tab case(PRST_TURTLE_SURFACE):
\par \tab \tab \tab // check navigation state
\par \tab \tab \tab if(g_lpdwTurtleNavState[dwIndex]==NVST_TURTLE_JUSTSWIM)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%TURTLE_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%TURTLE_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%TURTLE_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // surface
\par \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42+=TURTLE_DIVEINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42>0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // clip value
\par \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42=0;
\par 
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // dive
\par \tab \tab case(PRST_TURTLE_DIVE):
\par \tab \tab \tab // check navigation state
\par \tab \tab \tab if(g_lpdwTurtleNavState[dwIndex]==NVST_TURTLE_JUSTSWIM)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%TURTLE_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%TURTLE_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%TURTLE_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // dive
\par \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42-=TURTLE_DIVEINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42<TURTLE_MAXDIVEDEPTH)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // clip value
\par \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42=TURTLE_MAXDIVEDEPTH;
\par 
\par \tab \tab \tab \tab // set state to transfer
\par \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_TRANSFER;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // transfer
\par \tab \tab case(PRST_TURTLE_TRANSFER):
\par \tab \tab \tab // find new position if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%TURTLE_TRANSFERRATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // create random position
\par \tab \tab \tab \tab switch(abs(GetRandomInt())%3)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab // upper round portion of boundary
\par \tab \tab \tab \tab case(0):
\par \tab \tab \tab \tab \tab // set polar coordinates
\par \tab \tab \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab \tab \tab fDist=fabsf(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // set position
\par \tab \tab \tab \tab \tab fX=TERRAIN_CENTERX-(cosf(fAngle)*fDist);
\par \tab \tab \tab \tab \tab fZ=(TERRAIN_CENTERZ-TERRAIN_ZRANGE)-(sinf(fAngle)*fDist);
\par 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // center rectangular portion of boundary
\par \tab \tab \tab \tab case(1):
\par \tab \tab \tab \tab \tab // set position
\par \tab \tab \tab \tab \tab fX=TERRAIN_CENTERX+(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab \tab \tab fZ=TERRAIN_CENTERZ+(GetRandomFloat()*TERRAIN_ZRANGE);
\par 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // lower round portion of boundary
\par \tab \tab \tab \tab case(2):
\par \tab \tab \tab \tab \tab // set polar coordinates
\par \tab \tab \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab \tab \tab fDist=fabsf(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // set position
\par \tab \tab \tab \tab \tab fX=TERRAIN_CENTERX+(cosf(fAngle)*fDist);
\par \tab \tab \tab \tab \tab fZ=(TERRAIN_CENTERZ+TERRAIN_ZRANGE)+(sinf(fAngle)*fDist);
\par 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set turtle position
\par \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._41=fX;
\par \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._43=fZ;
\par 
\par \tab \tab \tab \tab // randomize yaw
\par \tab \tab \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab \tab \tab MatrixYaw(g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab \tab \tab // set primary state to surface
\par \tab \tab \tab \tab g_lpdwTurtlePriState[dwIndex]=PRST_TURTLE_SURFACE;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // just swim
\par \tab \tab case(PRST_TURTLE_JUSTSWIM):
\par \tab \tab \tab // check navigation state
\par \tab \tab \tab if(g_lpdwTurtleNavState[dwIndex]==NVST_TURTLE_JUSTSWIM)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%TURTLE_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%TURTLE_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwTurtleNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%TURTLE_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab if(g_lpdwTurtleNavState[dwIndex]!=NVST_TURTLE_JUSTSWIM)
\par \tab \tab \{
\par \tab \tab \tab // check navigation position
\par \tab \tab \tab if(g_lpdwTurtleNavPos[dwIndex]<g_lpdwTurtleNavMax[dwIndex])
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bNavFlag=TRUE;
\par 
\par \tab \tab \tab \tab // increment navigation position
\par \tab \tab \tab \tab g_lpdwTurtleNavPos[dwIndex]++;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset flag
\par \tab \tab \tab \tab bNavFlag=FALSE;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab switch(g_lpdwTurtleNavState[dwIndex])
\par \tab \tab \{
\par \tab \tab // speed up
\par \tab \tab case(NVST_TURTLE_SPEEDUP):
\par \tab \tab \tab // increase speed
\par \tab \tab \tab g_lpfTurtleNavSpeed[dwIndex]+=TURTLE_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfTurtleNavSpeed[dwIndex]>TURTLE_MAXSPEED)
\par \tab \tab \tab \tab g_lpfTurtleNavSpeed[dwIndex]=TURTLE_MAXSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=NVST_TURTLE_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // slow down
\par \tab \tab case(NVST_TURTLE_SLOWDOWN):
\par \tab \tab \tab // decrease speed
\par \tab \tab \tab g_lpfTurtleNavSpeed[dwIndex]-=TURTLE_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfTurtleNavSpeed[dwIndex]<TURTLE_MINSPEED)
\par \tab \tab \tab \tab g_lpfTurtleNavSpeed[dwIndex]=TURTLE_MINSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=NVST_TURTLE_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn left
\par \tab \tab case(NVST_TURTLE_TURNLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab   TURTLE_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=NVST_TURTLE_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn right
\par \tab \tab case(NVST_TURTLE_TURNRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -TURTLE_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwTurtleNavState[dwIndex]=NVST_TURTLE_JUSTSWIM;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // move turtle
\par \tab \tab MatrixBack(g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab    g_lpfTurtleNavSpeed[dwIndex]);
\par 
\par \tab \tab // check action state
\par \tab \tab switch(g_lpdwTurtleActState[dwIndex])
\par \tab \tab \{
\par \tab \tab // just swim
\par \tab \tab case(ACST_TURTLE_JUSTSWIM):
\par \tab \tab \tab // change states if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%TURTLE_ACTIONCHANGERATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // copy current keyframe to first keyframe
\par \tab \tab \tab \tab g_lpdwTurtleKeyframe1[dwIndex]=g_lpdwTurtleKeyframe2[dwIndex];
\par 
\par \tab \tab \tab \tab // reset tween value
\par \tab \tab \tab \tab g_lpfTurtleTweenVal[dwIndex]=0;
\par 
\par \tab \tab \tab \tab switch(abs(GetRandomInt())%TURTLE_NUMACTIONSTATES)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab // head up
\par \tab \tab \tab \tab case(ACST_TURTLE_HEADUP):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwTurtleKeyframe2[dwIndex]=KEYF_TURTLE_HU;
\par \tab \tab \tab \tab \tab g_lpfTurtleTransSpeed[dwIndex]=TURTLE_TRANSITIONSPEED+(GetRandomFloat()*TURTLE_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head down
\par \tab \tab \tab \tab case(ACST_TURTLE_HEADDOWN):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwTurtleKeyframe2[dwIndex]=KEYF_TURTLE_HD;
\par \tab \tab \tab \tab \tab g_lpfTurtleTransSpeed[dwIndex]=TURTLE_TRANSITIONSPEED+(GetRandomFloat()*TURTLE_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head left
\par \tab \tab \tab \tab case(ACST_TURTLE_HEADLEFT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwTurtleKeyframe2[dwIndex]=KEYF_TURTLE_HL;
\par \tab \tab \tab \tab \tab g_lpfTurtleTransSpeed[dwIndex]=TURTLE_TRANSITIONSPEED+(GetRandomFloat()*TURTLE_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // head right
\par \tab \tab \tab \tab case(ACST_TURTLE_HEADRIGHT):
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwTurtleKeyframe2[dwIndex]=KEYF_TURTLE_HR;
\par \tab \tab \tab \tab \tab g_lpfTurtleTransSpeed[dwIndex]=TURTLE_TRANSITIONSPEED+(GetRandomFloat()*TURTLE_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab \tab // look ahead
\par \tab \tab \tab \tab default:
\par \tab \tab \tab \tab \tab // set transition values
\par \tab \tab \tab \tab \tab g_lpdwTurtleKeyframe2[dwIndex]=KEYF_TURTLE_HC;
\par \tab \tab \tab \tab \tab g_lpfTurtleTransSpeed[dwIndex]=TURTLE_TRANSITIONSPEED+(GetRandomFloat()*TURTLE_TRANSITIONSPEED*0.5F);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set state to transition
\par \tab \tab \tab \tab g_lpdwTurtleActState[dwIndex]=ACST_TURTLE_TRANSITION;
\par 
\par \tab \tab \tab \tab // set transition position
\par \tab \tab \tab \tab g_lpfTurtleTransPos[dwIndex]=0;
\par \tab \tab \tab \}
\par \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab 
\par \tab \tab // perform transition
\par \tab \tab case(ACST_TURTLE_TRANSITION):
\par \tab \tab \tab // increment transition position
\par \tab \tab \tab g_lpfTurtleTransPos[dwIndex]+=g_lpfTurtleTransSpeed[dwIndex];
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfTurtleTransPos[dwIndex]>1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab g_lpfTurtleTweenVal[dwIndex]=1;
\par 
\par \tab \tab \tab \tab // set state to swim
\par \tab \tab \tab \tab g_lpdwTurtleActState[dwIndex]=ACST_TURTLE_JUSTSWIM;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set tween value
\par \tab \tab \tab \tab g_lpfTurtleTweenVal[dwIndex]=GetNaturalizedTweenValue(g_lpfTurtleTransPos[dwIndex]);
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // start ripples if necessary
\par \tab \tab if(IsRippleComplete(g_lpdwTurtleRipple1Idx[dwIndex]))
\par \tab \tab \tab StartRipple(g_lpdwTurtleRipple1Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._43,
\par \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \tab if(IsRippleComplete(g_lpdwTurtleRipple2Idx[dwIndex]))
\par \tab \tab \tab StartRipple(g_lpdwTurtleRipple2Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._43,
\par \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \}
\par \}
\par 
\par // RenderTurtles()
\par 
\par void RenderTurtles(void)
\par \{
\par \tab // turtle index
\par \tab DWORD dwIndex;
\par 
\par \tab // y-value
\par \tab float fY;
\par 
\par \tab // alpha value
\par \tab float fAlpha;
\par 
\par #ifndef REFLECTION_OPTIMIZATION
\par \tab // render turtles
\par \tab for(dwIndex=0;dwIndex<g_dwNumTurtle;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwTurtleKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwTurtleKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfTurtleTweenVal[dwIndex]);
\par 
\par \tab \tab // get y-value
\par \tab \tab fY=g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42;
\par \tab \tab 
\par \tab \tab // compute alpha value
\par \tab \tab if(fY>(TURTLE_MAXDIVEDEPTH*0.5F))
\par \tab \tab \tab fAlpha=1;
\par \tab \tab else
\par \tab \tab \tab fAlpha=1-((fY-(TURTLE_MAXDIVEDEPTH*0.5F))/(TURTLE_MAXDIVEDEPTH*0.5F));
\par \tab \tab 
\par \tab \tab // render turtle
\par \tab \tab RenderAnimationAlpha(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  fAlpha);
\par \tab \}
\par 
\par \tab // enable frontface cull
\par \tab EnableFrontfaceCull();
\par \tab 
\par \tab // render turtle reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumTurtle;dwIndex++)
\par \tab \{
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwTurtleKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwTurtleKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfTurtleTweenVal[dwIndex]);
\par \tab \tab 
\par \tab \tab // get y-value
\par \tab \tab fY=g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42;
\par \tab \tab 
\par \tab \tab // compute alpha value
\par \tab \tab if(fY>(TURTLE_MAXDIVEDEPTH*0.5F))
\par \tab \tab \tab fAlpha=1-(fY/(TURTLE_MAXDIVEDEPTH*0.5F));
\par \tab \tab else
\par \tab \tab \tab fAlpha=0;
\par 
\par \tab \tab 
\par \tab \tab // render turtle
\par \tab \tab RenderAnimationAlpha(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  fAlpha);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale;
\par \tab \}
\par \tab 
\par \tab // enable backface cull
\par \tab EnableBackfaceCull();
\par #else
\par \tab // render turtles & reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumTurtle;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwTurtleKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwTurtleKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfTurtleTweenVal[dwIndex]);
\par 
\par \tab \tab // get y-value
\par \tab \tab fY=g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42;
\par \tab \tab 
\par \tab \tab // compute alpha value
\par \tab \tab if(fY>(TURTLE_MAXDIVEDEPTH*0.5F))
\par \tab \tab \tab fAlpha=1;
\par \tab \tab else
\par \tab \tab \tab fAlpha=1-((fY-(TURTLE_MAXDIVEDEPTH*0.5F))/(TURTLE_MAXDIVEDEPTH*0.5F));
\par \tab \tab 
\par \tab \tab // render turtle
\par \tab \tab RenderAnimationAlpha(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  fAlpha);
\par \tab \tab // enable frontface cull
\par \tab \tab EnableFrontfaceCull();
\par \tab 
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // get y-value
\par \tab \tab fY=g_lpMtx[g_lpdwTurtleMtx[dwIndex]].mtx._42;
\par \tab \tab 
\par \tab \tab // compute alpha value
\par \tab \tab if(fY>(TURTLE_MAXDIVEDEPTH*0.5F))
\par \tab \tab \tab fAlpha=1-(fY/(TURTLE_MAXDIVEDEPTH*0.5F));
\par \tab \tab else
\par \tab \tab \tab fAlpha=0;
\par 
\par \tab \tab // render turtle
\par \tab \tab RenderAnimationAlpha(g_dwTurtleAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwTurtleMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  fAlpha);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwTurtleMtx[dwIndex]].fYScale;
\par \tab 
\par \tab \tab // enable backface cull
\par \tab \tab EnableBackfaceCull();
\par \tab \}
\par #endif
\par \}
\par 
\par // PurgeTurtles()
\par 
\par void PurgeTurtles(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleMtx);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtlePriState);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleActState);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleNavState);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleKeyframe1);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleKeyframe2);
\par \tab FreeMem((LPVOID*)&g_lpfTurtleTweenVal);
\par \tab FreeMem((LPVOID*)&g_lpfTurtleTransPos);
\par \tab FreeMem((LPVOID*)&g_lpfTurtleTransSpeed);
\par \tab FreeMem((LPVOID*)&g_lpfTurtleNavSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleNavPos);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleNavMax);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleRipple1Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwTurtleRipple2Idx);
\par 
\par \tab // reset counters
\par \tab g_dwNumTurtle=0;
\par \tab g_dwMaxTurtle=0;
\par \}
\par 
\par // GetNextDragonfly()
\par 
\par DWORD GetNextDragonfly(void)
\par \{
\par \tab LoadingOutput("GetNextDragonfly");
\par 
\par \tab // check counter
\par \tab if(g_dwNumDFly==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyMtx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyPriState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyNavState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfDFlyNavSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyNavPos,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyNavMax,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpvDFlyDartVec,
\par \tab \tab \tab \tab \tab  sizeof(D3DXVECTOR3)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyMateIdx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyAPathID,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwDFlyBuzzIdx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpbDFlyPlayback,
\par \tab \tab \tab \tab \tab  sizeof(BOOL)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxDFly=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumDFly>=g_dwMaxDFly)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyMtx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyPriState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyNavState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfDFlyNavSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyNavPos,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyNavMax,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpvDFlyDartVec,
\par \tab \tab \tab \tab \tab    sizeof(D3DXVECTOR3)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(D3DXVECTOR3)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyMateIdx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyAPathID,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwDFlyBuzzIdx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpbDFlyPlayback,
\par \tab \tab \tab \tab \tab    sizeof(BOOL)*g_dwMaxDFly,
\par \tab \tab \tab \tab \tab    sizeof(BOOL)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxDFly+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumDFly;
\par 
\par \tab // increment counter
\par \tab g_dwNumDFly++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddDragonfly()
\par 
\par DWORD AddDragonfly(void)
\par \{
\par \tab LoadingOutput("AddDragonfly");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextDragonfly();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add dragonfly matrix
\par \tab g_lpdwDFlyMtx[dwIndex]=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_lpdwDFlyMtx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // scale matrix by dragonfly scale
\par \tab MatrixScale(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab DRGFLY_SCALE+(GetRandomFloat()*DRGFLY_SCALEVAR));
\par 
\par \tab // set height of dragonfly
\par \tab MatrixUp(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab  DFLY_MINHEIGHT+((DFLY_MAXHEIGHT-DFLY_MINHEIGHT)*fabsf(GetRandomFloat())));
\par 
\par \tab // set default values
\par \tab g_lpdwDFlyPriState[dwIndex]=PRST_DFLY_REST;
\par \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab g_lpfDFlyNavSpeed[dwIndex]=0;
\par \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab g_lpdwDFlyNavMax[dwIndex]=0;
\par \tab g_lpvDFlyDartVec[dwIndex]=D3DXVECTOR3(0,0,0);
\par \tab g_lpdwDFlyMateIdx[dwIndex]=NO_OBJECT;
\par \tab g_lpdwDFlyAPathID[dwIndex]=NO_OBJECT;
\par \tab g_lpdwDFlyBuzzIdx[dwIndex]=NO_OBJECT;
\par \tab g_lpbDFlyPlayback[dwIndex]=TRUE;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // SetDragonflyMatrix()
\par 
\par void SetDragonflyMatrix(DWORD dwIndex,
\par \tab \tab \tab \tab \tab \tab LPD3DXMATRIX lpMtx)
\par \{
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwIndex>=g_dwNumDFly)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid dragonfly index.",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "SetDragonflyMatrix()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \tab return;
\par \tab \}
\par #endif
\par 
\par \tab // set matrix
\par \tab SetMatrix(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab   lpMtx);
\par \}
\par 
\par // PurgeDragonflies()
\par 
\par void PurgeDragonflies(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyMtx);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyPriState);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyNavState);
\par \tab FreeMem((LPVOID*)&g_lpfDFlyNavSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyNavPos);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyNavMax);
\par \tab FreeMem((LPVOID*)&g_lpvDFlyDartVec);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyMateIdx);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyAPathID);
\par \tab FreeMem((LPVOID*)&g_lpdwDFlyBuzzIdx);
\par \tab FreeMem((LPVOID*)&g_lpbDFlyPlayback);
\par 
\par \tab // reset counters
\par \tab g_dwNumDFly=0;
\par \tab g_dwMaxDFly=0;
\par \}
\par 
\par // RenderDragonfliesA()
\par 
\par void RenderDragonfliesA(void)
\par \{
\par \tab // dragonfly index
\par \tab DWORD dwIndex;
\par 
\par \tab // render dragonflies
\par \tab for(dwIndex=0;dwIndex<g_dwNumDFly;dwIndex++)
\par \tab \{
\par \tab \tab // render dragonfly body
\par \tab \tab RenderMesh(g_dwDragonflyMesh,
\par \tab \tab \tab \tab    g_lpdwDFlyMtx[dwIndex]);
\par \tab \}
\par 
\par \tab // enable frontface cull
\par \tab EnableFrontfaceCull();
\par \tab 
\par \tab // render dragonfly reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumDFly;dwIndex++)
\par \tab \{
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwDFlyMtx[dwIndex]].fYScale;
\par 
\par \tab \tab // invert y-position
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42=-g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42;
\par 
\par \tab \tab // render dragonfly body
\par \tab \tab RenderMesh(g_dwDragonflyMesh,
\par \tab \tab \tab \tab    g_lpdwDFlyMtx[dwIndex]);
\par 
\par \tab \tab // set keyframe for upper wings
\par \tab \tab UpdateRenderFrames(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab    0,
\par \tab \tab \tab \tab \tab \tab    1,
\par \tab \tab \tab \tab \tab \tab    fabsf(GetRandomFloat()));
\par 
\par \tab \tab // render upper wings
\par \tab \tab RenderAnimationAlpha(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  DFLY_WINGALPHA);
\par 
\par \tab \tab // set keyframe for lower wings
\par \tab \tab UpdateRenderFrames(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab    0,
\par \tab \tab \tab \tab \tab \tab    2,
\par \tab \tab \tab \tab \tab \tab    fabsf(GetRandomFloat()));
\par 
\par \tab \tab // render lower wings
\par \tab \tab RenderAnimationAlpha(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  DFLY_WINGALPHA);
\par \tab \tab 
\par \tab \tab // reset y-position
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42=-g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42;
\par 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwDFlyMtx[dwIndex]].fYScale;
\par \tab \}
\par \tab 
\par \tab // enable backface cull
\par \tab EnableBackfaceCull();
\par \}
\par 
\par // RenderDragonfliesB()
\par 
\par void RenderDragonfliesB(void)
\par \{
\par \tab // dragonfly index
\par \tab DWORD dwIndex;
\par 
\par \tab // render dragonfly wings
\par \tab for(dwIndex=0;dwIndex<g_dwNumDFly;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe for upper wings
\par \tab \tab UpdateRenderFrames(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab    0,
\par \tab \tab \tab \tab \tab \tab    1,
\par \tab \tab \tab \tab \tab \tab    fabsf(GetRandomFloat()));
\par 
\par \tab \tab // render upper wings
\par \tab \tab RenderAnimationAlpha(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  DFLY_WINGALPHA);
\par 
\par \tab \tab // set keyframe for lower wings
\par \tab \tab UpdateRenderFrames(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab    0,
\par \tab \tab \tab \tab \tab \tab    2,
\par \tab \tab \tab \tab \tab \tab    fabsf(GetRandomFloat()));
\par 
\par \tab \tab // render lower wings
\par \tab \tab RenderAnimationAlpha(g_dwDragonflyWingAnim,
\par \tab \tab \tab \tab \tab \tab \tab  g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab  DFLY_WINGALPHA);
\par \tab \}
\par \}
\par 
\par // AddDragonflyLoner()
\par 
\par DWORD AddDragonflyLoner(void)
\par \{
\par \tab LoadingOutput("AddDragonflyLoner");
\par 
\par \tab // dragonfly index
\par \tab DWORD dwIndex;
\par 
\par \tab // polar coordinate values
\par \tab float fAngle;
\par \tab float fDist;
\par \tab 
\par \tab // position values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // matrix
\par \tab D3DXMATRIX mtx;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // done flag
\par \tab BOOL bDone;
\par \tab 
\par \tab // add dragonfly
\par \tab dwIndex=AddDragonfly();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // reset done flag
\par \tab bDone=FALSE;
\par 
\par \tab // loop until suitable position is found
\par \tab while(!bDone)
\par \tab \{
\par \tab \tab // create random position
\par \tab \tab switch(abs(GetRandomInt())%3)
\par \tab \tab \{
\par \tab \tab // upper round portion of boundary
\par \tab \tab case(0):
\par \tab \tab \tab // set polar coordinates
\par \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab fDist=fabsf(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab 
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX-(cosf(fAngle)*fDist);
\par \tab \tab \tab fZ=(TERRAIN_CENTERZ-TERRAIN_ZRANGE)-(sinf(fAngle)*fDist);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // center rectangular portion of boundary
\par \tab \tab case(1):
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX+(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab fZ=TERRAIN_CENTERZ+(GetRandomFloat()*TERRAIN_ZRANGE);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // lower round portion of boundary
\par \tab \tab case(2):
\par \tab \tab \tab // set polar coordinates
\par \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab fDist=fabsf(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab 
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX+(cosf(fAngle)*fDist);
\par \tab \tab \tab fZ=(TERRAIN_CENTERZ+TERRAIN_ZRANGE)+(sinf(fAngle)*fDist);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // assume that we will be done
\par \tab \tab bDone=TRUE;
\par \tab \tab 
\par \tab \tab // compare position with other dragonflies
\par \tab \tab for(dwCount=0;dwCount<g_dwNumDFly;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // skip this dragonfly
\par \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get dragonfly position
\par \tab \tab \tab \tab float fDFlyX=g_lpMtx[g_lpdwDFlyMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab float fDFlyZ=g_lpMtx[g_lpdwDFlyMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab // compare distance with separation distance
\par \tab \tab \tab \tab if(SquareMagnitudeXZ(fDFlyX-fX,fDFlyZ-fZ)<Squared(DFLY_SEPARATIONDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // reset done fkag
\par \tab \tab \tab \tab \tab bDone=FALSE;
\par 
\par \tab \tab \tab \tab \tab // end loop
\par \tab \tab \tab \tab \tab dwCount=g_dwNumDFly;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // set dragonfly position
\par \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41=fX;
\par \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43=fZ;
\par 
\par \tab // randomize yaw
\par \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab // set primary state
\par \tab g_lpdwDFlyPriState[dwIndex]=(DWORD)(abs(GetRandomInt())%DFLY_NUMPRIMARYSTATES);
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddDragonflyCouple()
\par 
\par DWORD AddDragonflyCouple(void)
\par \{
\par \tab LoadingOutput("AddDragonflyCouple");
\par 
\par \tab // dragonfly indices
\par \tab DWORD dwIndex1;
\par \tab DWORD dwIndex2;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // add dragonfly #1
\par \tab dwIndex1=AddDragonflyLoner();
\par 
\par \tab // check dragonfly #1
\par \tab if(dwIndex1==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add dragonfly #2
\par \tab dwIndex2=AddDragonfly();
\par 
\par \tab // check dragonfly #2
\par \tab if(dwIndex2==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // set mate values
\par \tab g_lpdwDFlyMateIdx[dwIndex1]=dwIndex2;
\par \tab g_lpdwDFlyMateIdx[dwIndex2]=dwIndex1;
\par 
\par \tab // set primary state & position of dragonfly #2
\par \tab switch(g_lpdwDFlyPriState[dwIndex1])
\par \tab \{
\par \tab // dragonfly #1 leading
\par \tab case(PRST_DFLY_LEAD):
\par \tab \tab // set dragonfly #2 to follow
\par \tab \tab g_lpdwDFlyPriState[dwIndex2]=PRST_DFLY_FOLLOW;
\par 
\par \tab \tab // copy dragonfly #1's position to dragonfly #2
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._41=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._42=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._43=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._43;
\par 
\par \tab \tab // randomize yaw of dragonfly #2
\par \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex2],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move dragonfly #2 back by follow distance
\par \tab \tab MatrixAhead(g_lpdwDFlyMtx[dwIndex2],
\par \tab \tab \tab \tab \tab DFLY_MAXFOLLOWDISTANCE);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // dragonfly #1 following
\par \tab case(PRST_DFLY_FOLLOW):
\par \tab \tab // set dragonfly #2 to lead
\par \tab \tab g_lpdwDFlyPriState[dwIndex2]=PRST_DFLY_LEAD;
\par 
\par \tab \tab // copy dragonfly #1's position to dragonfly #2
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._41=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._42=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._43=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._43;
\par 
\par \tab \tab // randomize yaw of dragonfly #2
\par \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex2],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move dragonfly #1 back by follow distance
\par \tab \tab MatrixAhead(g_lpdwDFlyMtx[dwIndex1],
\par \tab \tab \tab \tab \tab DFLY_MAXFOLLOWDISTANCE);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // dragonfly #1 resting
\par \tab case(PRST_DFLY_REST):
\par \tab \tab // set dragonfly #2 to rest
\par \tab \tab g_lpdwDFlyPriState[dwIndex2]=PRST_DFLY_REST;
\par 
\par \tab \tab // copy dragonfly #1's position to dragonfly #2
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._41=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._41;
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._42=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._42;
\par \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._43=g_lpMtx[g_lpdwDFlyMtx[dwIndex1]].mtx._43;
\par 
\par \tab \tab // randomize yaw of dragonfly #2
\par \tab \tab for(dwCount=0;dwCount<8;dwCount++)
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex2],
\par \tab \tab \tab \tab \tab   fabsf(GetRandomFloat()));
\par 
\par \tab \tab // move dragonfly #2 back by follow distance
\par \tab \tab MatrixAhead(g_lpdwDFlyMtx[dwIndex2],
\par \tab \tab \tab \tab \tab DFLY_MAXFOLLOWDISTANCE);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // set height of dragonfly #2
\par \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex2]].mtx._42=DFLY_MINHEIGHT+((DFLY_MAXHEIGHT-DFLY_MINHEIGHT)*fabsf(GetRandomFloat()));
\par 
\par \tab // return index #1
\par \tab return(dwIndex1);
\par \}
\par 
\par // RandomizeDragonflyPrimaryState()
\par 
\par void RandomizeDragonflyPrimaryState(DWORD dwIndex)
\par \{
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwIndex>=g_dwNumDFly)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid dragonfly index.",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "RandomizeDragonflyPrimaryState()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \tab return;
\par \tab \}
\par #endif
\par 
\par \tab // set new state
\par \tab g_lpdwDFlyPriState[dwIndex]=(DWORD)(abs(GetRandomInt())%DFLY_NUMPRIMARYSTATES);
\par 
\par \tab // check for mate
\par \tab if(g_lpdwDFlyMateIdx[dwIndex]!=NO_OBJECT)
\par \tab \{
\par \tab \tab // set mate's state accordingly
\par \tab \tab switch(g_lpdwDFlyPriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // this dragonfly leading
\par \tab \tab case(PRST_DFLY_LEAD):
\par \tab \tab \tab // set mate to follow
\par \tab \tab \tab g_lpdwDFlyPriState[g_lpdwDFlyMateIdx[dwIndex]]=PRST_DFLY_FOLLOW;
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // this dragonfly following
\par \tab \tab case(PRST_DFLY_FOLLOW):
\par \tab \tab \tab // set mate to lead
\par \tab \tab \tab g_lpdwDFlyPriState[g_lpdwDFlyMateIdx[dwIndex]]=PRST_DFLY_LEAD;
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // this dragonfly resting
\par \tab \tab case(PRST_DFLY_REST):
\par \tab \tab \tab // set mate to rest
\par \tab \tab \tab g_lpdwDFlyPriState[g_lpdwDFlyMateIdx[dwIndex]]=PRST_DFLY_REST;
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \}
\par \}
\par 
\par // UpdateDragonflies()
\par 
\par void UpdateDragonflies(void)
\par \{
\par \tab // alternating counter
\par \tab static DWORD dwAltCount=0;
\par 
\par \tab // dragonfly index
\par \tab DWORD dwIndex;
\par 
\par \tab // mate index
\par \tab DWORD dwMateIndex;
\par 
\par \tab // navigation update flag
\par \tab BOOL bNavFlag;
\par 
\par \tab // vectors for comparisons
\par \tab D3DXVECTOR3 vV1;
\par \tab D3DXVECTOR3 vV2;
\par \tab D3DXVECTOR3 vV3;
\par 
\par \tab // distance value
\par \tab float fDist;
\par 
\par \tab // tracking value
\par \tab float fTrackingVal;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fY;
\par \tab float fZ;
\par 
\par \tab // boundary flags
\par \tab BOOL bUpper;
\par \tab BOOL bLower;
\par \tab BOOL bCenter;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // audiopath index
\par \tab DWORD dwPathIndex;
\par 
\par \tab // update alternating counter
\par \tab dwAltCount=(dwAltCount+1)&1;
\par 
\par \tab // update dragonflies
\par \tab for(dwIndex=0;dwIndex<g_dwNumDFly;dwIndex++)
\par \tab \{
\par \tab \tab // get mate index
\par \tab \tab dwMateIndex=g_lpdwDFlyMateIdx[dwIndex];
\par 
\par \tab \tab // set coordinate values
\par \tab \tab fX=g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41;
\par \tab \tab fY=g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42;
\par \tab \tab fZ=g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43;
\par 
\par \tab \tab // compare dragonfly position with other dragonflies
\par \tab \tab for(dwCount=0;dwCount<g_dwNumDFly;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // skip this dragonfly
\par \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // skip this dragonfly's mate
\par \tab \tab \tab \tab if(dwCount!=dwMateIndex)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwDFlyMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwDFlyMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab // save distance
\par \tab \tab \tab \tab \tab fDist=SquareMagnitudeXZ(&vV1);
\par 
\par \tab \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab \tab if(fDist<Squared(DFLY_SEPARATIONDISTANCE))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // compute inverse distance
\par \tab \tab \tab \tab \tab \tab float fInvDist=1.0F/sqrtf(fDist);
\par \tab \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab \tab vV2.x=vV1.x*fInvDist;
\par \tab \tab \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab \tab \tab vV2.z=vV1.z*fInvDist;
\par 
\par \tab \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41+=vV2.x*g_lpfDFlyNavSpeed[dwCount];
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43+=vV2.z*g_lpfDFlyNavSpeed[dwCount];
\par 
\par \tab \tab \tab \tab \tab \tab // stop this dragonfly if darting
\par \tab \tab \tab \tab \tab \tab if(g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_DART)
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par 
\par \tab \tab \tab \tab \tab \tab // stop other dragonfly if darting
\par \tab \tab \tab \tab \tab \tab if(g_lpdwDFlyNavState[dwCount]=NVST_DFLY_DART)
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwCount]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // compare dragonfly position with swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // set up vector
\par \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab // check distance
\par \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(DFLY_MINSWANDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check height
\par \tab \tab \tab \tab if(fY<DFLY_MINSWANHEIGHT)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to climb
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_CLIMB;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // compare dragonfly position with baby swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumBBSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // set up vector
\par \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab // check distance
\par \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(DFLY_MINBBSWANDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check height
\par \tab \tab \tab \tab if(fY<DFLY_MINBBSWANHEIGHT)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to climb
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_CLIMB;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // compare dragonfly position with turtles
\par \tab \tab for(dwCount=0;dwCount<g_dwNumTurtle;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // set up vector
\par \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwTurtleMtx[dwCount]].mtx._41;
\par \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwTurtleMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab // check distance
\par \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(DFLY_MINTURTLEDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check height
\par \tab \tab \tab \tab if(fY<DFLY_MINTURTLEHEIGHT)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to climb
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_CLIMB;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check for audio segment
\par \tab \tab if(g_bUseSFX)
\par \tab \tab \{
\par \tab \tab \tab if(g_lpdwDFlyBuzzIdx[dwIndex]!=NO_OBJECT)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set up vector from dragonfly to camera
\par \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_dwCamMtx].mtx._41;
\par \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_dwCamMtx].mtx._43;
\par 
\par \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(MAXDIST_BUZZ))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check sound effect
\par \tab \tab \tab \tab \tab if(IsAudioSegmentPlaying(g_lpdwDFlyBuzzIdx[dwIndex]))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set playback flag
\par \tab \tab \tab \tab \tab \tab g_lpbDFlyPlayback[dwIndex]=TRUE;
\par 
\par \tab \tab \tab \tab \tab \tab // get audiopath index
\par \tab \tab \tab \tab \tab \tab if(GetManagedAudioPathIndex(g_lpdwDFlyAPathID[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &dwPathIndex))
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check 3D sound flag
\par \tab \tab \tab \tab \tab \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // update position
\par \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathPosition(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  g_lpdwDFlyMtx[dwIndex]);
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set simulated 3D settings
\par \tab \tab \tab \tab \tab \tab \tab \tab SimulateAudioPath3D(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_dwCamMtx,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &g_vCamAhead,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MINDIST_BUZZ,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXDIST_BUZZ,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXVOL_BUZZ);
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // audiopath lost
\par \tab \tab \tab \tab \tab \tab \tab StopAudioSegment(g_lpdwDFlyBuzzIdx[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // reset audiopath id
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyAPathID[dwIndex]=NO_OBJECT;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check playback flag
\par \tab \tab \tab \tab \tab \tab if(g_lpbDFlyPlayback[dwIndex]!=FALSE)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check audiopath id
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpdwDFlyAPathID[dwIndex]!=NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // release audiopath
\par \tab \tab \tab \tab \tab \tab \tab \tab ReleaseManagedAudioPath(g_lpdwDFlyAPathID[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // reset audiopath id
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyAPathID[dwIndex]=NO_OBJECT;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab // check initial updates flag
\par \tab \tab \tab \tab \tab \tab \tab if(!g_bInitUpdates)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // capture audiopath
\par \tab \tab \tab \tab \tab \tab \tab \tab if(CaptureManagedAudioPath(&g_lpdwDFlyAPathID[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    SFXPRI_BUZZ))
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // get audiopath index
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab if(GetManagedAudioPathIndex(g_lpdwDFlyAPathID[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &dwPathIndex))
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // check 3D sound flag
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath minimum distance
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathMinDistance(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MINDIST_BUZZ);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath maximum distance
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathMaxDistance(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXDIST_BUZZ);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath max volume
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathVolume(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    MAXVOL_BUZZ);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath position
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathPosition(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  g_lpdwDFlyMtx[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // render audio changes
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab RenderAudioChanges();
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // set simulated 3D settings
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab SimulateAudioPath3D(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_dwCamMtx,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &g_vCamAhead,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MINDIST_BUZZ,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXDIST_BUZZ,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXVOL_BUZZ);
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // reset playback flag
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpbDFlyPlayback[dwIndex]=FALSE;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab // play segment
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab PlayAudioSegment(g_lpdwDFlyBuzzIdx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  dwPathIndex);
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check sound effect
\par \tab \tab \tab \tab \tab if(IsAudioSegmentPlaying(g_lpdwDFlyBuzzIdx[dwIndex]))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // stop segment
\par \tab \tab \tab \tab \tab \tab StopAudioSegment(g_lpdwDFlyBuzzIdx[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab \tab // release audiopath
\par \tab \tab \tab \tab \tab \tab ReleaseManagedAudioPath(g_lpdwDFlyAPathID[dwIndex]);
\par 
\par \tab \tab \tab \tab \tab \tab // reset audiopath id
\par \tab \tab \tab \tab \tab \tab g_lpdwDFlyAPathID[dwIndex]=NO_OBJECT;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check primary state
\par \tab \tab switch(g_lpdwDFlyPriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // lead
\par \tab \tab case(PRST_DFLY_LEAD):
\par \tab \tab \tab // get boundary flags
\par \tab \tab \tab bUpper=IsPointOutOfUpperBounds(fX,fZ);
\par \tab \tab \tab bLower=IsPointOutOfLowerBounds(fX,fZ);
\par \tab \tab \tab bCenter=IsPointOutOfCenterBounds(fX,fZ);
\par 
\par \tab \tab \tab // check boundaries
\par \tab \tab \tab if(bUpper||bLower||bCenter)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get vector from center of boundary to dragonfly
\par \tab \tab \tab \tab if(bUpper)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // center of upper boundary
\par \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab fZ-(TERRAIN_CENTERZ-TERRAIN_ZRANGE));
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(bLower)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // center of lower boundary
\par \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab fZ-(TERRAIN_CENTERZ+TERRAIN_ZRANGE));
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // center of center boundary
\par \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab fZ-TERRAIN_CENTERZ);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab Normalize(&vV1,&vV2);
\par 
\par \tab \tab \tab \tab // get perpendicular vector
\par \tab \tab \tab \tab vV2.x=vV1.z;
\par \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab vV2.z=-vV1.x;
\par 
\par \tab \tab \tab \tab // get dragonfly ahead vector
\par \tab \tab \tab \tab vV3=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._33);
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV2,&vV3)>0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_HARDRIGHT;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_HARDLEFT;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV1,&vV3)<0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]<(DFLY_MAXSPEED*0.25F))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]<(DFLY_MAXSPEED*0.25F))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwDFlyNavState[dwIndex]==NVST_DFLY_JUSTFLY)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%DFLY_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%DFLY_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%DFLY_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // check for mate
\par \tab \tab \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get dragonfly position
\par \tab \tab \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab \tab \tab // get mate position
\par \tab \tab \tab \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwMateIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwMateIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab \tab \tab // get distance to mate
\par \tab \tab \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab \tab \tab if(fDist>Squared(DFLY_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]>(DFLY_MAXSPEED*0.5F))
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // change primary state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%DFLY_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab RandomizeDragonflyPrimaryState(dwIndex);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // follow
\par \tab \tab case(PRST_DFLY_FOLLOW):
\par \tab \tab \tab // single dragonflies must be leaders
\par \tab \tab \tab if(dwMateIndex==NO_OBJECT)
\par \tab \tab \tab \tab g_lpdwDFlyPriState[dwIndex]=PRST_DFLY_LEAD;
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get dragonfly position
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get mate position
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwMateIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwMateIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get distance to mate
\par \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab if(fDist<Squared(DFLY_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab \tab if(fDist<Squared(DFLY_MINDFLYDISTANCE))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get vector from mate to dragonfly
\par \tab \tab \tab \tab \tab \tab vV3=vV1-vV2;
\par 
\par \tab \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab \tab Normalize(&vV1,&vV3);
\par 
\par \tab \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41+=vV1.x*g_lpfDFlyNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43+=vV1.z*g_lpfDFlyNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]>(g_lpfDFlyNavSpeed[dwMateIndex]*DFLY_TRACKINGSPEEDVAL)+DFLY_TRACKINGSPEEDINC)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else if(g_lpfDFlyNavSpeed[dwIndex]<(g_lpfDFlyNavSpeed[dwMateIndex]*DFLY_TRACKINGSPEEDVAL1)-DFLY_TRACKINGSPEEDINC1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpdwDFlyNavState[dwIndex]==NVST_DFLY_JUSTFLY)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%DFLY_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%DFLY_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%DFLY_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par   \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector from dragonfly to mate
\par \tab \tab \tab \tab \tab vV3=vV2-vV1;
\par 
\par \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab Normalize(&vV2,&vV3);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // get dragonfly ahead vector
\par \tab \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._33);
\par 
\par \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab if(DotProduct(&vV1,&vV2)>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par  
\par \tab \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab \tab if(DotProduct(&vV3,&vV2)>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab \tab // save tracking value
\par \tab \tab \tab \tab \tab \tab fTrackingVal=DotProduct(&vV3,&vV2);
\par 
\par \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab if(fabsf(fTrackingVal)>DFLY_FOLLOWTRACKINGVAL)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab \tab if(fTrackingVal>0)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]<((g_lpfDFlyNavSpeed[dwMateIndex]*DFLY_TRACKINGSPEEDVAL)+DFLY_TRACKINGSPEEDINC)-DFLY_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else if(g_lpfDFlyNavSpeed[dwIndex]>((g_lpfDFlyNavSpeed[dwMateIndex]*DFLY_TRACKINGSPEEDVAL)+DFLY_TRACKINGSPEEDINC)+DFLY_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab \tab \tab \tab if(fDist>Squared(DFLY_MAXFOLLOWDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]<((g_lpfDFlyNavSpeed[dwMateIndex]*DFLY_TRACKINGSPEEDVAL2)+DFLY_TRACKINGSPEEDINC2)-DFLY_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \tab else if(g_lpfDFlyNavSpeed[dwIndex]>((g_lpfDFlyNavSpeed[dwMateIndex]*DFLY_TRACKINGSPEEDVAL2)+DFLY_TRACKINGSPEEDINC2)+DFLY_SPEEDTOLERANCE)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // rest
\par \tab \tab case(PRST_DFLY_REST):
\par \tab \tab \tab // check for mate
\par \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get dragonfly position
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get mate position
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_lpdwDFlyMtx[dwMateIndex]].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwMateIndex]].mtx._43);
\par 
\par \tab \tab \tab \tab // get distance to mate
\par \tab \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab \tab // check distance to mate
\par \tab \tab \tab \tab if(fDist<Squared(DFLY_MINDFLYDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector from mate to dragonfly
\par \tab \tab \tab \tab \tab vV3=vV1-vV2;
\par 
\par \tab \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab \tab Normalize(&vV1,&vV3);
\par 
\par \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41+=vV1.x*g_lpfDFlyNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43+=vV1.z*g_lpfDFlyNavSpeed[dwMateIndex];
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(fDist>Squared(DFLY_MAXRESTDISTANCE))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set dragonfly to lead
\par \tab \tab \tab \tab \tab g_lpdwDFlyPriState[dwIndex]=PRST_DFLY_LEAD;
\par 
\par \tab \tab \tab \tab \tab // set mate to follow if necessary
\par \tab \tab \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab g_lpdwDFlyPriState[dwMateIndex]=PRST_DFLY_FOLLOW;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check boundaries
\par \tab \tab \tab if(IsPointOutOfBounds(fX,fZ))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set dragonfly to lead
\par \tab \tab \tab \tab g_lpdwDFlyPriState[dwIndex]=PRST_DFLY_LEAD;
\par 
\par \tab \tab \tab \tab // set mate to follow if necessary
\par \tab \tab \tab \tab if(dwMateIndex!=NO_OBJECT)
\par \tab \tab \tab \tab \tab g_lpdwDFlyPriState[dwMateIndex]=PRST_DFLY_FOLLOW;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]>DFLY_MAXRESTSPEED)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_lpdwDFlyNavState[dwIndex]==NVST_DFLY_JUSTFLY)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%DFLY_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%DFLY_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]=0;
\par \tab \tab \tab \tab \tab \tab \tab g_lpdwDFlyNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%DFLY_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // change primary state if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%DFLY_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab RandomizeDragonflyPrimaryState(dwIndex);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab if(g_lpdwDFlyNavState[dwIndex]!=NVST_DFLY_JUSTFLY)
\par \tab \tab \{
\par \tab \tab \tab // check navigation position
\par \tab \tab \tab if(g_lpdwDFlyNavPos[dwIndex]<g_lpdwDFlyNavMax[dwIndex])
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bNavFlag=TRUE;
\par 
\par \tab \tab \tab \tab // increment navigation position
\par \tab \tab \tab \tab g_lpdwDFlyNavPos[dwIndex]++;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset flag
\par \tab \tab \tab \tab bNavFlag=FALSE;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab switch(g_lpdwDFlyNavState[dwIndex])
\par \tab \tab \{
\par \tab \tab // speed up
\par \tab \tab case(NVST_DFLY_SPEEDUP):
\par \tab \tab \tab // increase speed
\par \tab \tab \tab g_lpfDFlyNavSpeed[dwIndex]+=DFLY_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]>DFLY_MAXSPEED)
\par \tab \tab \tab \tab g_lpfDFlyNavSpeed[dwIndex]=DFLY_MAXSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // slow down
\par \tab \tab case(NVST_DFLY_SLOWDOWN):
\par \tab \tab \tab // decrease speed
\par \tab \tab \tab g_lpfDFlyNavSpeed[dwIndex]-=DFLY_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfDFlyNavSpeed[dwIndex]<0)
\par \tab \tab \tab \tab g_lpfDFlyNavSpeed[dwIndex]=0;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn left
\par \tab \tab case(NVST_DFLY_TURNLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab   DFLY_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn right
\par \tab \tab case(NVST_DFLY_TURNRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -DFLY_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard left
\par \tab \tab case(NVST_DFLY_HARDLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab   DFLY_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard right
\par \tab \tab case(NVST_DFLY_HARDRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -DFLY_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // climb
\par \tab \tab case(NVST_DFLY_CLIMB):
\par \tab \tab \tab // increase height
\par \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42+=(g_lpfDFlyNavSpeed[dwIndex]*DFLY_HEIGHTINCFACTOR);
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42>DFLY_MAXHEIGHT)
\par \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42=DFLY_MAXHEIGHT;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // dive
\par \tab \tab case(NVST_DFLY_DIVE):
\par \tab \tab \tab // decrease height
\par \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42-=(g_lpfDFlyNavSpeed[dwIndex]*DFLY_HEIGHTINCFACTOR);
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42<DFLY_MINHEIGHT)
\par \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42=DFLY_MINHEIGHT;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // dart
\par \tab \tab case(NVST_DFLY_DART):
\par \tab \tab \tab // adjust position by dart vector
\par \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._41+=(g_lpvDFlyDartVec[dwIndex].x*DFLY_DARTINC);
\par \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42+=(g_lpvDFlyDartVec[dwIndex].y*DFLY_DARTINC);
\par \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._43+=(g_lpvDFlyDartVec[dwIndex].z*DFLY_DARTINC);
\par 
\par \tab \tab \tab // check height for overflow
\par \tab \tab \tab if(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42>DFLY_MAXHEIGHT)
\par \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42=DFLY_MAXHEIGHT;
\par \tab \tab \tab else if(g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42<DFLY_MINHEIGHT)
\par \tab \tab \tab \tab g_lpMtx[g_lpdwDFlyMtx[dwIndex]].mtx._42=DFLY_MINHEIGHT;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwDFlyNavState[dwIndex]=NVST_DFLY_JUSTFLY;
\par 
\par \tab \tab \tab \tab // set new dart vector
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(GetRandomFloat(),
\par \tab \tab \tab \tab \tab \tab \tab     GetRandomFloat(),
\par \tab \tab \tab \tab \tab \tab \tab     GetRandomFloat());
\par 
\par \tab \tab \tab \tab // normalize & store vector
\par \tab \tab \tab \tab Normalize(&g_lpvDFlyDartVec[dwIndex],
\par \tab \tab \tab \tab \tab \tab   &vV1);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // move dragonfly
\par \tab \tab MatrixBack(g_lpdwDFlyMtx[dwIndex],
\par \tab \tab \tab \tab    g_lpfDFlyNavSpeed[dwIndex]);
\par \tab \}
\par \}
\par 
\par #ifdef DEBUG_MODE
\par // CreateFishTextures()
\par 
\par BOOL CreateFishTextures(DWORD dwNumTex,
\par \tab \tab \tab \tab \tab \tab LPCSTR lpFileNameIn,
\par \tab \tab \tab \tab \tab \tab LPCSTR lpFileNameOut)
\par \{
\par \tab LoadingOutput("CreateFishTextures");
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par \tab 
\par \tab // create dds file for each texture
\par \tab for(dwCount=0;dwCount<dwNumTex;dwCount++)
\par \tab \{
\par \tab \tab // generate input filename
\par \tab \tab char lpSrcFile[16];
\par \tab \tab sprintf(lpSrcFile,
\par \tab \tab \tab \tab lpFileNameIn,
\par \tab \tab \tab \tab dwCount+1);
\par 
\par \tab \tab // generate output filename
\par \tab \tab char lpDestFile[16];
\par \tab \tab sprintf(lpDestFile,
\par \tab \tab \tab \tab lpFileNameOut,
\par \tab \tab \tab \tab dwCount+1);
\par 
\par \tab \tab // transfer image
\par \tab \tab CreateDDSFromImage(lpDestFile,
\par \tab \tab \tab \tab \tab \tab    lpSrcFile,
\par \tab \tab \tab \tab \tab \tab    TRUE,
\par \tab \tab \tab \tab \tab \tab    FISH_TRANSCOLOR);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par #endif
\par 
\par // AddFishTextures()
\par 
\par DWORD AddFishTextures(DWORD dwNumTex,
\par \tab \tab \tab \tab \tab   LPCSTR lpFileName)
\par \{
\par \tab LoadingOutput("AddFishTextures");
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par \tab 
\par \tab // texture index
\par \tab DWORD dwTexIndex=NO_OBJECT;
\par \tab 
\par \tab // add fish textures
\par \tab for(dwCount=0;dwCount<dwNumTex;dwCount++)
\par \tab \{
\par \tab \tab // generate filename
\par \tab \tab char lpDestFile[16];
\par \tab \tab sprintf(lpDestFile,
\par \tab \tab \tab \tab lpFileName,
\par \tab \tab \tab \tab dwCount+1);
\par 
\par \tab \tab // load image
\par \tab \tab DWORD dwIndex=AddTexture(lpDestFile);
\par 
\par \tab \tab // check for error
\par \tab \tab if(dwIndex==NO_OBJECT)
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // save first texture index
\par \tab \tab if(dwCount==0)
\par \tab \tab \tab dwTexIndex=dwIndex;
\par \tab \}
\par 
\par \tab // return index
\par \tab return(dwTexIndex);
\par \}
\par 
\par // GetNextFish()
\par 
\par DWORD GetNextFish(void)
\par \{
\par \tab LoadingOutput("GetNextFish");
\par 
\par \tab // check counter
\par \tab if(g_dwNumFish==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpvFishPos,
\par \tab \tab \tab \tab \tab  sizeof(D3DXVECTOR3)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfFishScale,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwFishPriState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwFishAnimFrame,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwFishRipple1Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwFishRipple2Idx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwFishAPathID,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwFishSplashIdx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpbFishPlayback,
\par \tab \tab \tab \tab \tab  sizeof(BOOL)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxFish=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumFish>=g_dwMaxFish)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpvFishPos,
\par \tab \tab \tab \tab \tab    sizeof(D3DXVECTOR3)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(D3DXVECTOR3)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfFishScale,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwFishPriState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwFishAnimFrame,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwFishRipple1Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwFishRipple2Idx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwFishAPathID,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwFishSplashIdx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpbFishPlayback,
\par \tab \tab \tab \tab \tab    sizeof(BOOL)*g_dwMaxFish,
\par \tab \tab \tab \tab \tab    sizeof(BOOL)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxFish+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumFish;
\par 
\par \tab // increment counter
\par \tab g_dwNumFish++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddFish()
\par 
\par DWORD AddFish(void)
\par \{
\par \tab LoadingOutput("AddFish");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextFish();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // set scale factor
\par \tab g_lpfFishScale[dwIndex]=FISH_SCALE+(GetRandomFloat()*FISH_SCALEVAR);
\par 
\par \tab // set default values
\par \tab g_lpvFishPos[dwIndex]=D3DXVECTOR3(0,0,0);
\par \tab g_lpdwFishPriState[dwIndex]=PRST_FISH_LURK;
\par \tab g_lpdwFishAnimFrame[dwIndex]=0;
\par \tab g_lpdwFishAPathID[dwIndex]=NO_OBJECT;
\par \tab g_lpdwFishSplashIdx[dwIndex]=NO_OBJECT;
\par \tab g_lpbFishPlayback[dwIndex]=TRUE;
\par 
\par \tab // add ripple #1
\par \tab g_lpdwFishRipple1Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #1
\par \tab if(g_lpdwFishRipple1Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add ripple #2
\par \tab g_lpdwFishRipple2Idx[dwIndex]=AddRipple();
\par 
\par \tab // check ripple #2
\par \tab if(g_lpdwFishRipple2Idx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // UpdateFish()
\par 
\par void UpdateFish(void)
\par \{
\par \tab // fish index
\par \tab DWORD dwIndex;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // comparison vector
\par \tab D3DXVECTOR3 vV1;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // camera distance
\par \tab float fCamDist;
\par 
\par \tab // allow state change flag
\par \tab BOOL bStateChangeOK;
\par 
\par \tab // audiopath index
\par \tab DWORD dwPathIndex;
\par 
\par \tab // update fish
\par \tab for(dwIndex=0;dwIndex<g_dwNumFish;dwIndex++)
\par \tab \{
\par \tab \tab // check primary state
\par \tab \tab switch(g_lpdwFishPriState[dwIndex])
\par \tab \tab \{
\par \tab \tab // lurk
\par \tab \tab case(PRST_FISH_LURK):
\par \tab \tab \tab // change state if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%FISH_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // create random position
\par \tab \tab \tab \tab fX=TERRAIN_CENTERX+(GetRandomFloat()*TERRAIN_XRANGE);
\par \tab \tab \tab \tab fZ=TERRAIN_CENTERZ+(GetRandomFloat()*(TERRAIN_ZRANGE+TERRAIN_XRANGE));
\par 
\par \tab \tab \tab \tab // reset state chanage flag
\par \tab \tab \tab \tab bStateChangeOK=TRUE;
\par 
\par \tab \tab \tab \tab // compare fish position with camera
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_dwCamMtx].mtx._41;
\par \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_dwCamMtx].mtx._43;
\par 
\par \tab \tab \tab \tab \tab // save camera distance
\par \tab \tab \tab \tab \tab fCamDist=SquareMagnitudeXZ(&vV1);
\par 
\par \tab \tab \tab \tab \tab // check distance & set flag if necessary
\par \tab \tab \tab \tab \tab if(fCamDist<Squared(FISH_MINCAMERADISTANCE))
\par \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // compare fish position with swans
\par \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab \tab // check distance & set flag if necessary
\par \tab \tab \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(FISH_MINSWANDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // compare fish position with baby swans
\par \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab \tab for(dwCount=0;dwCount<g_dwNumBBSwan;dwCount++)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwBBSwanMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab \tab // check distance & set flag if necessary
\par \tab \tab \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(FISH_MINBBSWANDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // compare fish position with turtles
\par \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab for(dwCount=0;dwCount<g_dwNumTurtle;dwCount++)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwTurtleMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwTurtleMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab \tab // check distance & set flag if necessary
\par \tab \tab \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(FISH_MINTURTLEDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // compare fish position with dragonflies
\par \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab for(dwCount=0;dwCount<g_dwNumDFly;dwCount++)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab \tab vV1.x=fX-g_lpMtx[g_lpdwDFlyMtx[dwCount]].mtx._41;
\par \tab \tab \tab \tab \tab \tab vV1.z=fZ-g_lpMtx[g_lpdwDFlyMtx[dwCount]].mtx._43;
\par 
\par \tab \tab \tab \tab \tab \tab // check distance & set flag if necessary
\par \tab \tab \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(FISH_MINDFLYDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // compare fish position with other fish
\par \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab \tab for(dwCount=0;dwCount<g_dwNumFish;dwCount++)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // skip this fish
\par \tab \tab \tab \tab \tab \tab if(dwCount!=dwIndex)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // skip lurking fish
\par \tab \tab \tab \tab \tab \tab \tab if(g_lpdwFishPriState[dwCount]!=PRST_FISH_LURK)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set up vector
\par \tab \tab \tab \tab \tab \tab \tab \tab vV1.x=fX-g_lpvFishPos[dwCount].x;
\par \tab \tab \tab \tab \tab \tab \tab \tab vV1.z=fZ-g_lpvFishPos[dwCount].z;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // check distance & set flag if necessary
\par \tab \tab \tab \tab \tab \tab \tab \tab if(SquareMagnitudeXZ(&vV1)<Squared(FISH_MINFISHDISTANCE))
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // check state of playback
\par \tab \tab \tab \tab if(g_bUseSFX)
\par \tab \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab \tab \tab if(g_lpbFishPlayback[dwIndex]==FALSE||
\par \tab \tab \tab \tab \tab \tab    IsAudioSegmentPlaying(g_lpdwFishSplashIdx[dwIndex]))
\par \tab \tab \tab \tab \tab \tab \tab bStateChangeOK=FALSE;
\par 
\par \tab \tab \tab \tab // check state change flag
\par \tab \tab \tab \tab if(bStateChangeOK)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].x=fX;
\par \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].z=fZ;
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // set state to jump as needed
\par \tab \tab \tab \tab \tab if((abs(GetRandomInt())%2)==1)
\par \tab \tab \tab \tab \tab \tab g_lpdwFishPriState[dwIndex]=PRST_FISH_JUMPL;
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab g_lpdwFishPriState[dwIndex]=PRST_FISH_JUMPR;
\par 
\par \tab \tab \tab \tab \tab // start ripple
\par \tab \tab \tab \tab \tab StartRipple(g_lpdwFishRipple1Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].x,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].z,
\par \tab \tab \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // jump
\par \tab \tab case(PRST_FISH_JUMPL):
\par \tab \tab case(PRST_FISH_JUMPR):
\par \tab \tab \tab // update animation frame
\par \tab \tab \tab g_lpdwFishAnimFrame[dwIndex]++;
\par 
\par \tab \tab \tab // check sound flag
\par \tab \tab \tab if(g_bUseSFX)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check current frame
\par \tab \tab \tab \tab if(g_lpdwFishAnimFrame[dwIndex]==(FISH_INITSPLASHTEX<<FISH_SLOWDOWN))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check distance to camera
\par \tab \tab \tab \tab \tab if(fCamDist<Squared(MAXDIST_SPLASH))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check initial updates flag
\par \tab \tab \tab \tab \tab \tab if(!g_bInitUpdates)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // capture audiopath
\par \tab \tab \tab \tab \tab \tab \tab if(CaptureManagedAudioPath(&g_lpdwFishAPathID[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    SFXPRI_SPLASH))
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // get audiopath index
\par \tab \tab \tab \tab \tab \tab \tab \tab GetManagedAudioPathIndex(g_lpdwFishAPathID[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  &dwPathIndex);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // check 3D sound flag
\par \tab \tab \tab \tab \tab \tab \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath minimum distance
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathMinDistance(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MINDIST_SPLASH);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath maximum distance
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathMaxDistance(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXDIST_SPLASH);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath max volume
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathVolume(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    MAXVOL_SPLASH);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath position
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathPosition(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  g_lpvFishPos[dwIndex].x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  g_lpvFishPos[dwIndex].y,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  g_lpvFishPos[dwIndex].z);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // render audio changes
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab RenderAudioChanges();
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab // set simulated 3D settings
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab SimulateAudioPath3D(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_dwCamMtx,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &g_vCamAhead,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].x,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].y,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].z,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MINDIST_SPLASH,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXDIST_SPLASH,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab MAXVOL_SPLASH);
\par \tab \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // reset playback flag
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpbFishPlayback[dwIndex]=FALSE;
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // play sound
\par \tab \tab \tab \tab \tab \tab \tab \tab PlayAudioSegment(g_lpdwFishSplashIdx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  dwPathIndex);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if((g_lpdwFishAnimFrame[dwIndex]>>FISH_SLOWDOWN)>=FISH_NUMTEX)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset animation frame
\par \tab \tab \tab \tab g_lpdwFishAnimFrame[dwIndex]=0;
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // set state to lurk
\par \tab \tab \tab \tab g_lpdwFishPriState[dwIndex]=PRST_FISH_LURK;
\par 
\par \tab \tab \tab \tab // start ripple
\par \tab \tab \tab \tab StartRipple(g_lpdwFishRipple2Idx[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].x,
\par \tab \tab \tab \tab \tab \tab \tab g_lpvFishPos[dwIndex].z,
\par \tab \tab \tab \tab \tab \tab \tab GetRandomRippleSpeed());
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // check sound flag
\par \tab \tab if(g_bUseSFX)
\par \tab \tab \{
\par \tab \tab \tab // check playback flag
\par \tab \tab \tab if(!g_lpbFishPlayback[dwIndex])
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check audio segment
\par \tab \tab \tab \tab if(IsAudioSegmentPlaying(g_lpdwFishSplashIdx[dwIndex]))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set playback flag
\par \tab \tab \tab \tab \tab g_lpbFishPlayback[dwIndex]=TRUE;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check audio segment
\par \tab \tab \tab \tab if(!IsAudioSegmentPlaying(g_lpdwFishSplashIdx[dwIndex]))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // release audiopath
\par \tab \tab \tab \tab \tab ReleaseManagedAudioPath(g_lpdwFishAPathID[dwIndex]);
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par \}
\par 
\par // RenderFish()
\par 
\par void RenderFish(void)
\par \{
\par \tab // fish index
\par \tab DWORD dwIndex;
\par 
\par \tab // render fish
\par \tab for(dwIndex=0;dwIndex<g_dwNumFish;dwIndex++)
\par \tab \{
\par \tab \tab // check primary state
\par \tab \tab if(g_lpdwFishPriState[dwIndex]==PRST_FISH_JUMPL)
\par \tab \tab \{
\par \tab \tab \tab // render left-hand fish
\par \tab \tab \tab RenderVerticalBillboard(NULL,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_dwFishTex+(g_lpdwFishAnimFrame[dwIndex]>>FISH_SLOWDOWN),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab &g_lpvFishPos[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpfFishScale[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab g_lpfFishScale[dwIndex]);
\par \tab \tab \}
\par \tab \tab else if(g_lpdwFishPriState[dwIndex]==PRST_FISH_JUMPR)
\par \tab \tab \{
\par \tab \tab \tab // render right-hand fish
\par \tab \tab \tab RenderReverseVerticalBillboard(NULL,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    g_dwFishTex+(g_lpdwFishAnimFrame[dwIndex]>>FISH_SLOWDOWN),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    &g_lpvFishPos[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    g_lpfFishScale[dwIndex],
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    g_lpfFishScale[dwIndex]);
\par \tab \tab \}
\par \tab \}
\par \}
\par 
\par // PurgeFish()
\par 
\par void PurgeFish(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpvFishPos);
\par \tab FreeMem((LPVOID*)&g_lpfFishScale);
\par \tab FreeMem((LPVOID*)&g_lpdwFishPriState);
\par \tab FreeMem((LPVOID*)&g_lpdwFishAnimFrame);
\par \tab FreeMem((LPVOID*)&g_lpdwFishRipple1Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwFishRipple2Idx);
\par \tab FreeMem((LPVOID*)&g_lpdwFishAPathID);
\par \tab FreeMem((LPVOID*)&g_lpdwFishSplashIdx);
\par \tab FreeMem((LPVOID*)&g_lpbFishPlayback);
\par 
\par \tab // reset counters
\par \tab g_dwNumFish=0;
\par \tab g_dwMaxFish=0;
\par \}
\par 
\par // GetNextBird()
\par 
\par DWORD GetNextBird(void)
\par \{
\par \tab LoadingOutput("GetNextBird");
\par 
\par \tab // check counter
\par \tab if(g_dwNumBird==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBirdMtx,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBirdWingPos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBirdWingDir,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBirdNavState,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBirdNavSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBirdNavPos,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBirdNavMax,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBirdKeyframe1,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpdwBirdKeyframe2,
\par \tab \tab \tab \tab \tab  sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfBirdTweenVal,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxBird=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumBird>=g_dwMaxBird)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBirdMtx,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBirdWingPos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBirdWingDir,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBirdNavState,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBirdNavSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBirdNavPos,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBirdNavMax,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBirdKeyframe1,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpdwBirdKeyframe2,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(DWORD)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfBirdTweenVal,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxBird,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxBird+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumBird;
\par 
\par \tab // increment counter
\par \tab g_dwNumBird++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddBird()
\par 
\par DWORD AddBird(void)
\par \{
\par \tab LoadingOutput("AddBird");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextBird();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // add bird matrix
\par \tab g_lpdwBirdMtx[dwIndex]=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_lpdwBirdMtx[dwIndex]==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // set random position
\par \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._41=GetRandomFloat()*WSURF_RAD;
\par \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._43=GetRandomFloat()*WSURF_RAD;
\par 
\par \tab // set altitude as needed
\par \tab if(dwIndex==0)
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42=BIRD_BASEALTITUDE;
\par \tab else
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42=g_lpMtx[g_lpdwBirdMtx[dwIndex-1]].mtx._42+BIRD_ALTITUDEINC;
\par 
\par \tab // scale matrix by bird scale
\par \tab MatrixScale(g_lpdwBirdMtx[dwIndex],
\par \tab \tab \tab \tab BIRD_SCALE+(GetRandomFloat()*BIRD_SCALEVAR));
\par 
\par \tab // set default values
\par \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab g_lpfBirdWingPos[dwIndex]=0.0F;
\par \tab g_lpfBirdWingDir[dwIndex]=BIRD_WINGSPEED;
\par \tab g_lpfBirdNavSpeed[dwIndex]=BIRD_MINSPEED;
\par \tab g_lpdwBirdNavPos[dwIndex]=0;
\par \tab g_lpdwBirdNavMax[dwIndex]=0;
\par \tab g_lpdwBirdKeyframe1[dwIndex]=KEYF_BIRD_WD;
\par \tab g_lpdwBirdKeyframe2[dwIndex]=KEYF_BIRD_WU;
\par \tab g_lpfBirdTweenVal[dwIndex]=0.0F;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // UpdateBirds()
\par 
\par void UpdateBirds(void)
\par \{
\par \tab // bird index
\par \tab DWORD dwIndex;
\par 
\par \tab // navigation update flag
\par \tab BOOL bNavFlag;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // update birds
\par \tab for(dwIndex=0;dwIndex<g_dwNumBird;dwIndex++)
\par \tab \{
\par \tab \tab // set coordinate values
\par \tab \tab fX=g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._41;
\par \tab \tab fZ=g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._43;
\par 
\par \tab \tab // check boundaries
\par \tab \tab if(SquareMagnitudeXZ(fX,fZ)>Squared(WSURF_RAD*1.5F))
\par \tab \tab \{
\par \tab \tab \tab // set state to hard left
\par \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_HARDLEFT;
\par 
\par \tab \tab \tab // set navigation values
\par \tab \tab \tab g_lpdwBirdNavPos[dwIndex]=0;
\par \tab \tab \tab g_lpdwBirdNavMax[dwIndex]=2;
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab if(g_lpdwBirdNavState[dwIndex]==NVST_BIRD_JUSTFLY)
\par \tab \tab \{
\par \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab if((abs(GetRandomInt())%BIRD_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=(DWORD)(abs(GetRandomInt())%BIRD_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab g_lpdwBirdNavPos[dwIndex]=0;
\par \tab \tab \tab \tab g_lpdwBirdNavMax[dwIndex]=(DWORD)((abs(GetRandomInt())%BIRD_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab if(g_lpdwBirdNavState[dwIndex]!=NVST_BIRD_JUSTFLY)
\par \tab \tab \{
\par \tab \tab \tab // check navigation position
\par \tab \tab \tab if(g_lpdwBirdNavPos[dwIndex]<g_lpdwBirdNavMax[dwIndex])
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bNavFlag=TRUE;
\par 
\par \tab \tab \tab \tab // increment navigation position
\par \tab \tab \tab \tab g_lpdwBirdNavPos[dwIndex]++;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset flag
\par \tab \tab \tab \tab bNavFlag=FALSE;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // check navigation state
\par \tab \tab switch(g_lpdwBirdNavState[dwIndex])
\par \tab \tab \{
\par \tab \tab // speed up
\par \tab \tab case(NVST_BIRD_SPEEDUP):
\par \tab \tab \tab // increase speed
\par \tab \tab \tab g_lpfBirdNavSpeed[dwIndex]+=BIRD_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfBirdNavSpeed[dwIndex]>BIRD_MAXSPEED)
\par \tab \tab \tab \tab g_lpfBirdNavSpeed[dwIndex]=BIRD_MAXSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // slow down
\par \tab \tab case(NVST_BIRD_SLOWDOWN):
\par \tab \tab \tab // decrease speed
\par \tab \tab \tab g_lpfBirdNavSpeed[dwIndex]-=BIRD_SPEEDINC;
\par 
\par \tab \tab \tab // check for overflow
\par \tab \tab \tab if(g_lpfBirdNavSpeed[dwIndex]<BIRD_MINSPEED)
\par \tab \tab \tab \tab g_lpfBirdNavSpeed[dwIndex]=BIRD_MINSPEED;
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn left
\par \tab \tab case(NVST_BIRD_TURNLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwBirdMtx[dwIndex],
\par \tab \tab \tab \tab \tab   BIRD_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // turn right
\par \tab \tab case(NVST_BIRD_TURNRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwBirdMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -BIRD_TURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard left
\par \tab \tab case(NVST_BIRD_HARDLEFT):
\par \tab \tab \tab // turn left
\par \tab \tab \tab MatrixYaw(g_lpdwBirdMtx[dwIndex],
\par \tab \tab \tab \tab \tab   BIRD_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // hard right
\par \tab \tab case(NVST_BIRD_HARDRIGHT):
\par \tab \tab \tab // turn right
\par \tab \tab \tab MatrixYaw(g_lpdwBirdMtx[dwIndex],
\par \tab \tab \tab \tab \tab   -BIRD_HARDTURNINC);
\par 
\par \tab \tab \tab // check navigation flag
\par \tab \tab \tab if(!bNavFlag)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to fly
\par \tab \tab \tab \tab g_lpdwBirdNavState[dwIndex]=NVST_BIRD_JUSTFLY;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // move bird
\par \tab \tab MatrixAhead(g_lpdwBirdMtx[dwIndex],
\par \tab \tab \tab \tab     g_lpfBirdNavSpeed[dwIndex]);
\par 
\par \tab \tab // update wings
\par \tab \tab g_lpfBirdWingPos[dwIndex]+=g_lpfBirdWingDir[dwIndex]*g_lpfBirdNavSpeed[dwIndex];
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_lpfBirdWingPos[dwIndex]>=BIRD_MAXWINGPOS)
\par \tab \tab \{
\par \tab \tab \tab // clip position
\par \tab \tab \tab g_lpfBirdWingPos[dwIndex]=BIRD_MAXWINGPOS;
\par 
\par \tab \tab \tab // reverse direction
\par \tab \tab \tab g_lpfBirdWingDir[dwIndex]=-g_lpfBirdWingDir[dwIndex];
\par \tab \tab \}
\par \tab \tab else if(g_lpfBirdWingPos[dwIndex]<=-1.0F)
\par \tab \tab \{
\par \tab \tab \tab // clip position
\par \tab \tab \tab g_lpfBirdWingPos[dwIndex]=-1.0F;
\par 
\par \tab \tab \tab // reverse direction
\par \tab \tab \tab g_lpfBirdWingDir[dwIndex]=-g_lpfBirdWingDir[dwIndex];
\par \tab \tab \}
\par 
\par \tab \tab // set tween value
\par \tab \tab if(g_lpfBirdWingPos[dwIndex]>1.0F)
\par \tab \tab \tab g_lpfBirdTweenVal[dwIndex]=1;
\par \tab \tab else
\par \tab \tab \tab g_lpfBirdTweenVal[dwIndex]=GetNaturalizedTweenValue((g_lpfBirdWingPos[dwIndex]+1.0F)*0.5F);
\par \tab \}
\par \}
\par 
\par // RenderBirds()
\par 
\par void RenderBirds(void)
\par \{
\par \tab // bird index
\par \tab DWORD dwIndex;
\par 
\par #ifndef REFLECTION_OPTIMIZATION
\par \tab // render birds
\par \tab for(dwIndex=0;dwIndex<g_dwNumBird;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwBirdKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwBirdKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfBirdTweenVal[dwIndex]);
\par 
\par \tab \tab // render bird
\par \tab \tab RenderAnimation(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBirdMtx[dwIndex]);
\par \tab \}
\par 
\par \tab // enable frontface cull
\par \tab EnableFrontfaceCull();
\par \tab 
\par \tab // render bird reflections
\par \tab for(dwIndex=0;dwIndex<g_dwNumBird;dwIndex++)
\par \tab \{
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale;
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42;
\par 
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwBirdKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwBirdKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfBirdTweenVal[dwIndex]);
\par \tab \tab 
\par \tab \tab // render bird
\par \tab \tab RenderAnimation(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBirdMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale;
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42;
\par \tab \}
\par \tab 
\par \tab // enable backface cull
\par \tab EnableBackfaceCull();
\par #else
\par \tab // render birds
\par \tab for(dwIndex=0;dwIndex<g_dwNumBird;dwIndex++)
\par \tab \{
\par \tab \tab // set keyframe
\par \tab \tab UpdateRenderFrames(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab    g_lpdwBirdKeyframe1[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpdwBirdKeyframe2[dwIndex],
\par \tab \tab \tab \tab \tab \tab    g_lpfBirdTweenVal[dwIndex]);
\par 
\par \tab \tab // render bird
\par \tab \tab RenderAnimation(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBirdMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // enable frontface cull
\par \tab \tab EnableFrontfaceCull();
\par \tab 
\par \tab \tab // invert y-axis
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale;
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42;
\par 
\par \tab \tab // render bird
\par \tab \tab RenderAnimation(g_dwBirdAnim,
\par \tab \tab \tab \tab \tab \tab g_lpdwBirdMtx[dwIndex]);
\par \tab \tab 
\par \tab \tab // reset y-axis
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].fYScale;
\par \tab \tab g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42=-g_lpMtx[g_lpdwBirdMtx[dwIndex]].mtx._42;
\par \tab 
\par \tab \tab // enable backface cull
\par \tab \tab EnableBackfaceCull();
\par \tab \}
\par #endif
\par \}
\par 
\par // PurgeBirds()
\par 
\par void PurgeBirds(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpdwBirdMtx);
\par \tab FreeMem((LPVOID*)&g_lpfBirdWingPos);
\par \tab FreeMem((LPVOID*)&g_lpfBirdWingDir);
\par \tab FreeMem((LPVOID*)&g_lpdwBirdNavState);
\par \tab FreeMem((LPVOID*)&g_lpfBirdNavSpeed);
\par \tab FreeMem((LPVOID*)&g_lpdwBirdNavPos);
\par \tab FreeMem((LPVOID*)&g_lpdwBirdNavMax);
\par \tab FreeMem((LPVOID*)&g_lpdwBirdKeyframe1);
\par \tab FreeMem((LPVOID*)&g_lpdwBirdKeyframe2);
\par \tab FreeMem((LPVOID*)&g_lpfBirdTweenVal);
\par 
\par \tab // reset counters
\par \tab g_dwNumBird=0;
\par \tab g_dwMaxBird=0;
\par \}
\par 
\par #ifdef DEBUG_MODE
\par // CreateLensFlareTextures()
\par 
\par BOOL CreateLensFlareTextures(void)
\par \{
\par \tab LoadingOutput("CreateLensFlareTextures");
\par 
\par \tab // flare info
\par \tab LF_MAINFLAREINFO mfi;
\par \tab LF_FLARERINGINFO fri;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // filename
\par \tab char lpFilename[16];
\par \tab 
\par \tab // prepare main flare structure
\par \tab mfi.dwFlareType=LF_MAINFLARE;
\par \tab mfi.dwTexSize=128;
\par \tab mfi.fGlowDia=0.8F;
\par \tab mfi.cGlowClr1=D3DCOLOR_RGBA(255,255,255,255);
\par \tab mfi.cGlowClr2=D3DCOLOR_RGBA(255,192,0,0);
\par \tab mfi.fGlowFalloff=1.0F;
\par \tab mfi.fRingDia1=0.60F;
\par \tab mfi.fRingDia2=0.70F;
\par \tab mfi.cRingClr1=D3DCOLOR_RGBA(255,255,255,48);
\par \tab mfi.cRingClr2=D3DCOLOR_RGBA(255,192,0,0);
\par \tab mfi.fRingFalloff=1.0F;
\par \tab mfi.fStreakDia=1.4F;
\par \tab mfi.fStreakWidth=0.04F;
\par \tab mfi.cStreakClr1=D3DCOLOR_RGBA(255,255,255,96);
\par \tab mfi.cStreakClr2=D3DCOLOR_RGBA(255,192,0,0);
\par \tab mfi.fStreakFalloff=1.0F;
\par \tab mfi.fMaxRayDia=1.2F;
\par \tab mfi.fMaxRayWidth=0.03F;
\par \tab mfi.dwNumRays=8;
\par \tab mfi.cRayClr1=D3DCOLOR_RGBA(255,255,255,64);
\par \tab mfi.cRayClr2=D3DCOLOR_RGBA(255,192,0,0);
\par \tab mfi.fRayFalloff=1.0F;
\par 
\par \tab // add main flare
\par \tab CreateLensFlareDDS("flare0.dds",
\par \tab \tab \tab \tab \tab    (LPVOID)&mfi);
\par 
\par \tab // add flare rings
\par \tab for(dwCount=0;dwCount<NUM_FLARERINGS;dwCount++)
\par \tab \{
\par \tab \tab // create random color
\par \tab \tab float fR=fabsf(GetRandomFloat());
\par \tab \tab float fG=fabsf(GetRandomFloat());
\par \tab \tab float fB=fabsf(GetRandomFloat());
\par \tab \tab 
\par \tab \tab // prepare flare ring structure
\par \tab \tab fri.dwFlareType=LF_FLARERING;
\par \tab \tab fri.dwTexSize=64;
\par \tab \tab fri.fRingDia2=0.9F;
\par \tab \tab fri.fRingDia1=fri.fRingDia2*fabsf(GetRandomFloat());
\par \tab \tab fri.cRingClr1=D3DCOLOR_COLORVALUE(fR,fG,fB,0.075F);
\par \tab \tab fri.cRingClr2=D3DCOLOR_COLORVALUE(fR,fG,fB,0.0F);
\par \tab \tab fri.fRingFalloff=1.0F;
\par 
\par \tab \tab // create filename
\par \tab \tab sprintf(lpFilename,
\par \tab \tab \tab     "flare%d.dds",
\par \tab \tab \tab \tab dwCount+1);
\par 
\par \tab \tab // add flare ring
\par \tab \tab CreateLensFlareDDS(lpFilename,
\par \tab \tab \tab \tab \tab \tab    (LPVOID)&fri);
\par \tab \}
\par \tab 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // CreateRippleTextures()
\par 
\par BOOL CreateRippleTextures(void)
\par \{
\par \tab LoadingOutput("CreateRippleTextures");
\par 
\par \tab // flare info (to be used as ripple texture)
\par \tab LF_FLARERINGINFO fri;
\par \tab 
\par \tab // prepare flare ring structure
\par \tab fri.dwFlareType=LF_FLARERING;
\par \tab fri.dwTexSize=128;
\par \tab fri.fRingDia1=0.65F;
\par \tab fri.fRingDia2=0.95F;
\par \tab fri.cRingClr2=D3DCOLOR_COLORVALUE(0.26F,0.26F,0.71F,0);
\par \tab fri.fRingFalloff=1.0F;
\par 
\par \tab // create texture #1
\par \tab fri.cRingClr1=D3DCOLOR_COLORVALUE(1,1,1,0.4F);
\par \tab CreateLensFlareDDS("ripple0.dds",
\par \tab \tab \tab \tab \tab    (LPVOID)&fri);
\par \tab 
\par \tab // create texture #2
\par \tab fri.cRingClr1=D3DCOLOR_COLORVALUE(1,1,1,0.3F);
\par \tab CreateLensFlareDDS("ripple1.dds",
\par \tab \tab \tab \tab \tab    (LPVOID)&fri);
\par \tab 
\par \tab // create texture #3
\par \tab fri.cRingClr1=D3DCOLOR_COLORVALUE(1,1,1,0.2F);
\par \tab CreateLensFlareDDS("ripple2.dds",
\par \tab \tab \tab \tab \tab    (LPVOID)&fri);
\par \tab 
\par \tab // create texture #4
\par \tab fri.cRingClr1=D3DCOLOR_COLORVALUE(1,1,1,0.1F);
\par \tab CreateLensFlareDDS("ripple3.dds",
\par \tab \tab \tab \tab \tab    (LPVOID)&fri);
\par \tab 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par #endif
\par 
\par // AddRippleVertexBuffer()
\par 
\par DWORD AddRippleVertexBuffer(void)
\par \{
\par \tab LoadingOutput("AddRippleVertexBuffer");
\par 
\par \tab // ripple vertex data
\par \tab LPRIPPLEVERTEX lpRippleVtx;
\par \tab 
\par \tab // create ripple vertex buffer
\par \tab DWORD dwVtxBuf=AddVertexBuffer(D3DFVF_RIPPLEVERTEX,
\par \tab \tab \tab \tab \tab \tab \tab \tab    sizeof(RIPPLEVERTEX),
\par \tab \tab \tab \tab \tab \tab \tab \tab    4);
\par 
\par \tab // check vertex buffer
\par \tab if(dwVtxBuf==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // lock ripple vertex buffer
\par \tab lpRippleVtx=(LPRIPPLEVERTEX)LockVertexBuffer(dwVtxBuf);
\par \tab 
\par \tab // check for error
\par \tab if(!lpRippleVtx)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // fill in vertices
\par \tab SET_RIPPLEVERTEX(lpRippleVtx[0],
\par \tab \tab \tab \tab \tab  -0.5F,0,-0.5F,
\par \tab \tab \tab \tab \tab  0,0);
\par \tab SET_RIPPLEVERTEX(lpRippleVtx[1],
\par \tab \tab \tab \tab \tab  0.5F,0,-0.5F,
\par \tab \tab \tab \tab \tab  1,0);
\par \tab SET_RIPPLEVERTEX(lpRippleVtx[2],
\par \tab \tab \tab \tab \tab  -0.5F,0,0.5F,
\par \tab \tab \tab \tab \tab  0,1);
\par \tab SET_RIPPLEVERTEX(lpRippleVtx[3],
\par \tab \tab \tab \tab \tab  0.5F,0,0.5F,
\par \tab \tab \tab \tab \tab  1,1);
\par 
\par \tab // unlock vertex buffer
\par \tab UnlockVertexBuffer(dwVtxBuf);
\par 
\par \tab // return index
\par \tab return(dwVtxBuf);
\par \}
\par 
\par // AddRippleIndexBuffer()
\par 
\par DWORD AddRippleIndexBuffer(void)
\par \{
\par \tab LoadingOutput("AddRippleIndexBuffer");
\par 
\par \tab // ripple index data
\par \tab LPWORD lpwRippleIdx;
\par \tab 
\par \tab // create ripple index buffer
\par \tab DWORD dwIdxBuf=AddIndexBuffer(D3DPT_TRIANGLESTRIP,
\par \tab \tab \tab \tab \tab \tab \tab \tab   2);
\par 
\par \tab // check index buffer
\par \tab if(dwIdxBuf==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // lock ripple index buffer
\par \tab lpwRippleIdx=(LPWORD)LockIndexBuffer(dwIdxBuf);
\par \tab 
\par \tab // check for error
\par \tab if(!lpwRippleIdx)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // fill in indices
\par \tab lpwRippleIdx[0]=0;
\par \tab lpwRippleIdx[1]=2;
\par \tab lpwRippleIdx[2]=1;
\par \tab lpwRippleIdx[3]=3;
\par 
\par \tab // unlock index buffer
\par \tab UnlockIndexBuffer(dwIdxBuf);
\par 
\par \tab // return index
\par \tab return(dwIdxBuf);
\par \}
\par 
\par // InitRipples
\par 
\par BOOL InitRipples(void)
\par \{
\par \tab LoadingOutput("InitRipples");
\par 
\par \tab // add ripple vertex buffer
\par \tab g_dwRippleVtxBuf=AddRippleVertexBuffer();
\par 
\par \tab // check vertex buffer
\par \tab if(g_dwRippleVtxBuf==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add ripple index buffer
\par \tab g_dwRippleIdxBuf=AddRippleIndexBuffer();
\par 
\par \tab // check index buffer
\par \tab if(g_dwRippleIdxBuf==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add ripple material
\par \tab g_dwRippleMat=AddMaterial(0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab   0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab   0,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab   1,1,1,1,
\par \tab \tab \tab \tab \tab \tab \tab   0);
\par 
\par \tab // check material
\par \tab if(g_dwRippleMat==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add ripple texture #0
\par \tab g_lpdwRippleTex[0]=AddTexture("ripple0.dds");
\par 
\par \tab // check texture #0
\par \tab if(g_lpdwRippleTex[0]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par \tab 
\par \tab // add ripple texture #1
\par \tab g_lpdwRippleTex[1]=AddTexture("ripple1.dds");
\par 
\par \tab // check texture #1
\par \tab if(g_lpdwRippleTex[1]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par \tab 
\par \tab // add ripple texture #2
\par \tab g_lpdwRippleTex[2]=AddTexture("ripple2.dds");
\par 
\par \tab // check texture #2
\par \tab if(g_lpdwRippleTex[2]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par \tab 
\par \tab // add ripple texture #3
\par \tab g_lpdwRippleTex[3]=AddTexture("ripple3.dds");
\par 
\par \tab // check texture #3
\par \tab if(g_lpdwRippleTex[3]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par \tab 
\par \tab // add ripple matrix
\par \tab g_dwRippleMtx=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_dwRippleMtx==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // GetNextRipple()
\par 
\par DWORD GetNextRipple(void)
\par \{
\par \tab LoadingOutput("GetNextRipple");
\par 
\par \tab // check counter
\par \tab if(g_dwNumRipple==0)
\par \tab \{
\par \tab \tab // allocate memory
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfRippleX,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfRippleZ,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfRipplePos,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!AllocMem((LPVOID*)&g_lpfRippleSpeed,
\par \tab \tab \tab \tab \tab  sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxRipple=BLOCK_ALLOC_INC;
\par \tab \}
\par \tab else if(g_dwNumRipple>=g_dwMaxRipple)
\par \tab \{
\par \tab \tab // expand memory
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfRippleX,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxRipple,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfRippleZ,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxRipple,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfRipplePos,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxRipple,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par \tab \tab if(!ExpandMem((LPVOID*)&g_lpfRippleSpeed,
\par \tab \tab \tab \tab \tab    sizeof(float)*g_dwMaxRipple,
\par \tab \tab \tab \tab \tab    sizeof(float)*BLOCK_ALLOC_INC))
\par \tab \tab \tab return(NO_OBJECT);
\par 
\par \tab \tab // increment counter
\par \tab \tab g_dwMaxRipple+=BLOCK_ALLOC_INC;
\par \tab \}
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=g_dwNumRipple;
\par 
\par \tab // increment counter
\par \tab g_dwNumRipple++;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // AddRipple()
\par 
\par DWORD AddRipple(void)
\par \{
\par \tab LoadingOutput("AddRipple");
\par 
\par \tab // get return index
\par \tab DWORD dwIndex=GetNextRipple();
\par 
\par \tab // check index
\par \tab if(dwIndex==NO_OBJECT)
\par \tab \tab return(NO_OBJECT);
\par 
\par \tab // init data
\par \tab g_lpfRippleX[dwIndex]=0;
\par \tab g_lpfRippleZ[dwIndex]=0;
\par \tab g_lpfRipplePos[dwIndex]=1;
\par \tab g_lpfRippleSpeed[dwIndex]=1;
\par 
\par \tab // return index
\par \tab return(dwIndex);
\par \}
\par 
\par // StartRipple()
\par 
\par void StartRipple(DWORD dwIndex,
\par \tab \tab \tab \tab  float fX,
\par \tab \tab \tab \tab  float fZ,
\par \tab \tab \tab \tab  float fSpeed)
\par \{
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwIndex>=g_dwNumRipple)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid ripple index.",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "StartRipple()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \tab return;
\par \tab \}
\par #endif
\par 
\par \tab // copy data
\par \tab g_lpfRippleX[dwIndex]=fX;
\par \tab g_lpfRippleZ[dwIndex]=fZ;
\par \tab g_lpfRipplePos[dwIndex]=0;
\par \tab g_lpfRippleSpeed[dwIndex]=fSpeed;
\par \}
\par 
\par // IsRippleComplete()
\par 
\par BOOL IsRippleComplete(DWORD dwIndex)
\par \{
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwIndex>=g_dwNumRipple)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid ripple index.",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "IsRippleComplete()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \tab return(TRUE);
\par \tab \}
\par #endif
\par 
\par \tab // check ripple position
\par \tab if(g_lpfRipplePos[dwIndex]>=1)
\par \tab \tab return(TRUE);
\par \tab else
\par \tab \tab return(FALSE);
\par \}
\par 
\par // UpdateRipples()
\par 
\par void UpdateRipples(void)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // update ripples
\par \tab for(dwCount=0;dwCount<g_dwNumRipple;dwCount++)
\par \tab \{
\par \tab \tab // update position
\par \tab \tab g_lpfRipplePos[dwCount]+=g_lpfRippleSpeed[dwCount];
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_lpfRipplePos[dwCount]>1)
\par \tab \tab \tab g_lpfRipplePos[dwCount]=1;
\par \tab \}
\par \}
\par 
\par // RenderRipples()
\par 
\par void RenderRipples(void)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // disable z-buffer writes
\par \tab DisableZBufferWrites();
\par \tab 
\par \tab // set render parameters
\par \tab SetVertexBuffer(g_dwRippleVtxBuf);
\par \tab SetIndexBuffer(g_dwRippleIdxBuf);
\par \tab SetMaterial(g_dwRippleMat);
\par \tab 
\par \tab // render ripples
\par \tab for(dwCount=0;dwCount<g_dwNumRipple;dwCount++)
\par \tab \{
\par \tab \tab // check ripple position
\par \tab \tab if(g_lpfRipplePos[dwCount]<1.0F)
\par \tab \tab \{\tab \tab 
\par \tab \tab \tab // compute ripple scale
\par \tab \tab \tab float fRippleScale=Squared(g_lpfRipplePos[dwCount])*MAX_RIPPLEDIA;
\par 
\par \tab \tab \tab // update ripple matrix
\par \tab \tab \tab g_lpMtx[g_dwRippleMtx].mtx._41=g_lpfRippleX[dwCount];
\par \tab \tab \tab g_lpMtx[g_dwRippleMtx].mtx._43=g_lpfRippleZ[dwCount];
\par \tab \tab \tab g_lpMtx[g_dwRippleMtx].fXScale=fRippleScale;
\par \tab \tab \tab g_lpMtx[g_dwRippleMtx].fZScale=fRippleScale;
\par 
\par \tab \tab \tab // set world matrix
\par \tab \tab \tab SetWorldMatrix(g_dwRippleMtx);
\par 
\par \tab \tab \tab // set texture
\par \tab \tab \tab if(g_lpfRipplePos[dwCount]<=0.25F)
\par \tab \tab \tab \tab SetTexture(g_lpdwRippleTex[0]);
\par \tab \tab \tab else if(g_lpfRipplePos[dwCount]<=0.5F)
\par \tab \tab \tab \tab SetTexture(g_lpdwRippleTex[1]);
\par \tab \tab \tab else if(g_lpfRipplePos[dwCount]<=0.75F)
\par \tab \tab \tab \tab SetTexture(g_lpdwRippleTex[2]);
\par \tab \tab \tab else
\par \tab \tab \tab \tab SetTexture(g_lpdwRippleTex[3]);
\par 
\par \tab \tab \tab // render ripple
\par \tab \tab \tab RenderPrimitive();
\par \tab \tab \}
\par \tab \}
\par \tab 
\par \tab // enable z-buffer writes
\par \tab EnableZBufferWrites();
\par \}
\par 
\par // PurgeRipples()
\par 
\par void PurgeRipples(void)
\par \{
\par \tab // free memory
\par \tab FreeMem((LPVOID*)&g_lpfRippleX);
\par \tab FreeMem((LPVOID*)&g_lpfRippleZ);
\par \tab FreeMem((LPVOID*)&g_lpfRipplePos);
\par \tab FreeMem((LPVOID*)&g_lpfRippleSpeed);
\par 
\par \tab // reset counters
\par \tab g_dwNumRipple=0;
\par \tab g_dwMaxRipple=0;
\par \}
\par 
\par // GetRandomRippleSpeed()
\par 
\par float GetRandomRippleSpeed(void)
\par \{
\par \tab // compute speed
\par \tab float fVal=MIN_RIPPLESPEED+((MAX_RIPPLESPEED-MIN_RIPPLESPEED)*fabsf(GetRandomFloat()));
\par 
\par \tab // return value
\par \tab return(fVal);
\par \}
\par 
\par // InitCameraObject()
\par 
\par BOOL InitCameraObject(void)
\par \{
\par \tab LoadingOutput("InitCameraObject");
\par 
\par \tab // add camera matrix
\par \tab g_dwCamMtx=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_dwCamMtx==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // add camera output matrix
\par \tab g_dwCamOutputMtx=AddMatrix();
\par 
\par \tab // check matrix
\par \tab if(g_dwCamOutputMtx==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // move camera up
\par \tab MatrixUp(g_dwCamMtx,(CAMERA_MINHEIGHT+CAMERA_MAXHEIGHT)*0.5F);
\par 
\par \tab // init camera values
\par \tab g_dwCamPriState=PRST_CAMERA_FOLLOW;
\par \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab g_fCamNavSpeed=0.0F;
\par \tab g_dwCamNavPos=0;
\par \tab g_dwCamNavMax=0;
\par \tab g_vCamAhead=D3DXVECTOR3(0,0,1);
\par \tab g_fCamTurnInc=0;
\par \tab g_fCamClimbInc=0;
\par \tab g_dwCamTargetMtx=NO_OBJECT;
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // UpdateCameraObject()
\par 
\par void UpdateCameraObject(void)
\par \{
\par // uncomment to allow mouse manipulation
\par /*
\par \tab // constants for mouse manipulation
\par \tab #define MM_MOVEINC 1.0F
\par \tab #define MM_TURNINC 0.001F
\par \tab #define MM_HIGHINC 3.0F
\par 
\par \tab // turn based on mouse input
\par \tab MatrixYaw(g_dwCamMtx,
\par \tab \tab \tab   ((float)g_nMouseDX)*MM_TURNINC);
\par 
\par \tab // move front-back
\par \tab MatrixBack(g_dwCamMtx,
\par \tab \tab \tab    ((float)g_nMouseDY)*MM_MOVEINC);
\par 
\par \tab // move up-down
\par \tab if(g_bMouseBtnL)
\par \tab \tab MatrixUp(g_dwCamMtx,
\par \tab \tab \tab \tab  MM_HIGHINC);
\par \tab else if(g_bMouseBtnR)
\par \tab \tab MatrixDown(g_dwCamMtx,
\par \tab \tab \tab \tab    MM_HIGHINC);
\par 
\par \tab // set look vector to ahead vector
\par \tab g_vCamAhead.x=g_lpMtx[g_dwCamMtx].mtx._31;
\par \tab g_vCamAhead.y=g_lpMtx[g_dwCamMtx].mtx._32;
\par \tab g_vCamAhead.z=g_lpMtx[g_dwCamMtx].mtx._33;
\par 
\par \tab // reset mouse position
\par \tab ResetMousePosition();
\par 
\par \tab // output position data
\par \tab if(BeginText(g_dwFPSFont))
\par \tab \{
\par \tab \tab // output position
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "P(%f,%f,%f)",
\par \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._41,
\par \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._42,
\par \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._43);
\par \tab \tab OutputText(g_lpMsg,0,32);
\par \tab \tab 
\par \tab \tab // output ahead
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "A(%f,%f,%f)",
\par \tab \tab \tab \tab g_vCamAhead.x,
\par \tab \tab \tab \tab g_vCamAhead.y,
\par \tab \tab \tab \tab g_vCamAhead.z);
\par \tab \tab OutputText(g_lpMsg,0,48);
\par \tab \tab 
\par \tab \tab // end text
\par \tab \tab EndText();
\par \tab \}
\par \tab 
\par \tab // ok
\par \tab return;
\par */\tab 
\par \tab 
\par \tab // alternating counter
\par \tab static DWORD dwAltCount=0;
\par 
\par \tab // navigation update flag
\par \tab BOOL bNavFlag;
\par 
\par \tab // vectors for comparisons
\par \tab D3DXVECTOR3 vV1;
\par \tab D3DXVECTOR3 vV2;
\par \tab D3DXVECTOR3 vV3;
\par 
\par \tab // matrix value
\par \tab DWORD dwMtx;
\par 
\par \tab // distance value
\par \tab float fDist;
\par 
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fY;
\par \tab float fZ;
\par 
\par \tab // boundary flags
\par \tab BOOL bUpper;
\par \tab BOOL bLower;
\par \tab BOOL bCenter;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // tracking value
\par \tab float fTrackingVal;
\par 
\par \tab // nearest creature info
\par \tab DWORD dwNCMtx;
\par \tab float fNCDist;
\par 
\par #ifdef DEBUG_MODE
\par \tab // user control flag
\par \tab static BOOL bUserControl=FALSE;
\par 
\par \tab // read user input
\par \tab ReadUserInput();
\par 
\par \tab // constants
\par \tab #define TURN_SLOW 0.001F
\par \tab #define MOVE_SLOW 0.1F
\par \tab 
\par \tab // check user input
\par \tab if(fabsf(GetAxisPos(g_dwDefXAxis))>EPSILON)
\par \tab \{
\par \tab \tab // turn camera
\par \tab \tab MatrixYaw(g_dwCamMtx,GetAxisPos(g_dwDefXAxis)*TURN_SLOW);
\par 
\par \tab \tab // set flag
\par \tab \tab bUserControl=TRUE;
\par \tab \}
\par \tab if(IsButtonDown(g_dwTopViewBtn))
\par \tab \{
\par \tab \tab if(fabsf(GetAxisPos(g_dwDefYAxis))>EPSILON)
\par \tab \tab \{
\par \tab \tab \tab // move camera
\par \tab \tab \tab MatrixDown(g_dwCamMtx,GetAxisPos(g_dwDefYAxis)*MOVE_SLOW);
\par 
\par \tab \tab \tab // set flag
\par \tab \tab \tab bUserControl=TRUE;
\par \tab \tab \}
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab if(fabsf(GetAxisPos(g_dwDefYAxis))>EPSILON)
\par \tab \tab \{
\par \tab \tab \tab // move camera
\par \tab \tab \tab MatrixBack(g_dwCamMtx,GetAxisPos(g_dwDefYAxis)*MOVE_SLOW);
\par 
\par \tab \tab \tab // set flag
\par \tab \tab \tab bUserControl=TRUE;
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // check user control flag
\par \tab if(bUserControl)
\par \tab \{
\par \tab \tab // set look vector to ahead vector
\par \tab \tab g_vCamAhead.x=g_lpMtx[g_dwCamMtx].mtx._31;
\par \tab \tab g_vCamAhead.y=g_lpMtx[g_dwCamMtx].mtx._32;
\par \tab \tab g_vCamAhead.z=g_lpMtx[g_dwCamMtx].mtx._33;
\par \tab \}
\par \tab else
\par \tab \{
\par #endif
\par 
\par \tab // update alternating counter
\par \tab dwAltCount=(dwAltCount+1)&1;
\par 
\par \tab // set coordinate values
\par \tab fX=g_lpMtx[g_dwCamMtx].mtx._41;
\par \tab fY=g_lpMtx[g_dwCamMtx].mtx._42;
\par \tab fZ=g_lpMtx[g_dwCamMtx].mtx._43;
\par \tab 
\par \tab // check primary state
\par \tab switch(g_dwCamPriState)
\par \tab \{
\par \tab // follow
\par \tab case(PRST_CAMERA_FOLLOW):
\par \tab \tab // reset nearest creature distance
\par \tab \tab fNCDist=Squared(SKYBOX_RAD);
\par 
\par \tab \tab // compare camera position with swans
\par \tab \tab for(dwCount=0;dwCount<g_dwNumSwan;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // save matrix
\par \tab \tab \tab dwMtx=g_lpdwSwanMtx[dwCount];
\par \tab \tab \tab 
\par \tab \tab \tab // set up vector
\par \tab \tab \tab vV1.x=fX-g_lpMtx[dwMtx].mtx._41;
\par \tab \tab \tab vV1.z=fZ-g_lpMtx[dwMtx].mtx._43;
\par 
\par \tab \tab \tab // compute distance
\par \tab \tab \tab fDist=SquareMagnitudeXZ(&vV1);
\par 
\par \tab \tab \tab // check nearest creature distance
\par \tab \tab \tab if(fDist<(fNCDist-Squared(CAMERA_TARGETDISTTOL)))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // save distance
\par \tab \tab \tab \tab fNCDist=fDist;
\par 
\par \tab \tab \tab \tab // save matrix
\par \tab \tab \tab \tab dwNCMtx=dwMtx;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check distance
\par \tab \tab \tab if(fDist<Squared(CAMERA_MINSWANDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // decrease speed
\par \tab \tab \tab \tab g_fCamNavSpeed-=CAMERA_SPEEDINC;
\par 
\par \tab \tab \tab \tab // check for overflow
\par \tab \tab \tab \tab if(g_fCamNavSpeed<CAMERA_MINSPEED)
\par \tab \tab \tab \tab \tab g_fCamNavSpeed=CAMERA_MINSPEED;
\par 
\par \tab \tab \tab \tab // compute inverse distance
\par \tab \tab \tab \tab float fInvDist=1.0F/sqrtf(fDist);
\par 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab vV2.x=vV1.x*fInvDist;
\par \tab \tab \tab \tab vV2.y=0;
\par \tab \tab \tab \tab vV2.z=vV1.z*fInvDist;
\par 
\par \tab \tab \tab \tab // set new position
\par \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._41+=vV2.x*g_fCamNavSpeed;
\par \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._43+=vV2.z*g_fCamNavSpeed;
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // get boundary flags
\par \tab \tab bUpper=IsPointOutOfUpperBounds(fX,fZ);
\par \tab \tab bLower=IsPointOutOfLowerBounds(fX,fZ);
\par \tab \tab bCenter=IsPointOutOfCenterBounds(fX,fZ);
\par 
\par \tab \tab // check boundaries
\par \tab \tab if(bUpper||bLower||bCenter)
\par \tab \tab \{
\par \tab \tab \tab // get vector from center of boundary to camera
\par \tab \tab \tab if(bUpper)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // center of upper boundary
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab fZ-(TERRAIN_CENTERZ-TERRAIN_ZRANGE));
\par \tab \tab \tab \}
\par \tab \tab \tab else if(bLower)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // center of lower boundary
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab fZ-(TERRAIN_CENTERZ+TERRAIN_ZRANGE));
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // center of center boundary
\par \tab \tab \tab \tab vV2=D3DXVECTOR3(fX-TERRAIN_CENTERX,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab fZ-TERRAIN_CENTERZ);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // normalize vector
\par \tab \tab \tab Normalize(&vV1,&vV2);
\par 
\par \tab \tab \tab // get perpendicular vector
\par \tab \tab \tab vV2.x=vV1.z;
\par \tab \tab \tab vV2.y=0;
\par \tab \tab \tab vV2.z=-vV1.x;
\par 
\par \tab \tab \tab // get camera ahead vector
\par \tab \tab \tab vV3=D3DXVECTOR3(g_lpMtx[g_dwCamMtx].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._33);
\par 
\par \tab \tab \tab // check cosine of angle
\par \tab \tab \tab if(DotProduct(&vV2,&vV3)>0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_HARDRIGHT;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_HARDLEFT;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check speed
\par \tab \tab \tab if(g_fCamNavSpeed>CAMERA_MINSPEED*CAMERA_OOBSPEEDFACTOR)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SLOWDOWN;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // set navigation values
\par \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab g_dwCamNavMax=2;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // check for target
\par \tab \tab \tab if(g_dwCamTargetMtx==NO_OBJECT)
\par \tab \tab \tab \tab g_dwCamTargetMtx=GetNewCameraObjectTarget();
\par 
\par \tab \tab \tab // get camera position
\par \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_dwCamMtx].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._43);
\par 
\par \tab \tab \tab // get target position
\par \tab \tab \tab vV2=D3DXVECTOR3(g_lpMtx[g_dwCamTargetMtx].mtx._41,
\par \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_dwCamTargetMtx].mtx._43);
\par 
\par \tab \tab \tab // get distance to target
\par \tab \tab \tab fDist=SquareMagnitudeXZ(vV1.x-vV2.x,
\par \tab \tab \tab \tab \tab \tab \tab \tab     vV1.z-vV2.z);
\par 
\par \tab \tab \tab // check distance to target
\par \tab \tab \tab if(fDist<Squared(CAMERA_OBSERVATIONDISTANCE))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab if(g_fCamNavSpeed>CAMERA_MINSPEED*2.0F)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SLOWDOWN;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab \tab \tab g_dwCamNavMax=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(g_fCamNavSpeed<CAMERA_MINSPEED)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab \tab \tab g_dwCamNavMax=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check navigation state
\par \tab \tab \tab \tab \tab if(g_dwCamNavState==NVST_CAMERA_JUSTFLY)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // change navigation state if necessary
\par \tab \tab \tab \tab \tab \tab if((abs(GetRandomInt())%CAMERA_NAVIGATIONCHANGERATIO)==1)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set new state
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=(DWORD)(abs(GetRandomInt())%CAMERA_NUMNAVIGATIONSTATES);
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavMax=(DWORD)((abs(GetRandomInt())%CAMERA_NAVIGATIONMAXINC)+1);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // change target if necessary
\par \tab \tab \tab \tab if((abs(GetRandomInt())%CAMERA_PRIMARYCHANGERATIO)==1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // reset target matrix
\par \tab \tab \tab \tab \tab g_dwCamTargetMtx=NO_OBJECT;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // get vector from camera to target
\par \tab \tab \tab \tab vV3=vV2-vV1;
\par 
\par \tab \tab \tab \tab // normalize vector
\par \tab \tab \tab \tab Normalize(&vV2,&vV3);
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // get camera ahead vector
\par \tab \tab \tab \tab vV1=D3DXVECTOR3(g_lpMtx[g_dwCamMtx].mtx._31,
\par \tab \tab \tab \tab \tab \tab \tab \tab 0,
\par \tab \tab \tab \tab \tab \tab \tab \tab g_lpMtx[g_dwCamMtx].mtx._33);
\par 
\par \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab if(DotProduct(&vV1,&vV2)>0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab // check cosine of angle
\par \tab \tab \tab \tab \tab if(DotProduct(&vV3,&vV2)>0)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_HARDRIGHT;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_HARDLEFT;
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab if(g_fCamNavSpeed>CAMERA_MINSPEED)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab \tab \tab g_dwCamNavMax=2;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get vector perpendicular to ahead vector
\par \tab \tab \tab \tab \tab vV3.x=vV1.z;
\par \tab \tab \tab \tab \tab vV3.y=0;
\par \tab \tab \tab \tab \tab vV3.z=-vV1.x;
\par 
\par \tab \tab \tab \tab \tab // save tracking value
\par \tab \tab \tab \tab \tab fTrackingVal=DotProduct(&vV3,&vV2);
\par 
\par \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab if(fabsf(fTrackingVal)>CAMERA_FOLLOWTRACKINGVAL)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check tracking value
\par \tab \tab \tab \tab \tab \tab if(fTrackingVal>0)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard right
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_HARDRIGHT;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to hard left
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_HARDLEFT;
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_fCamNavSpeed<CAMERA_MINSPEED)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SPEEDUP;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab else if(g_fCamNavSpeed>CAMERA_MINSPEED*2.0F)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check alternating counter
\par \tab \tab \tab \tab \tab \tab \tab if(dwAltCount)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set state to slow down
\par \tab \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SLOWDOWN;
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab \tab \tab \tab g_dwCamNavMax=2;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // check speed
\par \tab \tab \tab \tab \tab \tab if(g_fCamNavSpeed<CAMERA_MAXSPEED)
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // set state to speed up
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavState=NVST_CAMERA_SPEEDUP;
\par 
\par \tab \tab \tab \tab \tab \tab \tab // set navigation values
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavPos=0;
\par \tab \tab \tab \tab \tab \tab \tab g_dwCamNavMax=2;
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // check navigation state
\par \tab if(g_dwCamNavState!=NVST_CAMERA_JUSTFLY)
\par \tab \{
\par \tab \tab // check navigation position
\par \tab \tab if(g_dwCamNavPos<g_dwCamNavMax)
\par \tab \tab \{
\par \tab \tab \tab // set flag
\par \tab \tab \tab bNavFlag=TRUE;
\par 
\par \tab \tab \tab // increment navigation position
\par \tab \tab \tab g_dwCamNavPos++;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // reset flag
\par \tab \tab \tab bNavFlag=FALSE;
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // check navigation state
\par \tab switch(g_dwCamNavState)
\par \tab \{
\par \tab // speed up
\par \tab case(NVST_CAMERA_SPEEDUP):
\par \tab \tab // increase speed
\par \tab \tab g_fCamNavSpeed+=CAMERA_SPEEDINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamNavSpeed>CAMERA_MAXSPEED)
\par \tab \tab \tab g_fCamNavSpeed=CAMERA_MAXSPEED;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // slow down
\par \tab case(NVST_CAMERA_SLOWDOWN):
\par \tab \tab // decrease speed
\par \tab \tab g_fCamNavSpeed-=CAMERA_SPEEDINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamNavSpeed<0)
\par \tab \tab \tab g_fCamNavSpeed=0;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // turn left
\par \tab case(NVST_CAMERA_TURNLEFT):
\par \tab \tab // increase turn increment
\par \tab \tab g_fCamTurnInc+=CAMERA_TURNINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamTurnInc>CAMERA_MAXTURNINC)
\par \tab \tab \tab g_fCamTurnInc=CAMERA_MAXTURNINC;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // turn right
\par \tab case(NVST_CAMERA_TURNRIGHT):
\par \tab \tab // decrease turn increment
\par \tab \tab g_fCamTurnInc-=CAMERA_TURNINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamTurnInc<-CAMERA_MAXTURNINC)
\par \tab \tab \tab g_fCamTurnInc=-CAMERA_MAXTURNINC;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // hard left
\par \tab case(NVST_CAMERA_HARDLEFT):
\par \tab \tab // increase turn increment
\par \tab \tab g_fCamTurnInc+=CAMERA_HARDTURNINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamTurnInc>CAMERA_MAXTURNINC)
\par \tab \tab \tab g_fCamTurnInc=CAMERA_MAXTURNINC;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // hard right
\par \tab case(NVST_CAMERA_HARDRIGHT):
\par \tab \tab // decrease turn increment
\par \tab \tab g_fCamTurnInc-=CAMERA_HARDTURNINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamTurnInc<-CAMERA_MAXTURNINC)
\par \tab \tab \tab g_fCamTurnInc=-CAMERA_MAXTURNINC;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // climb
\par \tab case(NVST_CAMERA_CLIMB):
\par \tab \tab // increase climb increment
\par \tab \tab g_fCamClimbInc+=CAMERA_CLIMBINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamClimbInc>CAMERA_MAXCLIMBINC)
\par \tab \tab \tab g_fCamClimbInc=CAMERA_MAXCLIMBINC;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // dive
\par \tab case(NVST_CAMERA_DIVE):
\par \tab \tab // decrease climb increment
\par \tab \tab g_fCamClimbInc-=CAMERA_CLIMBINC;
\par 
\par \tab \tab // check for overflow
\par \tab \tab if(g_fCamClimbInc<-CAMERA_MAXCLIMBINC)
\par \tab \tab \tab g_fCamClimbInc=-CAMERA_MAXCLIMBINC;
\par 
\par \tab \tab // check navigation flag
\par \tab \tab if(!bNavFlag)
\par \tab \tab \{
\par \tab \tab \tab // set state to fly
\par \tab \tab \tab g_dwCamNavState=NVST_CAMERA_JUSTFLY;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // turn camera
\par \tab MatrixYaw(g_dwCamMtx,
\par \tab \tab \tab   g_fCamTurnInc);
\par 
\par \tab // move camera
\par \tab MatrixBack(g_dwCamMtx,
\par \tab \tab \tab    g_fCamNavSpeed);
\par \tab MatrixUp(g_dwCamMtx,
\par \tab \tab \tab  g_fCamClimbInc);
\par 
\par \tab // clip altitude
\par \tab if(g_lpMtx[g_dwCamMtx].mtx._42<CAMERA_MINHEIGHT)
\par \tab \tab g_lpMtx[g_dwCamMtx].mtx._42=CAMERA_MINHEIGHT;
\par \tab else if(g_lpMtx[g_dwCamMtx].mtx._42>CAMERA_MAXHEIGHT)
\par \tab \tab g_lpMtx[g_dwCamMtx].mtx._42=CAMERA_MAXHEIGHT;
\par 
\par \tab // straighten turn if not turning
\par \tab if(g_dwCamNavState!=NVST_CAMERA_TURNLEFT&&
\par \tab    g_dwCamNavState!=NVST_CAMERA_HARDLEFT&&
\par \tab    g_dwCamNavState!=NVST_CAMERA_TURNRIGHT&&
\par \tab    g_dwCamNavState!=NVST_CAMERA_HARDRIGHT)
\par \tab \{
\par \tab \tab // check turn value
\par \tab \tab if(g_fCamTurnInc<-EPSILON)
\par \tab \tab \tab g_fCamTurnInc+=CAMERA_TURNINC;
\par \tab \tab else if(g_fCamTurnInc>EPSILON)
\par \tab \tab \tab g_fCamTurnInc-=CAMERA_TURNINC;
\par \tab \}
\par 
\par \tab // level path if not climbing or diving
\par \tab if(g_dwCamNavState!=NVST_CAMERA_CLIMB&&
\par \tab    g_dwCamNavState!=NVST_CAMERA_DIVE)
\par \tab \{
\par \tab \tab // check climb value
\par \tab \tab if(g_fCamClimbInc<-CAMERA_CLIMBINC)
\par \tab \tab \tab g_fCamClimbInc+=CAMERA_CLIMBINC;
\par \tab \tab else if(g_fCamClimbInc>CAMERA_CLIMBINC)
\par \tab \tab \tab g_fCamClimbInc-=CAMERA_CLIMBINC;
\par \tab \}
\par 
\par \tab // get target vector
\par \tab if(dwNCMtx==NO_OBJECT)
\par \tab \{
\par \tab \tab // use camera ahead vector
\par \tab \tab vV1.x=-g_lpMtx[g_dwCamMtx].mtx._31;
\par \tab \tab vV1.y=-g_lpMtx[g_dwCamMtx].mtx._32;
\par \tab \tab vV1.z=-g_lpMtx[g_dwCamMtx].mtx._33;
\par 
\par \tab \tab // track ahead vector to target
\par \tab \tab vV2.x=GetInterpolatedValue(g_vCamAhead.x,vV1.x,CAMERA_TRACKINGINC2);
\par \tab \tab vV2.y=GetInterpolatedValue(g_vCamAhead.y,vV1.y,CAMERA_TRACKINGINC2);
\par \tab \tab vV2.z=GetInterpolatedValue(g_vCamAhead.z,vV1.z,CAMERA_TRACKINGINC2);
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // use vector to nearest creature
\par \tab \tab vV2.x=g_lpMtx[dwNCMtx].mtx._41-g_lpMtx[g_dwCamMtx].mtx._41;
\par \tab \tab vV2.y=CAMERA_TARGETYOFFSET    -g_lpMtx[g_dwCamMtx].mtx._42;
\par \tab \tab vV2.z=g_lpMtx[dwNCMtx].mtx._43-g_lpMtx[g_dwCamMtx].mtx._43;
\par 
\par \tab \tab // normalize vector
\par \tab \tab Normalize(&vV1,&vV2);
\par 
\par \tab \tab // track ahead vector to target
\par \tab \tab vV2.x=GetInterpolatedValue(g_vCamAhead.x,vV1.x,CAMERA_TRACKINGINC);
\par \tab \tab vV2.y=GetInterpolatedValue(g_vCamAhead.y,vV1.y,CAMERA_TRACKINGINC);
\par \tab \tab vV2.z=GetInterpolatedValue(g_vCamAhead.z,vV1.z,CAMERA_TRACKINGINC);
\par \tab \}
\par 
\par \tab // check ahead y-value
\par \tab if(vV2.y>CAMERA_MAXAHEADYVALUE)
\par \tab \tab vV2.y=CAMERA_MAXAHEADYVALUE;
\par \tab else if(vV2.y<-CAMERA_MAXAHEADYVALUE)
\par \tab \tab vV2.y=-CAMERA_MAXAHEADYVALUE;
\par 
\par \tab // normalize vector
\par \tab Normalize(&g_vCamAhead,&vV2);
\par 
\par #ifdef DEBUG_MODE
\par \tab \}
\par #endif
\par \}
\par 
\par // SetCameraObjectToViewMatrix()
\par 
\par void SetCameraObjectToViewMatrix(void)
\par \{
\par \tab // coordinate values
\par \tab float fX;
\par \tab float fY;
\par \tab float fZ;
\par \tab 
\par \tab // set pointer to output matrix
\par \tab LPD3DXMATRIX lpMtx=&g_lpMtx[g_dwCamOutputMtx].mtx;
\par 
\par \tab // set position
\par \tab lpMtx->_41=g_lpMtx[g_dwCamMtx].mtx._41;
\par \tab lpMtx->_42=g_lpMtx[g_dwCamMtx].mtx._42;
\par \tab lpMtx->_43=g_lpMtx[g_dwCamMtx].mtx._43;
\par 
\par \tab // set ahead vector
\par \tab lpMtx->_31=g_vCamAhead.x;
\par \tab lpMtx->_32=g_vCamAhead.y;
\par \tab lpMtx->_33=g_vCamAhead.z;
\par \tab 
\par \tab // compute right vector
\par \tab CrossProduct(&fX,&fY,&fZ,
\par \tab \tab \tab \tab  0,1,0,
\par \tab \tab \tab \tab  lpMtx->_31,lpMtx->_32,lpMtx->_33);
\par 
\par \tab // set right vector
\par \tab lpMtx->_11=fX;
\par \tab lpMtx->_12=fY;
\par \tab lpMtx->_13=fZ;
\par 
\par \tab // set as camera matrix
\par \tab SetCameraMatrix(g_dwCamOutputMtx);
\par \}
\par 
\par // GetNewCameraObjectTarget()
\par 
\par DWORD GetNewCameraObjectTarget(void)
\par \{
\par \tab // return value
\par \tab DWORD dwRetVal;
\par \tab 
\par \tab // select random swan
\par \tab DWORD dwSwanNum=(DWORD)(abs(GetRandomInt())%g_dwNumSwan);
\par 
\par \tab // set return matrix index
\par \tab dwRetVal=g_lpdwSwanMtx[dwSwanNum];
\par 
\par #ifdef DEBUG_MODE
\par \tab // verify index
\par \tab if(dwRetVal>g_dwNumMtx)
\par \tab \{
\par \tab \tab DisplayFatalErrorMessage("Invalid matrix index",
\par \tab \tab \tab \tab \tab \tab \tab \tab  "GetNewCameraObjectTarget()",
\par \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par \tab \}
\par #endif
\par 
\par \tab // return index
\par \tab return(dwRetVal);
\par \}
\par 
\par // InitSoundFX()
\par 
\par BOOL InitSoundFX(void)
\par \{
\par \tab LoadingOutput("InitSoundFX");
\par 
\par \tab // prepare 3D sound as needed
\par \tab if(g_bUseSFX)
\par \tab \{
\par \tab \tab if(g_bUse3DSound)
\par \tab \tab \{
\par \tab \tab \tab // enable 3D audio
\par \tab \tab \tab Enable3DAudio();
\par 
\par \tab \tab \tab // init audio listener
\par \tab \tab \tab if(!InitAudioListener())
\par \tab \tab \tab \{
\par \tab \tab \tab \tab DisplayErrorMessage("Unable to initialize 3-D audio.",
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab "Try disabling 3-D audio in the application settings.",
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab FALSE);
\par \tab \tab \tab \tab return(FALSE);
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // set listener distance factor
\par \tab \tab \tab SetListenerDistanceFactor(DIST_INCH*6.0F);
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // disable 3D audio
\par \tab \tab \tab Disable3DAudio();
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // initialize audiopath manager
\par \tab if(g_bUseSFX)
\par \tab \tab if(!InitAudioPathManager(NUM_MANAGEDAUDIOPATHS,g_bUse3DSound))
\par \tab \tab \tab return(FALSE);
\par 
\par \tab // load music
\par \tab if(g_bUseMusic)
\par \tab \{
\par \tab \tab // add segment
\par \tab \tab g_dwLeCygneMus=AddAudioSegment("lecygne1.mid");
\par 
\par \tab \tab // check segment
\par \tab \tab if(g_dwLeCygneMus==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // load sound effects
\par \tab if(g_bUseSFX)
\par \tab \{
\par \tab \tab // add & check segment
\par \tab \tab g_dwEagleSFX=AddAudioSegment("eagle1.wav");
\par \tab \tab if(g_dwEagleSFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwBirds1SFX=AddAudioSegment("birds1.wav");
\par \tab \tab if(g_dwBirds1SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwBirds2SFX=AddAudioSegment("birds2.wav");
\par \tab \tab if(g_dwBirds2SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwSwan1SFX=AddAudioSegment("swan1.wav");
\par \tab \tab if(g_dwSwan1SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwSwan2SFX=AddAudioSegment("swan2.wav");
\par \tab \tab if(g_dwSwan2SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwSwan3SFX=AddAudioSegment("swan3.wav");
\par \tab \tab if(g_dwSwan3SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwSplashSFX=AddAudioSegment("splash1.wav");
\par \tab \tab if(g_dwSplashSFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwBBSwan1SFX=AddAudioSegment("bbswan1.wav");
\par \tab \tab if(g_dwBBSwan1SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwBBSwan2SFX=AddAudioSegment("bbswan2.wav");
\par \tab \tab if(g_dwBBSwan2SFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // add & check segment
\par \tab \tab g_dwBuzzSFX=AddAudioSegment("buzz1.wav");
\par \tab \tab if(g_dwBuzzSFX==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // set music repeats
\par \tab if(g_bUseMusic)
\par \tab \tab SetAudioSegmentRepeats(g_dwLeCygneMus);
\par 
\par \tab // check sound flag
\par \tab if(g_bUseSFX)
\par \tab \{
\par \tab \tab // init dragonfly sound effects
\par \tab \tab if(!InitDragonflySFX())
\par \tab \tab \tab return(FALSE);
\par \tab \tab 
\par \tab \tab // init fish sound effects
\par \tab \tab if(!InitFishSFX())
\par \tab \tab \tab return(FALSE);
\par \tab \tab 
\par \tab \tab // init sound sources
\par \tab \tab if(!InitSoundSources())
\par \tab \tab \tab return(FALSE);
\par 
\par \tab \tab // init sound position data
\par \tab \tab if(!InitSoundPositionData())
\par \tab \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // UpdateSoundPosition()
\par 
\par void UpdateSoundPosition(LPSOUNDPOSDATA lpSPD)
\par \{
\par \tab // audiopath index
\par \tab DWORD dwPathIndex;
\par 
\par \tab // vectors for comparison
\par \tab D3DXVECTOR3 vV1;
\par \tab D3DXVECTOR3 vV2;
\par \tab D3DXVECTOR3 vV3;
\par 
\par \tab // distance value
\par \tab float fDist;
\par 
\par \tab // check sound effect
\par \tab if(IsAudioSegmentPlaying(lpSPD->dwSFXIndex))
\par \tab \{
\par \tab \tab // set playback flag
\par \tab \tab lpSPD->bPlayback=TRUE;
\par 
\par \tab \tab // get audiopath index
\par \tab \tab if(GetManagedAudioPathIndex(lpSPD->dwAudioPathID,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab &dwPathIndex))
\par \tab \tab \{
\par \tab \tab \tab // check 3D sound flag
\par \tab \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // update position
\par \tab \tab \tab \tab SetAudioPathPosition(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  lpSPD->dwTargetMtxIndex);
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // audiopath lost
\par \tab \tab \tab StopAudioSegment(lpSPD->dwSFXIndex);
\par 
\par \tab \tab \tab // reset audiopath id
\par \tab \tab \tab lpSPD->dwAudioPathID=NO_OBJECT;
\par \tab \tab \}
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // check playback flag
\par \tab \tab if(lpSPD->bPlayback==FALSE)
\par \tab \tab \{
\par \tab \tab \tab // chill until playback starts
\par \tab \tab \tab return;
\par \tab \tab \}
\par 
\par \tab \tab // check audiopath id
\par \tab \tab if(lpSPD->dwAudioPathID!=NO_OBJECT)
\par \tab \tab \{
\par \tab \tab \tab // release audiopath
\par \tab \tab \tab ReleaseManagedAudioPath(lpSPD->dwAudioPathID);
\par 
\par \tab \tab \tab // reset audiopath id
\par \tab \tab \tab lpSPD->dwAudioPathID=NO_OBJECT;
\par \tab \tab \}
\par 
\par \tab \tab // play sound if necessary
\par \tab \tab if((abs(GetRandomInt()%lpSPD->dwRepeatVal))==1)
\par \tab \tab \{
\par \tab \tab \tab // check for targets
\par \tab \tab \tab if(lpSPD->dwNumTarget)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // capture audiopath
\par \tab \tab \tab \tab if(CaptureManagedAudioPath(&lpSPD->dwAudioPathID,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    lpSPD->dwSFXPriVal))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // get audiopath index
\par \tab \tab \tab \tab \tab if(GetManagedAudioPathIndex(lpSPD->dwAudioPathID,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &dwPathIndex))
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // select random target
\par \tab \tab \tab \tab \tab \tab lpSPD->dwTargetMtxIndex=lpSPD->lpdwTargetMtxArray[abs(GetRandomInt()%lpSPD->dwNumTarget)];
\par 
\par \tab \tab \tab \tab \tab \tab // get camera position
\par \tab \tab \tab \tab \tab \tab vV1.x=g_lpMtx[g_dwCamMtx].mtx._41;
\par \tab \tab \tab \tab \tab \tab vV1.z=g_lpMtx[g_dwCamMtx].mtx._43;
\par 
\par \tab \tab \tab \tab \tab \tab // get target position
\par \tab \tab \tab \tab \tab \tab vV2.x=g_lpMtx[lpSPD->dwTargetMtxIndex].mtx._41;
\par \tab \tab \tab \tab \tab \tab vV2.z=g_lpMtx[lpSPD->dwTargetMtxIndex].mtx._43;
\par \tab \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab \tab // get vector from camera to target
\par \tab \tab \tab \tab \tab \tab vV3.x=vV2.x-vV1.x;
\par \tab \tab \tab \tab \tab \tab vV3.z=vV2.z-vV1.z;
\par 
\par \tab \tab \tab \tab \tab \tab // get distance to target
\par \tab \tab \tab \tab \tab \tab fDist=SquareMagnitudeXZ(&vV3);
\par 
\par \tab \tab \tab \tab \tab \tab // check distance
\par \tab \tab \tab \tab \tab \tab if(fDist>Squared(CAMERA_MINSOUNDDISTANCE))
\par \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab // check 3D sound flag
\par \tab \tab \tab \tab \tab \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath minimum distance
\par \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathMinDistance(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab lpSPD->fMinDist);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath maximum distance
\par \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathMaxDistance(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab lpSPD->fMaxDist);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath max volume
\par \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathVolume(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    lpSPD->fMaxVolVal);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // set audiopath position
\par \tab \tab \tab \tab \tab \tab \tab \tab SetAudioPathPosition(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  lpSPD->dwTargetMtxIndex);
\par 
\par \tab \tab \tab \tab \tab \tab \tab \tab // render audio changes
\par \tab \tab \tab \tab \tab \tab \tab \tab RenderAudioChanges();
\par \tab \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab \tab \tab // set simulated 3D settings
\par \tab \tab \tab \tab \tab \tab \tab \tab SimulateAudioPath3D(dwPathIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab g_dwCamMtx,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab &g_vCamAhead,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab lpSPD->dwTargetMtxIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab lpSPD->fMinDist,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab lpSPD->fMaxDist,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab lpSPD->fMaxVolVal);
\par \tab \tab \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab \tab \tab \tab // reset playback flag
\par \tab \tab \tab \tab \tab \tab \tab lpSPD->bPlayback=FALSE;
\par 
\par \tab \tab \tab \tab \tab \tab \tab // play segment
\par \tab \tab \tab \tab \tab \tab \tab PlayAudioSegment(lpSPD->dwSFXIndex,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  dwPathIndex);
\par \tab \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par \}
\par 
\par // RenderSoundFX()
\par 
\par void RenderSoundFX(void)
\par \{
\par \tab // check 3D sound flag
\par \tab if(g_bUseSFX)
\par \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab RenderAudioChanges();
\par \}
\par 
\par // ReleaseSoundFX()
\par 
\par void ReleaseSoundFX(void)
\par \{
\par \tab // check sound flag
\par \tab if(g_bUseSFX)
\par \tab \{
\par \tab \tab // release audiopath manager
\par \tab \tab ReleaseAudioPathManager();
\par 
\par \tab \tab // release audio listener
\par \tab \tab if(g_bUse3DSound)
\par \tab \tab \tab ReleaseAudioListener();
\par \tab \}
\par \}
\par 
\par // SetSoundPositionData()
\par 
\par void SetSoundPositionData(LPSOUNDPOSDATA lpSPD,
\par \tab \tab \tab \tab \tab \tab   DWORD dwSFXIndex,
\par \tab \tab \tab \tab \tab \tab   DWORD dwRepeatVal,
\par \tab \tab \tab \tab \tab \tab   DWORD dwSFXPriVal,
\par \tab \tab \tab \tab \tab \tab   float fMaxVolVal,
\par \tab \tab \tab \tab \tab \tab   float fMinDist,
\par \tab \tab \tab \tab \tab \tab   float fMaxDist,
\par \tab \tab \tab \tab \tab \tab   DWORD dwNumTarget,
\par \tab \tab \tab \tab \tab \tab   LPDWORD lpdwTargetMtxArray)
\par \{
\par \tab // set values
\par \tab lpSPD->dwSFXIndex=dwSFXIndex;
\par \tab lpSPD->dwAudioPathID=NO_OBJECT;
\par \tab lpSPD->dwRepeatVal=dwRepeatVal;
\par \tab lpSPD->dwSFXPriVal=dwSFXPriVal;
\par \tab lpSPD->fMaxVolVal=fMaxVolVal;
\par \tab lpSPD->fMinDist=fMinDist;
\par \tab lpSPD->fMaxDist=fMaxDist;
\par \tab lpSPD->dwNumTarget=dwNumTarget;
\par \tab lpSPD->lpdwTargetMtxArray=lpdwTargetMtxArray;
\par \tab lpSPD->dwTargetMtxIndex=NO_OBJECT;
\par \tab lpSPD->bPlayback=TRUE;
\par \}
\par 
\par // InitSoundPositionData()
\par 
\par BOOL InitSoundPositionData(void)
\par \{
\par \tab LoadingOutput("InitSoundPositionData");
\par 
\par \tab // init eagle sfx
\par \tab SetSoundPositionData(&g_spdEagle,
\par \tab \tab \tab \tab \tab \tab  g_dwEagleSFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_EAGLE,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_EAGLE,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_EAGLE,
\par \tab \tab \tab \tab \tab \tab  MINDIST_EAGLE,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_EAGLE,
\par \tab \tab \tab \tab \tab \tab  g_dwNumBird,
\par \tab \tab \tab \tab \tab \tab  g_lpdwBirdMtx);
\par \tab 
\par \tab // init swan sfx #1
\par \tab SetSoundPositionData(&g_spdSwan1,
\par \tab \tab \tab \tab \tab \tab  g_dwSwan1SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_SWAN1,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_SWAN1,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_SWAN1,
\par \tab \tab \tab \tab \tab \tab  MINDIST_SWAN1,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_SWAN1,
\par \tab \tab \tab \tab \tab \tab  g_dwNumSwan,
\par \tab \tab \tab \tab \tab \tab  g_lpdwSwanMtx);
\par \tab 
\par \tab // init swan sfx #2
\par \tab SetSoundPositionData(&g_spdSwan2,
\par \tab \tab \tab \tab \tab \tab  g_dwSwan2SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_SWAN2,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_SWAN2,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_SWAN2,
\par \tab \tab \tab \tab \tab \tab  MINDIST_SWAN2,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_SWAN2,
\par \tab \tab \tab \tab \tab \tab  g_dwNumSwan,
\par \tab \tab \tab \tab \tab \tab  g_lpdwSwanMtx);
\par \tab 
\par \tab // init swan sfx #3
\par \tab SetSoundPositionData(&g_spdSwan3,
\par \tab \tab \tab \tab \tab \tab  g_dwSwan3SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_SWAN3,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_SWAN3,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_SWAN3,
\par \tab \tab \tab \tab \tab \tab  MINDIST_SWAN3,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_SWAN3,
\par \tab \tab \tab \tab \tab \tab  g_dwNumSwan,
\par \tab \tab \tab \tab \tab \tab  g_lpdwSwanMtx);
\par \tab 
\par \tab // init baby swan sfx #1
\par \tab SetSoundPositionData(&g_spdBBSwan1,
\par \tab \tab \tab \tab \tab \tab  g_dwBBSwan1SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_BBSWAN1,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_BBSWAN1,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_BBSWAN1,
\par \tab \tab \tab \tab \tab \tab  MINDIST_BBSWAN1,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_BBSWAN1,
\par \tab \tab \tab \tab \tab \tab  g_dwNumBBSwan,
\par \tab \tab \tab \tab \tab \tab  g_lpdwBBSwanMtx);
\par \tab 
\par \tab // init baby swan sfx #2
\par \tab SetSoundPositionData(&g_spdBBSwan2,
\par \tab \tab \tab \tab \tab \tab  g_dwBBSwan2SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_BBSWAN2,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_BBSWAN2,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_BBSWAN2,
\par \tab \tab \tab \tab \tab \tab  MINDIST_BBSWAN2,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_BBSWAN2,
\par \tab \tab \tab \tab \tab \tab  g_dwNumBBSwan,
\par \tab \tab \tab \tab \tab \tab  g_lpdwBBSwanMtx);
\par \tab 
\par \tab // init birds sfx #1
\par \tab SetSoundPositionData(&g_spdBirds1,
\par \tab \tab \tab \tab \tab \tab  g_dwBirds1SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_BIRDS1,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_BIRDS1,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_BIRDS1,
\par \tab \tab \tab \tab \tab \tab  MINDIST_BIRDS1,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_BIRDS1,
\par \tab \tab \tab \tab \tab \tab  SNDSRC_NUMSOURCES,
\par \tab \tab \tab \tab \tab \tab  g_lpdwSndSrcMtx);
\par \tab 
\par \tab // init birds sfx #2
\par \tab SetSoundPositionData(&g_spdBirds2,
\par \tab \tab \tab \tab \tab \tab  g_dwBirds2SFX,
\par \tab \tab \tab \tab \tab \tab  REPEAT_BIRDS2,
\par \tab \tab \tab \tab \tab \tab  SFXPRI_BIRDS2,
\par \tab \tab \tab \tab \tab \tab  MAXVOL_BIRDS2,
\par \tab \tab \tab \tab \tab \tab  MINDIST_BIRDS2,
\par \tab \tab \tab \tab \tab \tab  MAXDIST_BIRDS2,
\par \tab \tab \tab \tab \tab \tab  SNDSRC_NUMSOURCES,
\par \tab \tab \tab \tab \tab \tab  g_lpdwSndSrcMtx);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // UpdateSoundFX()
\par 
\par void UpdateSoundFX(void)
\par \{
\par \tab // check sound flag
\par \tab if(g_bUseSFX)
\par \tab \{
\par \tab \tab // check 3D sound flag
\par \tab \tab if(g_bUse3DSound)
\par \tab \tab \{
\par \tab \tab \tab // update listener position
\par \tab \tab \tab SetListenerPosition(g_dwCamMtx);
\par 
\par \tab \tab \tab // update listener orientation
\par \tab \tab \tab SetListenerOrientation(&g_vCamAhead);
\par \tab \tab \}
\par 
\par \tab \tab // update sound positions
\par \tab \tab UpdateSoundPosition(&g_spdEagle);
\par \tab \tab if(!g_bPhantomSwan)
\par \tab \tab \{
\par \tab \tab \tab UpdateSoundPosition(&g_spdSwan1);
\par \tab \tab \tab UpdateSoundPosition(&g_spdSwan2);
\par \tab \tab \tab UpdateSoundPosition(&g_spdSwan3);
\par \tab \tab \}
\par \tab \tab UpdateSoundPosition(&g_spdBBSwan1);
\par \tab \tab UpdateSoundPosition(&g_spdBBSwan2);
\par \tab \tab UpdateSoundPosition(&g_spdBirds1);
\par \tab \tab UpdateSoundPosition(&g_spdBirds2);
\par \tab \}
\par \}
\par 
\par // InitSoundSources()
\par 
\par BOOL InitSoundSources(void)
\par \{
\par \tab LoadingOutput("InitSoundSources");
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // angle value
\par \tab float fAngle;
\par \tab 
\par \tab // position values
\par \tab float fX;
\par \tab float fZ;
\par 
\par \tab // set random sound sources
\par \tab for(dwCount=0;dwCount<SNDSRC_NUMSOURCES;dwCount++)
\par \tab \{
\par \tab \tab // create random position
\par \tab \tab switch(abs(GetRandomInt())%3)
\par \tab \tab \{
\par \tab \tab // upper round portion of boundary
\par \tab \tab case(0):
\par \tab \tab \tab // set angle value
\par \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab 
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX-(cosf(fAngle)*SNDSRC_OOBFACTOR*TERRAIN_XRANGE);
\par \tab \tab \tab fZ=(TERRAIN_CENTERZ-TERRAIN_ZRANGE)-(sinf(fAngle)*SNDSRC_OOBFACTOR*TERRAIN_XRANGE);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // center rectangular portion of boundary
\par \tab \tab case(1):
\par \tab \tab \tab // set x-position
\par \tab \tab \tab if(GetRandomInt()<0)
\par \tab \tab \tab \tab fX=TERRAIN_CENTERX+(SNDSRC_OOBFACTOR*TERRAIN_XRANGE);
\par \tab \tab \tab else
\par \tab \tab \tab \tab fX=TERRAIN_CENTERX-(SNDSRC_OOBFACTOR*TERRAIN_XRANGE);
\par 
\par \tab \tab \tab // set z-position
\par \tab \tab \tab fZ=TERRAIN_CENTERZ+(GetRandomFloat()*TERRAIN_ZRANGE);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // lower round portion of boundary
\par \tab \tab case(2):
\par \tab \tab \tab // set angle value
\par \tab \tab \tab fAngle=fabsf(GetRandomFloat()*PI);
\par \tab \tab \tab 
\par \tab \tab \tab // set position
\par \tab \tab \tab fX=TERRAIN_CENTERX+(cosf(fAngle)*SNDSRC_OOBFACTOR*TERRAIN_XRANGE);
\par \tab \tab \tab fZ=(TERRAIN_CENTERZ+TERRAIN_ZRANGE)+(sinf(fAngle)*SNDSRC_OOBFACTOR*TERRAIN_XRANGE);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // add matrix with new position
\par \tab \tab g_lpdwSndSrcMtx[dwCount]=AddMatrix(1,0,0,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,1,0,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    0,0,1,0,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab    fX,0,fZ,1);
\par 
\par \tab \tab // check matrix
\par \tab \tab if(g_lpdwSndSrcMtx[dwCount]==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitDragonflySFX()
\par 
\par BOOL InitDragonflySFX(void)
\par \{
\par \tab LoadingOutput("InitDragonflySFX");
\par 
\par \tab // counter
\par \tab DWORD dwIndex;
\par 
\par \tab // mate index
\par \tab DWORD dwMateIndex;
\par 
\par \tab // assign audio segment to each dragonfly or couple
\par \tab for(dwIndex=0;dwIndex<g_dwNumDFly;dwIndex++)
\par \tab \{
\par \tab \tab // check counter
\par \tab \tab if(dwIndex==0)
\par \tab \tab \{
\par \tab \tab \tab // assign original segment index
\par \tab \tab \tab g_lpdwDFlyBuzzIdx[dwIndex]=g_dwBuzzSFX;
\par 
\par \tab \tab \tab // set infinite repeats
\par \tab \tab \tab SetAudioSegmentRepeats(g_lpdwDFlyBuzzIdx[dwIndex]);
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // get mate index
\par \tab \tab \tab dwMateIndex=g_lpdwDFlyMateIdx[dwIndex];
\par 
\par \tab \tab \tab // check mate index
\par \tab \tab \tab if(dwMateIndex==NO_OBJECT||
\par \tab \tab \tab    (dwMateIndex!=NO_OBJECT&&
\par \tab \tab \tab    g_lpdwDFlyBuzzIdx[dwMateIndex]==NO_OBJECT))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // assign cloned segment index
\par \tab \tab \tab \tab g_lpdwDFlyBuzzIdx[dwIndex]=CloneAudioSegment(g_dwBuzzSFX);
\par 
\par \tab \tab \tab \tab // check for error
\par \tab \tab \tab \tab if(g_lpdwDFlyBuzzIdx[dwIndex]==NO_OBJECT)
\par \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab // set infinite repeats
\par \tab \tab \tab \tab SetAudioSegmentRepeats(g_lpdwDFlyBuzzIdx[dwIndex]);
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitFishSFX()
\par 
\par BOOL InitFishSFX(void)
\par \{
\par \tab LoadingOutput("InitFishSFX");
\par 
\par \tab // counter
\par \tab DWORD dwIndex;
\par 
\par \tab // assign audio segment to each fish
\par \tab for(dwIndex=0;dwIndex<g_dwNumFish;dwIndex++)
\par \tab \{
\par \tab \tab // check counter
\par \tab \tab if(dwIndex==0)
\par \tab \tab \{
\par \tab \tab \tab // assign original segment index
\par \tab \tab \tab g_lpdwFishSplashIdx[dwIndex]=g_dwSplashSFX;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // assign cloned segment index
\par \tab \tab \tab g_lpdwFishSplashIdx[dwIndex]=CloneAudioSegment(g_dwSplashSFX);
\par 
\par \tab \tab \tab // check for error
\par \tab \tab \tab if(g_lpdwFishSplashIdx[dwIndex]==NO_OBJECT)
\par \tab \tab \tab \tab return(FALSE);
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // AddCreatures()
\par 
\par BOOL AddCreatures(void)
\par \{
\par \tab LoadingOutput("AddCreatures");
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // number of baby swans
\par \tab DWORD dwNumBBSwans;
\par 
\par \tab // set counter to number of swans
\par \tab dwCount=g_dwSceneNumSwans;
\par 
\par \tab // check number of swans
\par \tab if(dwCount)
\par \tab \{\tab 
\par \tab \tab // check baby swans flag
\par \tab \tab if(g_bSceneBBSwans)
\par \tab \tab \{
\par \tab \tab \tab // add swans & baby swans
\par \tab \tab \tab while(dwCount)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check counter
\par \tab \tab \tab \tab if(dwCount==1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // add single swan
\par \tab \tab \tab \tab \tab if(AddSwanLoner()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab dwCount--;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(dwCount==2)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check random value
\par \tab \tab \tab \tab \tab switch(abs(GetRandomInt())%3)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab case(0):
\par \tab \tab \tab \tab \tab \tab // add single swan
\par \tab \tab \tab \tab \tab \tab if(AddSwanLoner()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount--;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab case(1):
\par \tab \tab \tab \tab \tab \tab // add swan couple
\par \tab \tab \tab \tab \tab \tab if(AddSwanCouple()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount-=2;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab default:
\par \tab \tab \tab \tab \tab \tab // add single swan with baby
\par \tab \tab \tab \tab \tab \tab if(AddSwanSPFamily(1)==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount-=2;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check random value
\par \tab \tab \tab \tab \tab switch(abs(GetRandomInt())%4)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab case(0):
\par \tab \tab \tab \tab \tab \tab // add single swan
\par \tab \tab \tab \tab \tab \tab if(AddSwanLoner()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount--;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab case(1):
\par \tab \tab \tab \tab \tab \tab // add swan couple
\par \tab \tab \tab \tab \tab \tab if(AddSwanCouple()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount-=2;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab case(2):
\par \tab \tab \tab \tab \tab \tab // get random number of baby swans
\par \tab \tab \tab \tab \tab \tab dwNumBBSwans=(abs(GetRandomInt())%3)+1;
\par 
\par \tab \tab \tab \tab \tab \tab // clip value as needed
\par \tab \tab \tab \tab \tab \tab if((dwCount-1)<dwNumBBSwans)
\par \tab \tab \tab \tab \tab \tab \tab dwNumBBSwans=dwCount-1;
\par 
\par \tab \tab \tab \tab \tab \tab // add single swan with babies
\par \tab \tab \tab \tab \tab \tab if(AddSwanSPFamily(dwNumBBSwans)==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount-=dwNumBBSwans+1;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab default:
\par \tab \tab \tab \tab \tab \tab // get random number of baby swans
\par \tab \tab \tab \tab \tab \tab dwNumBBSwans=(abs(GetRandomInt())%4)+2;
\par 
\par \tab \tab \tab \tab \tab \tab // clip value as needed
\par \tab \tab \tab \tab \tab \tab if((dwCount-2)<dwNumBBSwans)
\par \tab \tab \tab \tab \tab \tab \tab dwNumBBSwans=dwCount-2;
\par 
\par \tab \tab \tab \tab \tab \tab // add swan couple with babies
\par \tab \tab \tab \tab \tab \tab if(AddSwanDPFamily(dwNumBBSwans)==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount-=dwNumBBSwans+2;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // add swans
\par \tab \tab \tab while(dwCount)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check counter
\par \tab \tab \tab \tab if(dwCount==1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // add single swan
\par \tab \tab \tab \tab \tab if(AddSwanLoner()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab dwCount--;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // check random value
\par \tab \tab \tab \tab \tab switch(abs(GetRandomInt())%2)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab case(0):
\par \tab \tab \tab \tab \tab \tab // add single swan
\par \tab \tab \tab \tab \tab \tab if(AddSwanLoner()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount--;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab default:
\par \tab \tab \tab \tab \tab \tab // add swan couple
\par \tab \tab \tab \tab \tab \tab if(AddSwanCouple()==NO_OBJECT)
\par \tab \tab \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab \tab \tab dwCount-=2;
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // set phantom swan flag
\par \tab \tab g_bPhantomSwan=TRUE;
\par 
\par \tab \tab // add swan loner
\par \tab \tab AddSwanLoner();
\par \tab \}
\par 
\par \tab // add turtles
\par \tab for(dwCount=0;dwCount<g_dwSceneNumTurtles;dwCount++)
\par \tab \tab if(AddTurtle()==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab // set counter to number of dragonflies
\par \tab dwCount=g_dwSceneNumDFlies;
\par 
\par \tab // add dragonflies
\par \tab while(dwCount)
\par \tab \{
\par \tab \tab // check counter
\par \tab \tab if(dwCount==1)
\par \tab \tab \{
\par \tab \tab \tab // add single dragonfly
\par \tab \tab \tab if(AddDragonflyLoner()==NO_OBJECT)
\par \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab // update counter
\par \tab \tab \tab dwCount--;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // check random value
\par \tab \tab \tab switch(abs(GetRandomInt())%2)
\par \tab \tab \tab \{
\par \tab \tab \tab case(0):
\par \tab \tab \tab \tab // add single dragonfly
\par \tab \tab \tab \tab if(AddDragonflyLoner()==NO_OBJECT)
\par \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab dwCount--;
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par \tab \tab \tab default:
\par \tab \tab \tab \tab // add dragonfly couple
\par \tab \tab \tab \tab if(AddDragonflyCouple()==NO_OBJECT)
\par \tab \tab \tab \tab \tab return(FALSE);
\par 
\par \tab \tab \tab \tab // update counter
\par \tab \tab \tab \tab dwCount-=2;
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // add fish
\par \tab for(dwCount=0;dwCount<g_dwSceneNumFish;dwCount++)
\par \tab \tab if(AddFish()==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab // add birds
\par \tab for(dwCount=0;dwCount<g_dwSceneNumBirds;dwCount++)
\par \tab \tab if(AddBird()==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // SwanLakeProcessMessage()
\par 
\par BOOL SwanLakeProcessMessage(DWORD dwMsg,
\par \tab \tab \tab \tab \tab \tab \tab LPVOID lpData)
\par \{
\par \tab // check message
\par \tab switch(dwMsg)
\par \tab \{
\par \tab // toggle frame rate display
\par \tab case(MSG_TOGGLEFRAMERATE):
\par 
\par \tab \tab // toggle flag
\par \tab \tab if(g_bFrameRate)
\par \tab \tab \tab g_bFrameRate=FALSE;
\par \tab \tab else
\par \tab \tab \tab g_bFrameRate=TRUE;
\par 
\par \tab \tab // ok
\par \tab \tab return(TRUE);
\par 
\par \tab // toggle high-speed mode
\par \tab case(MSG_TOGGLESPEEDMODE):
\par 
\par \tab \tab // toggle flag
\par \tab \tab if(g_bSpeedMode)
\par \tab \tab \tab g_bSpeedMode=FALSE;
\par \tab \tab else
\par \tab \tab \tab g_bSpeedMode=TRUE;
\par 
\par \tab \tab // ok
\par \tab \tab return(TRUE);
\par \tab \}
\par 
\par \tab // message not found
\par \tab return(FALSE);
\par \}
\par 
\par // SwanLakeSetDataPath()
\par 
\par BOOL SwanLakeSetDataPath(void)
\par \{
\par \tab LoadingOutput("SwanLakeSetDataPath");
\par 
\par \tab // check registry for path
\par \tab LPSTR lpPath=GetSystemWideRegistryKey("InstallPath");
\par \tab if(!lpPath)
\par \tab \{
\par \tab \tab // display message box
\par \tab \tab DisplayInfoMessage("Installation path could not be found in the system registry.\\n\\n"
\par \tab \tab \tab \tab \tab \tab    "Please run the setup program again.");
\par 
\par \tab \tab // no good
\par \tab \tab return(FALSE);
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // copy value
\par \tab \tab strcpy(g_lpMsg,
\par \tab \tab \tab    lpPath);
\par 
\par \tab \tab // free key value
\par \tab \tab FreeRegistryKey(lpPath);
\par \tab \}
\par 
\par \tab // set data path
\par \tab if(!SetDataPathAbs((LPCSTR)g_lpMsg,
\par \tab \tab \tab \tab \tab    TRUE))
\par \tab \{
\par \tab \tab // display message box
\par \tab \tab DisplayInfoMessage("The installation path is invalid.\\n\\n"
\par \tab \tab \tab \tab \tab \tab    "Please run the setup program again.");
\par 
\par \tab \tab // no good
\par \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitClockDigits()
\par 
\par BOOL InitClockDigits(void)
\par \{
\par \tab LoadingOutput("InitClockDigits");
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[0]=AddTexture("clock0.jpg");
\par \tab if(g_dwClockDigit[0]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[1]=AddTexture("clock1.jpg");
\par \tab if(g_dwClockDigit[1]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[2]=AddTexture("clock2.jpg");
\par \tab if(g_dwClockDigit[2]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[3]=AddTexture("clock3.jpg");
\par \tab if(g_dwClockDigit[3]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[4]=AddTexture("clock4.jpg");
\par \tab if(g_dwClockDigit[4]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[5]=AddTexture("clock5.jpg");
\par \tab if(g_dwClockDigit[5]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[6]=AddTexture("clock6.jpg");
\par \tab if(g_dwClockDigit[6]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[7]=AddTexture("clock7.jpg");
\par \tab if(g_dwClockDigit[7]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[8]=AddTexture("clock8.jpg");
\par \tab if(g_dwClockDigit[8]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockDigit[9]=AddTexture("clock9.jpg");
\par \tab if(g_dwClockDigit[9]==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockAM=AddTexture("clockam.jpg");
\par \tab if(g_dwClockAM==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockPM=AddTexture("clockpm.jpg");
\par \tab if(g_dwClockPM==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // load & check texture
\par \tab g_dwClockColon=AddTexture("clockcln.jpg");
\par \tab if(g_dwClockColon==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // RenderClock()
\par 
\par void RenderClock(void)
\par \{
\par \tab // clock sizes
\par \tab #define CLOCK_DIGITH 16
\par \tab #define CLOCK_DIGITW 12
\par \tab #define CLOCK_COLONW 8
\par \tab #define CLOCK_AMPMW  16
\par 
\par \tab // clock color
\par \tab #define CLOCK_COLOR D3DCOLOR_COLORVALUE(1,1,0.8F,0.8F)
\par 
\par \tab // system time structure
\par \tab static SYSTEMTIME st;
\par 
\par \tab // am flag
\par \tab BOOL bAM;
\par 
\par \tab // hour value
\par \tab WORD wHour;
\par 
\par \tab // digit values
\par \tab DWORD dwH1;
\par \tab DWORD dwH2;
\par \tab DWORD dwM1;
\par \tab DWORD dwM2;
\par \tab DWORD dwS1;
\par \tab DWORD dwS2;
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // get local time if necessary
\par \tab if(!g_bNagScreen)
\par \tab \tab GetLocalTime(&st);
\par #else
\par \tab // get local time
\par \tab GetLocalTime(&st);
\par #endif
\par 
\par \tab // copy hour value
\par \tab wHour=st.wHour;
\par \tab 
\par \tab // check am/pm
\par \tab if(wHour<12)
\par \tab \{
\par \tab \tab // set am flag
\par \tab \tab bAM=TRUE;
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // reset am flag
\par \tab \tab bAM=FALSE;
\par 
\par \tab \tab // adjust hour
\par \tab \tab wHour-=12;
\par \tab \}
\par 
\par \tab // fix for 12:00
\par \tab if(wHour==0)
\par \tab \tab wHour=12;
\par 
\par \tab // extract digits
\par \tab dwH1=(DWORD)(((float)(wHour))/10.0F);
\par \tab dwM1=(DWORD)(((float)(st.wMinute))/10.0F);
\par \tab dwS1=(DWORD)(((float)(st.wSecond))/10.0F);
\par \tab dwH2=wHour-(dwH1*10);
\par \tab dwM2=st.wMinute-(dwM1*10);
\par \tab dwS2=st.wSecond-(dwS1*10);
\par 
\par \tab // begin sprite output
\par \tab if(BeginShadedSprites(g_bTexSmooth))
\par \tab \{
\par \tab \tab // output hour digit #1
\par \tab \tab OutputShadedSprite(g_dwClockDigit[dwH1],
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW*5)-(CLOCK_COLONW*2)-(CLOCK_DIGITW/2)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_DIGITW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output hour digit #2
\par \tab \tab OutputShadedSprite(g_dwClockDigit[dwH2],
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW*4)-(CLOCK_COLONW*2)-(CLOCK_DIGITW/2)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_DIGITW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output colon #1
\par \tab \tab OutputShadedSprite(g_dwClockColon,
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW*4)-(CLOCK_COLONW/2)-(CLOCK_COLONW)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_COLONW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par \tab \tab 
\par \tab \tab // output minute digit #1
\par \tab \tab OutputShadedSprite(g_dwClockDigit[dwM1],
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW*3)-(CLOCK_COLONW)-(CLOCK_DIGITW/2)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_DIGITW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output minute digit #2
\par \tab \tab OutputShadedSprite(g_dwClockDigit[dwM2],
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW*2)-(CLOCK_COLONW)-(CLOCK_DIGITW/2)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_DIGITW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output colon #2
\par \tab \tab OutputShadedSprite(g_dwClockColon,
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW*2)-(CLOCK_COLONW/2)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_COLONW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output second digit #1
\par \tab \tab OutputShadedSprite(g_dwClockDigit[dwS1],
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW/2)-(CLOCK_DIGITW)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_DIGITW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output second digit #2
\par \tab \tab OutputShadedSprite(g_dwClockDigit[dwS2],
\par \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW)-(CLOCK_DIGITW/2)),
\par \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_DIGITW),
\par \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par 
\par \tab \tab // output am/pm
\par \tab \tab if(bAM)
\par \tab \tab \{
\par \tab \tab \tab // output am
\par \tab \tab \tab OutputShadedSprite(g_dwClockAM,
\par \tab \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW/2)),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_AMPMW),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // output pm
\par \tab \tab \tab OutputShadedSprite(g_dwClockPM,
\par \tab \tab \tab \tab \tab \tab \tab    CLOCK_COLOR,
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoordX(636-(CLOCK_AMPMW/2)),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoordY(476-(CLOCK_DIGITH/2)),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSizeX(CLOCK_AMPMW),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSizeY(CLOCK_DIGITH));
\par \tab \tab \}
\par 
\par \tab \tab // end sprite output
\par \tab \tab EndSprites();
\par \tab \}
\par \}
\par 
\par // GetResoltionWidth()
\par 
\par DWORD GetResolutionWidth(LPSTR lpText)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // copy of text
\par \tab LPSTR lpCopy;
\par 
\par \tab // return value
\par \tab DWORD dwRet;
\par 
\par \tab // allocate memory for text
\par \tab if(!AllocMem((LPVOID*)&lpCopy,
\par \tab \tab \tab \tab  strlen(lpText)+1))
\par \tab \tab return(0);
\par 
\par \tab // copy string
\par \tab strcpy(lpCopy,
\par \tab \tab    lpText);
\par 
\par \tab // end string at 'x'
\par \tab for(dwCount=0;dwCount<strlen(lpCopy);dwCount++)
\par \tab \tab if(lpCopy[dwCount]=='x')
\par \tab \tab \tab lpCopy[dwCount]=0;
\par 
\par \tab // convert value\tab 
\par \tab dwRet=(DWORD)atoi(lpCopy);
\par 
\par \tab // free copy of text
\par \tab FreeMem((LPVOID*)&lpCopy);
\par 
\par \tab // return value
\par \tab return(dwRet);
\par \}
\par 
\par // GetResolutionHeight()
\par 
\par DWORD GetResolutionHeight(LPSTR lpText)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // copy of text
\par \tab LPSTR lpCopy;
\par 
\par \tab // return value
\par \tab DWORD dwRet;
\par 
\par \tab // allocate memory for text
\par \tab if(!AllocMem((LPVOID*)&lpCopy,
\par \tab \tab \tab \tab  strlen(lpText)+1))
\par \tab \tab return(0);
\par 
\par \tab // copy string
\par \tab strcpy(lpCopy,
\par \tab \tab    lpText);
\par 
\par \tab // replace with '0' to 'x'
\par \tab for(dwCount=0;dwCount<strlen(lpCopy);dwCount++)
\par \tab \tab if(lpCopy[dwCount]=='x')
\par \tab \tab \{
\par \tab \tab \tab // set value
\par \tab \tab \tab lpCopy[dwCount]='0';
\par 
\par \tab \tab \tab // end loop
\par \tab \tab \tab dwCount=strlen(lpCopy);
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \tab lpCopy[dwCount]='0';
\par 
\par \tab // convert value\tab 
\par \tab dwRet=(DWORD)atoi(lpCopy);
\par 
\par \tab // free copy of text
\par \tab FreeMem((LPVOID*)&lpCopy);
\par 
\par \tab // return value
\par \tab return(dwRet);
\par \}
\par 
\par // SwanLakeConfigure()
\par 
\par void SwanLakeConfigure(HWND hParentWnd)
\par \{
\par \tab LoadingOutput("SwanLakeConfigure");
\par 
\par \tab // validate window handle
\par \tab if(hParentWnd==INVALID_HANDLE_VALUE)
\par \tab \tab hParentWnd=GetDesktopWindow();
\par 
\par \tab // verify current installation
\par \tab if(!VerifyDirectXVersion())
\par \tab \tab return;
\par 
\par \tab // set data path
\par \tab if(!SwanLakeSetDataPath())
\par \tab \tab return;
\par 
\par // this section must be after SetDataPath!
\par #ifdef SHAREWARE_MODE
\par \tab // get days left
\par \tab g_dwTrialDays=GetTrialDaysRemaining();
\par #else
\par \tab // reset leftover timestamps
\par \tab ResetTimeStamps();
\par #endif
\par 
\par \tab // load options
\par \tab if(!SwanLakeLoadOptions())
\par \tab \tab DisplayErrorMessage("Unable to load application options.",
\par \tab \tab \tab \tab \tab \tab \tab NULL,
\par \tab \tab \tab \tab \tab \tab \tab FALSE);
\par 
\par \tab // add dialog boxes
\par \tab g_dwConfigDlg=AddDialogFromResource(IDD_CONFIGDIALOG);
\par \tab g_dwAboutDlg=AddDialogFromResource(IDD_ABOUTDIALOG);
\par #ifdef SHAREWARE_MODE
\par \tab g_dwPurchaseDlg=AddDialogFromResource(IDD_PURCHDIALOG);
\par #endif
\par 
\par \tab // check for errors
\par \tab if(g_dwConfigDlg==NO_OBJECT)
\par \tab \tab return;
\par \tab if(g_dwAboutDlg==NO_OBJECT)
\par \tab \tab return;
\par #ifdef SHAREWARE_MODE
\par \tab if(g_dwPurchaseDlg==NO_OBJECT)
\par \tab \tab return;
\par #endif
\par 
\par #ifdef SHAREWARE_MODE
\par \tab // check days remaining
\par \tab if(g_dwTrialDays)
\par \tab \{
\par \tab \tab // execute config dialog box
\par \tab \tab ExecuteDialog(g_dwConfigDlg,
\par \tab \tab \tab \tab \tab   SwanLakeConfigDlgProc,
\par \tab \tab \tab \tab \tab   hParentWnd);
\par 
\par \tab \tab // save options
\par \tab \tab if(!SwanLakeSaveOptions())
\par \tab \tab \tab DisplayErrorMessage("Unable to save application options.",
\par \tab \tab \tab \tab \tab \tab \tab \tab NULL,
\par \tab \tab \tab \tab \tab \tab \tab \tab FALSE);
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // play sound
\par \tab \tab MessageBeep(MB_ICONHAND);
\par \tab \tab 
\par \tab \tab // execute purchase dialog box
\par \tab \tab ExecuteDialog(g_dwPurchaseDlg,
\par \tab \tab \tab \tab \tab   SwanLakePurchaseDlgProc,
\par \tab \tab \tab \tab \tab   hParentWnd);
\par \tab \}
\par #else
\par \tab // execute config dialog box
\par \tab ExecuteDialog(g_dwConfigDlg,
\par \tab \tab \tab \tab   SwanLakeConfigDlgProc,
\par \tab \tab \tab \tab   hParentWnd);
\par 
\par \tab // save options
\par \tab if(!SwanLakeSaveOptions())
\par \tab \tab DisplayErrorMessage("Unable to save application options.",
\par \tab \tab \tab \tab \tab \tab \tab NULL,
\par \tab \tab \tab \tab \tab \tab \tab FALSE);
\par #endif
\par 
\par \tab // purge dialog boxes
\par \tab PurgeDialogs();
\par \}
\par 
\par // SwanLakeLoadOptions()
\par 
\par BOOL SwanLakeLoadOptions(void)
\par \{
\par \tab LoadingOutput("SwanLakeLoadOptions");
\par 
\par \tab // get graphics options
\par \tab g_dwHorzRes=  (DWORD)GetRegistryConfigValue(CFG_XRES_KEY,CFG_XRES_MIN,CFG_XRES_MAX,CFG_XRES_DEF);
\par \tab g_dwVertRes=  (DWORD)GetRegistryConfigValue(CFG_YRES_KEY,CFG_YRES_MIN,CFG_YRES_MAX,CFG_YRES_DEF);
\par \tab g_bTexSmooth=  (BOOL)GetRegistryConfigValue(CFG_STEX_KEY,CFG_STEX_MIN,CFG_STEX_MAX,CFG_STEX_DEF);
\par \tab g_bShadeSmooth=(BOOL)GetRegistryConfigValue(CFG_SSHD_KEY,CFG_SSHD_MIN,CFG_SSHD_MAX,CFG_SSHD_DEF);
\par 
\par \tab // get audio options
\par \tab g_bUseMusic=  (BOOL)GetRegistryConfigValue(CFG_MUSIC_KEY,CFG_MUSIC_MIN,CFG_MUSIC_MAX,CFG_MUSIC_DEF);
\par \tab g_bUseSFX=    (BOOL)GetRegistryConfigValue(CFG_SOUND_KEY,CFG_SOUND_MIN,CFG_SOUND_MAX,CFG_SOUND_DEF);
\par \tab g_bUse3DSound=(BOOL)GetRegistryConfigValue(CFG_3DSND_KEY,CFG_3DSND_MIN,CFG_3DSND_MAX,CFG_3DSND_DEF);
\par \tab g_fMasterVol=   ((float)GetRegistryConfigValue(CFG_MVOL_KEY,CFG_MVOL_MIN,CFG_MVOL_MAX,CFG_MVOL_DEF))/100.0F;
\par \tab g_fPrimaryVol=  ((float)GetRegistryConfigValue(CFG_PVOL_KEY,CFG_PVOL_MIN,CFG_PVOL_MAX,CFG_PVOL_DEF))/100.0F;
\par \tab g_fSecondaryVol=((float)GetRegistryConfigValue(CFG_SVOL_KEY,CFG_SVOL_MIN,CFG_SVOL_MAX,CFG_SVOL_DEF))/100.0F;
\par 
\par \tab // get environment options
\par \tab g_dwSceneNumSwans=  (DWORD)GetRegistryConfigValue(CFG_NUMSWANS_KEY,  CFG_NUMSWANS_MIN,  CFG_NUMSWANS_MAX,  CFG_NUMSWANS_DEF);
\par \tab g_dwSceneNumTurtles=(DWORD)GetRegistryConfigValue(CFG_NUMTURTLES_KEY,CFG_NUMTURTLES_MIN,CFG_NUMTURTLES_MAX,CFG_NUMTURTLES_DEF);
\par \tab g_dwSceneNumDFlies= (DWORD)GetRegistryConfigValue(CFG_NUMDFLIES_KEY, CFG_NUMDFLIES_MIN, CFG_NUMDFLIES_MAX, CFG_NUMDFLIES_DEF);
\par \tab g_dwSceneNumFish=   (DWORD)GetRegistryConfigValue(CFG_NUMFISH_KEY,   CFG_NUMFISH_MIN,   CFG_NUMFISH_MAX,   CFG_NUMFISH_DEF);
\par \tab g_dwSceneNumBirds=  (DWORD)GetRegistryConfigValue(CFG_NUMBIRDS_KEY,  CFG_NUMBIRDS_MIN,  CFG_NUMBIRDS_MAX,  CFG_NUMBIRDS_DEF);
\par \tab g_bFogMode=      (BOOL)GetRegistryConfigValue(CFG_FOG_KEY,    CFG_FOG_MIN,    CFG_FOG_MAX,    CFG_FOG_DEF);
\par \tab g_bLensFlareMode=(BOOL)GetRegistryConfigValue(CFG_LFLARE_KEY, CFG_LFLARE_MIN, CFG_LFLARE_MAX, CFG_LFLARE_DEF);
\par \tab g_bUseRipples=   (BOOL)GetRegistryConfigValue(CFG_RIPPLES_KEY,CFG_RIPPLES_MIN,CFG_RIPPLES_MAX,CFG_RIPPLES_DEF);
\par \tab g_bShowClock=    (BOOL)GetRegistryConfigValue(CFG_CLOCK_KEY,  CFG_CLOCK_MIN,  CFG_CLOCK_MAX,  CFG_CLOCK_DEF);
\par 
\par \tab // get advanced options
\par \tab g_bPriorityMode=(BOOL)GetRegistryConfigValue(CFG_PRIORITY_KEY, CFG_PRIORITY_MIN, CFG_PRIORITY_MAX, CFG_PRIORITY_DEF);
\par \tab g_dwBufferCnt= (DWORD)GetRegistryConfigValue(CFG_BUFFERCNT_KEY,CFG_BUFFERCNT_MIN,CFG_BUFFERCNT_MAX,CFG_BUFFERCNT_DEF);
\par 
\par \tab // set hidden options
\par \tab g_bSceneBBSwans=TRUE;
\par \tab g_bTerrainHiRes=TRUE;
\par \tab g_bFrameRate=FALSE;
\par \tab g_bSpeedMode=FALSE;
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // SwanLakeSaveOptions()
\par 
\par BOOL SwanLakeSaveOptions(void)
\par \{
\par \tab LoadingOutput("SwanLakeSaveOptions");
\par 
\par \tab // set graphics options
\par \tab SetRegistryConfigValue(CFG_XRES_KEY,(int)g_dwHorzRes);
\par \tab SetRegistryConfigValue(CFG_YRES_KEY,(int)g_dwVertRes);
\par \tab SetRegistryConfigValue(CFG_STEX_KEY,(int)g_bTexSmooth);
\par \tab SetRegistryConfigValue(CFG_SSHD_KEY,(int)g_bShadeSmooth);
\par 
\par \tab // set audio options
\par \tab SetRegistryConfigValue(CFG_MUSIC_KEY,(int)g_bUseMusic);
\par \tab SetRegistryConfigValue(CFG_SOUND_KEY,(int)g_bUseSFX);
\par \tab SetRegistryConfigValue(CFG_3DSND_KEY,(int)g_bUse3DSound);
\par \tab SetRegistryConfigValue(CFG_MVOL_KEY,(int)((g_fMasterVol*100.0F)+0.5F));
\par \tab SetRegistryConfigValue(CFG_PVOL_KEY,(int)((g_fPrimaryVol*100.0F)+0.5F));
\par \tab SetRegistryConfigValue(CFG_SVOL_KEY,(int)((g_fSecondaryVol*100.0F)+0.5F));
\par 
\par \tab // set environment options
\par \tab SetRegistryConfigValue(CFG_NUMSWANS_KEY,  (int)g_dwSceneNumSwans);
\par \tab SetRegistryConfigValue(CFG_NUMTURTLES_KEY,(int)g_dwSceneNumTurtles);
\par \tab SetRegistryConfigValue(CFG_NUMDFLIES_KEY, (int)g_dwSceneNumDFlies);
\par \tab SetRegistryConfigValue(CFG_NUMFISH_KEY,   (int)g_dwSceneNumFish);
\par \tab SetRegistryConfigValue(CFG_NUMBIRDS_KEY,  (int)g_dwSceneNumBirds);
\par \tab SetRegistryConfigValue(CFG_FOG_KEY,    (int)g_bFogMode);
\par \tab SetRegistryConfigValue(CFG_LFLARE_KEY, (int)g_bLensFlareMode);
\par \tab SetRegistryConfigValue(CFG_RIPPLES_KEY,(int)g_bUseRipples);
\par \tab SetRegistryConfigValue(CFG_CLOCK_KEY,  (int)g_bShowClock);
\par 
\par \tab // set advanced options
\par \tab SetRegistryConfigValue(CFG_PRIORITY_KEY, (int)g_bPriorityMode);
\par \tab SetRegistryConfigValue(CFG_BUFFERCNT_KEY,(int)g_dwBufferCnt);
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // SwanLakeConfigDlgProc()
\par 
\par BOOL APIENTRY SwanLakeConfigDlgProc(HWND hDlg,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab UINT Msg,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab WPARAM wParam,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab LPARAM lParam)
\par \{
\par \tab // resolutions list
\par \tab static RESOLUTIONS res;
\par 
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // logo button image handle
\par \tab static HBITMAP hLogo=(HBITMAP)INVALID_HANDLE_VALUE;
\par 
\par \tab // pointer to draw item structure
\par \tab LPDRAWITEMSTRUCT lpdis;
\par 
\par \tab // device context
\par \tab HDC hDC;
\par 
\par \tab // edit control values
\par \tab long lCurVal;
\par \tab long lMinEdit;
\par \tab long lMaxEdit;
\par \tab LPSTR lpEditErrTxt;
\par 
\par \tab // scroll bar values
\par \tab int nScrollCode;
\par \tab int nScrollPos;
\par \tab HWND hScroll;
\par 
\par \tab // check message
\par \tab switch(Msg)
\par \tab \{
\par \tab // init dialog box
\par \tab case(WM_INITDIALOG):
\par 
\par \tab \tab // set dialog box as current
\par \tab \tab SetCurrentDialogBox(hDlg);
\par 
\par \tab \tab // get available resolutions
\par \tab \tab if(!GetAvailableResolutions(&res))
\par \tab \tab \{
\par \tab \tab \tab // end dialog box
\par \tab \tab \tab EndDialog(hDlg,NULL);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par \tab \tab \}
\par 
\par \tab \tab // init creature values
\par \tab \tab SetCurrentDialogEditLong(IDC_NUMSWANS,  (long)g_dwSceneNumSwans);
\par \tab \tab SetCurrentDialogEditLong(IDC_NUMTURTLES,(long)g_dwSceneNumTurtles);
\par \tab \tab SetCurrentDialogEditLong(IDC_NUMDFLIES, (long)g_dwSceneNumDFlies);
\par \tab \tab SetCurrentDialogEditLong(IDC_NUMFISH,   (long)g_dwSceneNumFish);
\par \tab \tab SetCurrentDialogEditLong(IDC_NUMBIRDS,  (long)g_dwSceneNumBirds);
\par 
\par \tab \tab // init environment values
\par \tab \tab SetCurrentDialogCheckBox(IDC_FOGHAZE,   g_bFogMode);
\par \tab \tab SetCurrentDialogCheckBox(IDC_LENSFLARES,g_bLensFlareMode);
\par \tab \tab SetCurrentDialogCheckBox(IDC_RIPPLES,   g_bUseRipples);
\par \tab \tab SetCurrentDialogCheckBox(IDC_CLOCK,     g_bShowClock);
\par 
\par \tab \tab // init resolution list
\par \tab \tab for(dwCount=0;dwCount<res.dwNumRes;dwCount++)
\par \tab \tab \{
\par \tab \tab \tab // format string
\par \tab \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab \tab "%dx%d",
\par \tab \tab \tab \tab \tab res.lpRes[dwCount].dwX,
\par \tab \tab \tab \tab \tab res.lpRes[dwCount].dwY);
\par 
\par \tab \tab \tab // add to list
\par \tab \tab \tab AddCurrentDialogDropDownSelection(IDC_RESOLUTIONS,g_lpMsg);
\par \tab \tab \}
\par 
\par \tab \tab // format string for current selection
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "%dx%d",
\par \tab \tab \tab \tab g_dwHorzRes,
\par \tab \tab \tab \tab g_dwVertRes);
\par 
\par \tab \tab // highlight current selection
\par \tab \tab if(!HighlightCurrentDialogDropDownSelection(IDC_RESOLUTIONS,g_lpMsg))
\par \tab \tab \{
\par \tab \tab \tab // set defult selection on failure
\par \tab \tab \tab HighlightCurrentDialogDropDownSelection(IDC_RESOLUTIONS,CFG_RES_DEF);
\par \tab \tab \}
\par 
\par \tab \tab // init graphics values
\par \tab \tab SetCurrentDialogCheckBox(IDC_TEXSMOOTH,  g_bTexSmooth);
\par \tab \tab SetCurrentDialogCheckBox(IDC_SHADESMOOTH,g_bShadeSmooth);
\par \tab \tab 
\par \tab \tab // init audio values
\par \tab \tab SetCurrentDialogCheckBox(IDC_ENABLEMUSIC,g_bUseMusic);
\par \tab \tab SetCurrentDialogCheckBox(IDC_ENABLESOUND,g_bUseSFX);
\par \tab \tab SetCurrentDialogCheckBox(IDC_3DSOUND,    g_bUse3DSound);
\par 
\par \tab \tab // init volume values
\par \tab \tab SetCurrentDialogScrollInfo(IDC_MASTERVOL,CFG_MVOL_MIN,CFG_MVOL_MAX,1,(int)((g_fMasterVol*100.0F)+0.5F));
\par \tab \tab SetCurrentDialogScrollInfo(IDC_MUSICVOL, CFG_PVOL_MIN,CFG_PVOL_MAX,1,(int)((g_fPrimaryVol*100.0F)+0.5F));
\par \tab \tab SetCurrentDialogScrollInfo(IDC_SOUNDVOL, CFG_SVOL_MIN,CFG_SVOL_MAX,1,(int)((g_fSecondaryVol*100.0F)+0.5F));
\par 
\par \tab \tab // init advanced options
\par \tab \tab SetCurrentDialogCheckBox(IDC_PRIORITY,    g_bPriorityMode);
\par \tab \tab if(g_dwBufferCnt==2)
\par \tab \tab \tab SetCurrentDialogCheckBox(IDC_TRIPLEBUFFER,TRUE);
\par \tab \tab else
\par \tab \tab \tab SetCurrentDialogCheckBox(IDC_TRIPLEBUFFER,FALSE);
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab // show purchase button
\par \tab \tab ShowWindow(GetDlgItem(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab \tab   IDC_PURCHASE),
\par \tab \tab \tab \tab    SW_SHOW);
\par #else
\par \tab \tab // hide purchase button
\par \tab \tab ShowWindow(GetDlgItem(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab \tab   IDC_PURCHASE),
\par \tab \tab \tab \tab    SW_HIDE);
\par #endif
\par 
\par \tab \tab // load logo button image
\par \tab \tab hLogo=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab  MAKEINTRESOURCE(IDB_LOGOBUTTON),
\par \tab \tab \tab \tab \tab \tab \tab \tab  IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LOGOA_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LOGOA_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hLogo==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab // get window caption
\par \tab \tab if(GetWindowText(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab  g_lpMsg,
\par \tab \tab \tab \tab \tab \tab  _MAX_PATH))
\par \tab \tab \{
\par \tab \tab \tab // append "trial version" to caption
\par \tab \tab \tab strcat(g_lpMsg," (Trial Version)");
\par 
\par \tab \tab \tab // set new caption
\par \tab \tab \tab SetWindowText(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab   g_lpMsg);
\par \tab \tab \}
\par #endif
\par 
\par \tab \tab // ok
\par \tab \tab return(TRUE);
\par 
\par \tab // window command
\par \tab case(WM_COMMAND):
\par 
\par \tab \tab // check notification message
\par \tab \tab switch(HIWORD(wParam))
\par \tab \tab \{
\par \tab \tab // button clicked
\par \tab \tab case(BN_CLICKED):
\par 
\par \tab \tab \tab // check button id
\par \tab \tab \tab switch(LOWORD(wParam))
\par \tab \tab \tab \{
\par \tab \tab \tab // wavebreak logo
\par \tab \tab \tab case(IDC_OPENABOUT):
\par 
\par \tab \tab \tab \tab // open about dialog
\par \tab \tab \tab \tab ExecuteDialog(g_dwAboutDlg,
\par \tab \tab \tab \tab \tab \tab \tab   SwanLakeAboutDlgProc,
\par \tab \tab \tab \tab \tab \tab \tab   hDlg);
\par 
\par \tab \tab \tab \tab // reset current dialog box
\par \tab \tab \tab \tab SetCurrentDialogBox(hDlg);
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par \tab \tab \tab // reset defaults
\par \tab \tab \tab case(IDC_DEFAULTS):
\par 
\par \tab \tab \tab \tab // copy application name
\par \tab \tab \tab \tab strcpy(g_lpMsg,ApplicationName());
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab \tab \tab // append "trial version" to name
\par \tab \tab \tab \tab strcat(g_lpMsg," (Trial Version)");
\par #endif
\par 
\par \tab \tab \tab \tab // let user verify
\par \tab \tab \tab \tab if(MessageBox(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab \tab   "This will reset all configuration settings back to their original values.\\n\\nAre you sure this is what you want to do?",
\par \tab \tab \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab \tab \tab   MB_YESNO|MB_ICONQUESTION|MB_APPLMODAL)==IDYES)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // reset creature values
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(IDC_NUMSWANS,  CFG_NUMSWANS_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(IDC_NUMTURTLES,CFG_NUMTURTLES_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(IDC_NUMDFLIES, CFG_NUMDFLIES_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(IDC_NUMFISH,   CFG_NUMFISH_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(IDC_NUMBIRDS,  CFG_NUMBIRDS_DEF);
\par 
\par \tab \tab \tab \tab \tab // reset environment values
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_FOGHAZE,   (BOOL)CFG_FOG_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_LENSFLARES,(BOOL)CFG_LFLARE_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_RIPPLES,   (BOOL)CFG_RIPPLES_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_CLOCK,     (BOOL)CFG_CLOCK_DEF);
\par 
\par \tab \tab \tab \tab \tab // reset defult selection on failure
\par \tab \tab \tab \tab \tab HighlightCurrentDialogDropDownSelection(IDC_RESOLUTIONS,CFG_RES_DEF);
\par 
\par \tab \tab \tab \tab \tab // reset graphics values
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_TEXSMOOTH,  (BOOL)CFG_STEX_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_SHADESMOOTH,(BOOL)CFG_SSHD_DEF);
\par \tab \tab \tab \tab \tab 
\par \tab \tab \tab \tab \tab // reset audio values
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_ENABLEMUSIC,(BOOL)CFG_MUSIC_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_ENABLESOUND,(BOOL)CFG_SOUND_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_3DSOUND,    (BOOL)CFG_3DSND_DEF);
\par 
\par \tab \tab \tab \tab \tab // reset volume values
\par \tab \tab \tab \tab \tab SetCurrentDialogScrollInfo(IDC_MASTERVOL,CFG_MVOL_MIN,CFG_MVOL_MAX,1,CFG_MVOL_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogScrollInfo(IDC_MUSICVOL, CFG_PVOL_MIN,CFG_PVOL_MAX,1,CFG_PVOL_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogScrollInfo(IDC_SOUNDVOL, CFG_SVOL_MIN,CFG_SVOL_MAX,1,CFG_SVOL_DEF);
\par 
\par \tab \tab \tab \tab \tab // reset advanced options
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_PRIORITY,    (BOOL)CFG_PRIORITY_DEF);
\par \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_TRIPLEBUFFER,FALSE);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab \tab // purchase
\par \tab \tab \tab case(IDC_PURCHASE):
\par 
\par \tab \tab \tab \tab // open purchase dialog
\par \tab \tab \tab \tab ExecuteDialog(g_dwPurchaseDlg,
\par \tab \tab \tab \tab \tab \tab \tab   SwanLakePurchaseDlgProc,
\par \tab \tab \tab \tab \tab \tab \tab   hDlg);
\par 
\par \tab \tab \tab \tab // reset current dialog box
\par \tab \tab \tab \tab SetCurrentDialogBox(hDlg);
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par #endif
\par 
\par \tab \tab \tab // help
\par \tab \tab \tab case(HIDC_HELP):
\par 
\par \tab \tab \tab \tab // open help file
\par \tab \tab \tab \tab OpenExternalDoc("swanlake.chm");
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab case(IDOK):
\par 
\par \tab \tab \tab \tab // copy application name
\par \tab \tab \tab \tab strcpy(g_lpMsg,ApplicationName());
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab \tab \tab // append "trial version" to name
\par \tab \tab \tab \tab strcat(g_lpMsg," (Trial Version)");
\par #endif
\par 
\par \tab \tab \tab \tab // check for priority mode
\par \tab \tab \tab \tab if(GetCurrentDialogCheckBox(IDC_PRIORITY))
\par \tab \tab \tab \tab \tab if(MessageBox(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab \tab \tab   "You have chosen to run this application in priority mode. This setting may cause problems with some background programs (including audio playback) and will slow down a
ny networking operations (such as shared printers and Internet connections) that run through this computer. (See the help file for more information.)\\n\\nAre you sure you want to keep this setting?",
\par \tab \tab \tab \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab \tab \tab \tab   MB_YESNO|MB_ICONQUESTION|MB_APPLMODAL)==IDNO)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // reset box
\par \tab \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_PRIORITY,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab return(TRUE);
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // check for triple buffer
\par \tab \tab \tab \tab if(GetCurrentDialogCheckBox(IDC_TRIPLEBUFFER))
\par \tab \tab \tab \tab \tab if(MessageBox(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab \tab \tab   "You have chosen to use triple display buffering. Depending on your system configuration, this setting may cause the application to stop working properly. (See the help file for more information.)\\n\\
nAre you sure you want to keep this setting?",
\par \tab \tab \tab \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab \tab \tab \tab   MB_YESNO|MB_ICONQUESTION|MB_APPLMODAL)==IDNO)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab // reset box
\par \tab \tab \tab \tab \tab \tab SetCurrentDialogCheckBox(IDC_TRIPLEBUFFER,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  FALSE);
\par 
\par \tab \tab \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab \tab \tab return(TRUE);
\par \tab \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // save creature values
\par \tab \tab \tab \tab g_dwSceneNumSwans  =GetCurrentDialogEditLong(IDC_NUMSWANS);
\par \tab \tab \tab \tab g_dwSceneNumTurtles=GetCurrentDialogEditLong(IDC_NUMTURTLES);
\par \tab \tab \tab \tab g_dwSceneNumDFlies =GetCurrentDialogEditLong(IDC_NUMDFLIES);
\par \tab \tab \tab \tab g_dwSceneNumFish   =GetCurrentDialogEditLong(IDC_NUMFISH);
\par \tab \tab \tab \tab g_dwSceneNumBirds  =GetCurrentDialogEditLong(IDC_NUMBIRDS);
\par 
\par \tab \tab \tab \tab // save environment values
\par \tab \tab \tab \tab g_bFogMode      =GetCurrentDialogCheckBox(IDC_FOGHAZE);
\par \tab \tab \tab \tab g_bLensFlareMode=GetCurrentDialogCheckBox(IDC_LENSFLARES);
\par \tab \tab \tab \tab g_bUseRipples   =GetCurrentDialogCheckBox(IDC_RIPPLES);
\par \tab \tab \tab \tab g_bShowClock    =GetCurrentDialogCheckBox(IDC_CLOCK);
\par 
\par \tab \tab \tab \tab // save resolution string
\par \tab \tab \tab \tab GetCurrentDialogDropDownSelection(IDC_RESOLUTIONS,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab   g_lpMsg);
\par 
\par \tab \tab \tab \tab // extract resolution values
\par \tab \tab \tab \tab g_dwHorzRes=GetResolutionWidth(g_lpMsg);
\par \tab \tab \tab \tab g_dwVertRes=GetResolutionHeight(g_lpMsg);
\par 
\par \tab \tab \tab \tab // save graphics values
\par \tab \tab \tab \tab g_bTexSmooth  =GetCurrentDialogCheckBox(IDC_TEXSMOOTH);
\par \tab \tab \tab \tab g_bShadeSmooth=GetCurrentDialogCheckBox(IDC_SHADESMOOTH);
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // save audio values
\par \tab \tab \tab \tab g_bUseMusic  =GetCurrentDialogCheckBox(IDC_ENABLEMUSIC);
\par \tab \tab \tab \tab g_bUseSFX    =GetCurrentDialogCheckBox(IDC_ENABLESOUND);
\par \tab \tab \tab \tab g_bUse3DSound=GetCurrentDialogCheckBox(IDC_3DSOUND);
\par 
\par \tab \tab \tab \tab // save volume values
\par \tab \tab \tab \tab g_fMasterVol=   ((float)GetCurrentDialogScrollPos(IDC_MASTERVOL))/100.0F;
\par \tab \tab \tab \tab g_fPrimaryVol=  ((float)GetCurrentDialogScrollPos(IDC_MUSICVOL))/100.0F;
\par \tab \tab \tab \tab g_fSecondaryVol=((float)GetCurrentDialogScrollPos(IDC_SOUNDVOL))/100.0F;
\par 
\par \tab \tab \tab \tab // save advanced options
\par \tab \tab \tab \tab g_bPriorityMode=GetCurrentDialogCheckBox(IDC_PRIORITY);
\par \tab \tab \tab \tab if(GetCurrentDialogCheckBox(IDC_TRIPLEBUFFER))
\par \tab \tab \tab \tab \tab g_dwBufferCnt=2;
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab g_dwBufferCnt=1;
\par 
\par \tab \tab \tab \tab // fall through to "cancel" for cleanup 
\par 
\par \tab \tab \tab // cancel
\par \tab \tab \tab case(IDCANCEL):
\par 
\par \tab \tab \tab \tab // delete logo button image
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hLogo))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // release available resolutions
\par \tab \tab \tab \tab ReleaseAvailableResolutions(&res);
\par 
\par \tab \tab \tab \tab // end dialog box
\par \tab \tab \tab \tab EndDialog(hDlg,NULL);
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par 
\par \tab \tab // edit control change
\par \tab \tab case(EN_CHANGE):
\par \tab \tab \tab 
\par \tab \tab \tab // check edit control id
\par \tab \tab \tab switch(LOWORD(wParam))
\par \tab \tab \tab \{
\par \tab \tab \tab // number of swans
\par \tab \tab \tab case(IDC_NUMSWANS):
\par 
\par \tab \tab \tab \tab // set data
\par \tab \tab \tab \tab lMinEdit=CFG_NUMSWANS_MIN;
\par \tab \tab \tab \tab lMaxEdit=CFG_NUMSWANS_MAX;
\par \tab \tab \tab \tab lpEditErrTxt=(LPSTR)"Number of Swans";
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab // number of turtles
\par \tab \tab \tab case(IDC_NUMTURTLES):
\par 
\par \tab \tab \tab \tab // set data
\par \tab \tab \tab \tab lMinEdit=CFG_NUMTURTLES_MIN;
\par \tab \tab \tab \tab lMaxEdit=CFG_NUMTURTLES_MAX;
\par \tab \tab \tab \tab lpEditErrTxt=(LPSTR)"Number of Turtles";
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab // number of dragonfiles
\par \tab \tab \tab case(IDC_NUMDFLIES):
\par 
\par \tab \tab \tab \tab // set data
\par \tab \tab \tab \tab lMinEdit=CFG_NUMDFLIES_MIN;
\par \tab \tab \tab \tab lMaxEdit=CFG_NUMDFLIES_MAX;
\par \tab \tab \tab \tab lpEditErrTxt=(LPSTR)"Number of Dragonflies";
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab // number of fish
\par \tab \tab \tab case(IDC_NUMFISH):
\par 
\par \tab \tab \tab \tab // set data
\par \tab \tab \tab \tab lMinEdit=CFG_NUMFISH_MIN;
\par \tab \tab \tab \tab lMaxEdit=CFG_NUMFISH_MAX;
\par \tab \tab \tab \tab lpEditErrTxt=(LPSTR)"Number of Fish";
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par 
\par \tab \tab \tab // number of birds
\par \tab \tab \tab case(IDC_NUMBIRDS):
\par 
\par \tab \tab \tab \tab // set data
\par \tab \tab \tab \tab lMinEdit=CFG_NUMBIRDS_MIN;
\par \tab \tab \tab \tab lMaxEdit=CFG_NUMBIRDS_MAX;
\par \tab \tab \tab \tab lpEditErrTxt=(LPSTR)"Number of Eagles";
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab break;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // get current value
\par \tab \tab \tab lCurVal=GetCurrentDialogEditLong(LOWORD(wParam));
\par 
\par \tab \tab \tab // check value
\par \tab \tab \tab if(lCurVal<lMinEdit||
\par \tab \tab \tab    lCurVal>lMaxEdit)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // message string
\par \tab \tab \tab \tab char lpMsg[128];
\par 
\par \tab \tab \tab \tab // prepare message
\par \tab \tab \tab \tab sprintf(lpMsg,
\par \tab \tab \tab \tab \tab \tab "%s: Please enter a value from %d to %d.",
\par \tab \tab \tab \tab \tab \tab lpEditErrTxt,
\par \tab \tab \tab \tab \tab \tab lMinEdit,
\par \tab \tab \tab \tab \tab \tab lMaxEdit);
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // copy application name
\par \tab \tab \tab \tab strcpy(g_lpMsg,ApplicationName());
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab \tab \tab // append "trial version" to name
\par \tab \tab \tab \tab strcat(g_lpMsg," (Trial Version)");
\par #endif
\par 
\par \tab \tab \tab \tab // display message
\par \tab \tab \tab \tab MessageBox(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab    lpMsg,
\par \tab \tab \tab \tab \tab \tab    g_lpMsg,
\par \tab \tab \tab \tab \tab \tab    MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL|MB_SETFOREGROUND);
\par 
\par \tab \tab \tab \tab // reset value
\par \tab \tab \tab \tab if(lCurVal<lMinEdit)
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(LOWORD(wParam),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  lMinEdit);
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab SetCurrentDialogEditLong(LOWORD(wParam),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  lMaxEdit);
\par 
\par \tab \tab \tab \tab // highlight text
\par \tab \tab \tab \tab HighlightCurrentDialogEditText(LOWORD(wParam));
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par 
\par \tab \tab // focus lost
\par \tab \tab case(EN_KILLFOCUS):
\par 
\par \tab \tab \tab // if value is empty, set to 0
\par \tab \tab \tab if(!GetCurrentDialogEditText(LOWORD(wParam),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  g_lpMsg,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  _MAX_PATH))
\par \tab \tab \tab \tab SetCurrentDialogEditLong(LOWORD(wParam),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  0);
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // scroll bar message
\par \tab case(WM_HSCROLL):
\par 
\par \tab \tab // extract data
\par \tab \tab nScrollCode=(int)LOWORD(wParam);
\par \tab \tab nScrollPos=(int)HIWORD(wParam);
\par \tab \tab hScroll=(HWND)lParam;
\par 
\par \tab \tab // check scroll code
\par \tab \tab switch(nScrollCode)
\par \tab \tab \{
\par \tab \tab case(SB_LINELEFT):      UpdateScrollBarPos(hScroll,-1);      break;
\par \tab \tab case(SB_LINERIGHT):     UpdateScrollBarPos(hScroll,1);       break;
\par \tab \tab case(SB_PAGELEFT):      UpdateScrollBarPos(hScroll,-10);     break;
\par \tab \tab case(SB_PAGERIGHT):     UpdateScrollBarPos(hScroll,10);      break;
\par \tab \tab case(SB_THUMBPOSITION): SetScrollBarPos(hScroll,nScrollPos); break;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab return(TRUE);
\par 
\par \tab // draw item
\par \tab case(WM_DRAWITEM):
\par 
\par \tab \tab // cast pointer to draw item info
\par \tab \tab lpdis=(LPDRAWITEMSTRUCT)lParam;
\par 
\par \tab \tab // check for logo button
\par \tab \tab if(wParam==IDC_WAVEBREAK)
\par \tab \tab \{
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hLogo)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select object
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  (HGDIOBJ)hLogo);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    LOGOA_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    LOGOA_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // let windows handle it
\par \tab return(FALSE);
\par \}
\par 
\par // SwanLakeAboutDlgProc()
\par 
\par BOOL APIENTRY SwanLakeAboutDlgProc(HWND hDlg,
\par \tab \tab \tab \tab \tab \tab \tab \tab    UINT Msg,
\par \tab \tab \tab \tab \tab \tab \tab \tab    WPARAM wParam,
\par \tab \tab \tab \tab \tab \tab \tab \tab    LPARAM lParam)
\par \{
\par \tab // image handles
\par \tab static HBITMAP hIcon=   (HBITMAP)INVALID_HANDLE_VALUE;
\par \tab static HBITMAP hLogo=   (HBITMAP)INVALID_HANDLE_VALUE;
\par \tab static HBITMAP hASPLogo=(HBITMAP)INVALID_HANDLE_VALUE;
\par 
\par \tab // pointer to draw item structure
\par \tab LPDRAWITEMSTRUCT lpdis;
\par 
\par \tab // device context
\par \tab HDC hDC;
\par 
\par \tab // check message
\par \tab switch(Msg)
\par \tab \{
\par \tab // init dialog box
\par \tab case(WM_INITDIALOG):
\par 
\par \tab \tab // set dialog box as current
\par \tab \tab SetCurrentDialogBox(hDlg);
\par 
\par \tab \tab // load icon image
\par \tab \tab hIcon=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab  MAKEINTRESOURCE(IDB_APPICONIMAGE),
\par \tab \tab \tab \tab \tab \tab \tab \tab  IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab  32,32,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hIcon==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // load logo image
\par \tab \tab hLogo=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab  MAKEINTRESOURCE(IDB_LOGOBUTTON2),
\par \tab \tab \tab \tab \tab \tab \tab \tab  IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LOGOB_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LOGOB_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hLogo==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // load ASP logo image
\par \tab \tab hASPLogo=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab     MAKEINTRESOURCE(IDB_ASPLOGO),
\par \tab \tab \tab \tab \tab \tab \tab \tab     IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab     LOGOC_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab     LOGOC_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab     LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hASPLogo==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par #ifdef SHAREWARE_MODE
\par \tab \tab // get window caption
\par \tab \tab if(GetWindowText(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab  g_lpMsg,
\par \tab \tab \tab \tab \tab \tab  _MAX_PATH))
\par \tab \tab \{
\par \tab \tab \tab // append "trial version" to caption
\par \tab \tab \tab strcat(g_lpMsg," (Trial Version)");
\par 
\par \tab \tab \tab // set new caption
\par \tab \tab \tab SetWindowText(g_hCurrDlg,
\par \tab \tab \tab \tab \tab \tab   g_lpMsg);
\par \tab \tab \}
\par #endif
\par 
\par \tab \tab // ok
\par \tab \tab return(TRUE);
\par 
\par \tab // window command
\par \tab case(WM_COMMAND):
\par 
\par \tab \tab // check notification message
\par \tab \tab switch(HIWORD(wParam))
\par \tab \tab \{
\par \tab \tab // button clicked
\par \tab \tab case(BN_CLICKED):
\par 
\par \tab \tab \tab // check button id
\par \tab \tab \tab switch(LOWORD(wParam))
\par \tab \tab \tab \{
\par \tab \tab \tab // visit homepage
\par \tab \tab \tab case(IDC_HOMEPAGE):
\par 
\par \tab \tab \tab \tab // open homepage
\par \tab \tab \tab \tab OpenExternalDoc("http://www.wavebreaksoftware.com");
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par \tab \tab \tab // visit homepage
\par \tab \tab \tab case(IDC_ASPBUTTON):
\par 
\par \tab \tab \tab \tab // open ASP homepage
\par \tab \tab \tab \tab OpenExternalDoc("http://www.asp-shareware.org");
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par \tab \tab \tab // view license
\par \tab \tab \tab case(IDC_LICENSE):
\par 
\par \tab \tab \tab \tab // open license file
\par \tab \tab \tab \tab OpenExternalDoc("license.txt");
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par \tab \tab \tab // view readme
\par \tab \tab \tab case(IDC_README):
\par 
\par \tab \tab \tab \tab // open readme file
\par \tab \tab \tab \tab OpenExternalDoc("readme.txt");
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par 
\par \tab \tab \tab // ok & cancel
\par \tab \tab \tab case(IDOK):
\par \tab \tab \tab case(IDCANCEL):
\par 
\par \tab \tab \tab \tab // delete icon image
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hIcon))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // delete logo button image
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hLogo))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // delete ASP logo image
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hASPLogo))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // end dialog box
\par \tab \tab \tab \tab EndDialog(hDlg,NULL);
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // draw item
\par \tab case(WM_DRAWITEM):
\par 
\par \tab \tab // cast pointer to draw item info
\par \tab \tab lpdis=(LPDRAWITEMSTRUCT)lParam;
\par 
\par \tab \tab // check id
\par \tab \tab switch(wParam)
\par \tab \tab \{
\par \tab \tab // swan lake icon
\par \tab \tab case(IDC_SWANLAKEICON):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hIcon)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select image
\par \tab \tab \tab \tab \tab SelectObject(hDC,(HGDIOBJ)hIcon);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    32,32,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par 
\par \tab \tab // wavebreak logo
\par \tab \tab case(IDC_HOMEPAGE):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hLogo)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select image
\par \tab \tab \tab \tab \tab SelectObject(hDC,(HGDIOBJ)hLogo);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    LOGOB_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    LOGOB_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par 
\par \tab \tab // ASP logo
\par \tab \tab case(IDC_ASPBUTTON):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hLogo)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select image
\par \tab \tab \tab \tab \tab SelectObject(hDC,(HGDIOBJ)hASPLogo);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    LOGOC_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    LOGOC_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // let windows handle it
\par \tab return(FALSE);
\par \}
\par 
\par #ifdef SHAREWARE_MODE
\par // SwanLakePurchaseDlgProc()
\par 
\par BOOL APIENTRY SwanLakePurchaseDlgProc(HWND hDlg,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab   UINT Msg,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab   WPARAM wParam,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab   LPARAM lParam)
\par \{
\par \tab // image handles
\par \tab static HBITMAP hDays  =(HBITMAP)INVALID_HANDLE_VALUE;
\par \tab static HBITMAP hCards1=(HBITMAP)INVALID_HANDLE_VALUE;
\par \tab static HBITMAP hCards2=(HBITMAP)INVALID_HANDLE_VALUE;
\par \tab static HBITMAP hLogo  =(HBITMAP)INVALID_HANDLE_VALUE;
\par 
\par \tab // font handle
\par \tab static HFONT hFont=(HFONT)INVALID_HANDLE_VALUE;
\par 
\par \tab // pointer to draw item structure
\par \tab LPDRAWITEMSTRUCT lpdis;
\par 
\par \tab // device context
\par \tab HDC hDC;
\par 
\par \tab // message box text
\par \tab LPSTR lpMsgBoxTxt=NULL;
\par 
\par \tab // check message
\par \tab switch(Msg)
\par \tab \{
\par \tab // init dialog box
\par \tab case(WM_INITDIALOG):
\par 
\par \tab \tab // set dialog box as current
\par \tab \tab SetCurrentDialogBox(hDlg);
\par 
\par \tab \tab // check days left
\par \tab \tab if(g_dwTrialDays>0)
\par \tab \tab \{
\par \tab \tab \tab // load days-left image
\par \tab \tab \tab hDays=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  MAKEINTRESOURCE(IDB_DAYSLEFT),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  DAYSLEFT_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  DAYSLEFT_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  LR_DEFAULTCOLOR);
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // load expired image
\par \tab \tab \tab hDays=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  MAKEINTRESOURCE(IDB_EXPIRED),
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  DAYSLEFT_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  DAYSLEFT_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  LR_DEFAULTCOLOR);
\par \tab \tab \}
\par 
\par \tab \tab // check for error
\par \tab \tab if(hDays==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // load cards image #1
\par \tab \tab hCards1=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab    MAKEINTRESOURCE(IDB_CCARDS1),
\par \tab \tab \tab \tab \tab \tab \tab \tab    IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab    LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hCards1==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // load cards image #2
\par \tab \tab hCards2=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab    MAKEINTRESOURCE(IDB_CCARDS2),
\par \tab \tab \tab \tab \tab \tab \tab \tab    IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab    LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hCards2==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // load Swan Lake logo image
\par \tab \tab hLogo=(HBITMAP)LoadImage(g_hInst,
\par \tab \tab \tab \tab \tab \tab \tab \tab  MAKEINTRESOURCE(IDB_LOGOBUTTON3),
\par \tab \tab \tab \tab \tab \tab \tab \tab  IMAGE_BITMAP,
\par \tab \tab \tab \tab \tab \tab \tab \tab  SWANLAKE_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab \tab  SWANLAKE_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab \tab  LR_DEFAULTCOLOR);
\par 
\par \tab \tab // check for error
\par \tab \tab if(hLogo==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load image.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // create font
\par \tab \tab hFont=CreateFont(18,0,
\par \tab \tab \tab \tab \tab \tab  0,0,
\par \tab \tab \tab \tab \tab \tab  FW_HEAVY,
\par \tab \tab \tab \tab \tab \tab  FALSE,
\par \tab \tab \tab \tab \tab \tab  FALSE,
\par \tab \tab \tab \tab \tab \tab  FALSE,
\par \tab \tab \tab \tab \tab \tab  ANSI_CHARSET,
\par \tab \tab \tab \tab \tab \tab  NULL,
\par \tab \tab \tab \tab \tab \tab  NULL,
\par \tab \tab \tab \tab \tab \tab  NULL,
\par \tab \tab \tab \tab \tab \tab  NULL,
\par \tab \tab \tab \tab \tab \tab  "Courier");
\par 
\par \tab \tab // check for error
\par \tab \tab if(hFont==NULL)
\par \tab \tab \tab DisplayErrorMessage("Failed to load font.");
\par \tab \tab else
\par \tab \tab \tab AddWinResource;
\par 
\par \tab \tab // ok
\par \tab \tab return(TRUE);
\par 
\par \tab // window command
\par \tab case(WM_COMMAND):
\par 
\par \tab \tab // check notification message
\par \tab \tab switch(HIWORD(wParam))
\par \tab \tab \{
\par \tab \tab // button clicked
\par \tab \tab case(BN_CLICKED):
\par 
\par \tab \tab \tab // check button id
\par \tab \tab \tab switch(LOWORD(wParam))
\par \tab \tab \tab \{
\par \tab \tab \tab // order forms
\par \tab \tab \tab case(IDC_ORDERNOW):
\par \tab \tab \tab case(IDC_VIEWFORM):
\par 
\par \tab \tab \tab \tab // check form
\par \tab \tab \tab \tab if(LOWORD(wParam)==IDC_ORDERNOW)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // open order page
\par \tab \tab \tab \tab \tab OpenExternalDoc("http://www.wavebreaksoftware.com/swanlake.htm");
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else if(LOWORD(wParam)==IDC_VIEWFORM)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // open order form
\par \tab \tab \tab \tab \tab OpenExternalDoc("order.txt");
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // fall through to close
\par \tab \tab \tab \tab 
\par \tab \tab \tab // ok & cancel
\par \tab \tab \tab case(IDOK):
\par \tab \tab \tab case(IDCANCEL):
\par 
\par \tab \tab \tab \tab // delete days-left image
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hDays))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // delete cards image #1
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hCards1))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // delete cards image #2
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hCards2))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // delete Swan Lake logo image
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hLogo))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // delete days-left font
\par \tab \tab \tab \tab if(DeleteObject((HGDIOBJ)hFont))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par 
\par \tab \tab \tab \tab // end dialog box
\par \tab \tab \tab \tab EndDialog(hDlg,NULL);
\par 
\par \tab \tab \tab \tab // ok
\par \tab \tab \tab \tab return(TRUE);
\par \tab \tab \tab \}
\par \tab \tab \tab 
\par \tab \tab \tab // ok
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab // draw item
\par \tab case(WM_DRAWITEM):
\par 
\par \tab \tab // cast pointer to draw item info
\par \tab \tab lpdis=(LPDRAWITEMSTRUCT)lParam;
\par 
\par \tab \tab // check for days-left button
\par \tab \tab switch(wParam)
\par \tab \tab \{
\par \tab \tab // days-left image
\par \tab \tab case(IDC_DAYSLEFT):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hDays)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select object
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  (HGDIOBJ)hDays);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    DAYSLEFT_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    DAYSLEFT_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check days left
\par \tab \tab \tab if(g_dwTrialDays>0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // select font
\par \tab \tab \tab \tab SelectObject(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab  (HGDIOBJ)hFont);
\par 
\par \tab \tab \tab \tab // set text color
\par \tab \tab \tab \tab if(g_dwTrialDays<=TRIALDAYS_WARN)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set red color
\par \tab \tab \tab \tab \tab SetTextColor(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  RGB(160,0,0));
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // set green color
\par \tab \tab \tab \tab \tab SetTextColor(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  RGB(0,144,0));
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // set background color
\par \tab \tab \tab \tab SetBkColor(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab    RGB(239,235,222));
\par \tab \tab \tab \tab 
\par \tab \tab \tab \tab // prepare text
\par \tab \tab \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab \tab \tab "%02d",
\par \tab \tab \tab \tab \tab \tab g_dwTrialDays);
\par 
\par \tab \tab \tab \tab // output text
\par \tab \tab \tab \tab TextOut(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab 76,6,
\par \tab \tab \tab \tab \tab \tab g_lpMsg,
\par \tab \tab \tab \tab \tab \tab strlen(g_lpMsg));
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par 
\par \tab \tab // cards image #1
\par \tab \tab case(IDC_CARDS1):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hCards1)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select object
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  (HGDIOBJ)hCards1);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par 
\par \tab \tab // cards image #2
\par \tab \tab case(IDC_CARDS2):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hCards2)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select object
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  (HGDIOBJ)hCards2);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    CCARDS_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par 
\par \tab \tab // Swan Lake logo image
\par \tab \tab case(IDC_SLLOGO):
\par 
\par \tab \tab \tab // create device context
\par \tab \tab \tab hDC=CreateCompatibleDC(lpdis->hDC);
\par 
\par \tab \tab \tab // verify handle
\par \tab \tab \tab if(hDC)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add windows resource
\par \tab \tab \tab \tab AddWinResource;
\par 
\par \tab \tab \tab \tab // select bitmap if available
\par \tab \tab \tab \tab if(hDays)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // select object
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  (HGDIOBJ)hLogo);
\par 
\par \tab \tab \tab \tab \tab // output image
\par \tab \tab \tab \tab \tab StretchBlt(lpdis->hDC,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.right-lpdis->rcItem.left,
\par \tab \tab \tab \tab \tab \tab \tab    lpdis->rcItem.bottom-lpdis->rcItem.top,
\par \tab \tab \tab \tab \tab \tab \tab    hDC,
\par \tab \tab \tab \tab \tab \tab \tab    0,0,
\par \tab \tab \tab \tab \tab \tab \tab    SWANLAKE_BTN_X,
\par \tab \tab \tab \tab \tab \tab \tab    SWANLAKE_BTN_Y,
\par \tab \tab \tab \tab \tab \tab \tab    SRCCOPY);
\par 
\par \tab \tab \tab \tab \tab // de-select bitmap
\par \tab \tab \tab \tab \tab SelectObject(hDC,
\par \tab \tab \tab \tab \tab \tab \tab \tab  NULL);
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab \tab \tab // delete device context
\par \tab \tab \tab \tab if(DeleteDC(hDC))
\par \tab \tab \tab \tab \tab RemoveWinResource;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // ok
\par \tab \tab \tab return(TRUE);
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // let windows handle it
\par \tab return(FALSE);
\par \}
\par 
\par // SwanLakeExecutePurchaseDlg()
\par 
\par BOOL SwanLakeExecutePurchaseDlg(void)
\par \{
\par \tab // set data path
\par \tab if(!SwanLakeSetDataPath())
\par \tab \tab return(FALSE);
\par \tab 
\par // this section must be after SetDataPath!
\par #ifdef SHAREWARE_MODE
\par \tab // get days left
\par \tab g_dwTrialDays=GetTrialDaysRemaining();
\par #else
\par \tab // reset leftover timestamps
\par \tab ResetTimeStamps();
\par #endif
\par 
\par \tab // add dialog box
\par \tab DWORD dwDlg=AddDialogFromResource(IDD_PURCHDIALOG);
\par 
\par \tab // check for error
\par \tab if(dwDlg==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // execute dialog box
\par \tab ExecuteDialog(dwDlg,
\par \tab \tab \tab \tab   SwanLakePurchaseDlgProc,
\par \tab \tab \tab \tab   GetDesktopWindow());
\par 
\par \tab // purge dialog boxes
\par \tab PurgeDialogs();
\par 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // InitNagScreen()
\par 
\par BOOL InitNagScreen(void)
\par \{
\par \tab // load main texture
\par \tab if(g_dwTrialDays>TRIALDAYS_WARN)
\par \tab \tab g_dwNagMain=AddTexture("n_thanks.jpg");
\par \tab else if(g_dwTrialDays>0)
\par \tab \tab g_dwNagMain=AddTexture("n_expsn.jpg");
\par \tab else
\par \tab \tab g_dwNagMain=AddTexture("n_expd.jpg");
\par 
\par \tab // load remaining textures
\par \tab g_dwNagTFlash   =AddTexture("n_tflash.jpg");
\par \tab g_dwNagClose    =AddTexture("n_close.jpg");
\par \tab g_dwNagRedX     =AddTexture("n_redx.jpg");
\par \tab g_dwNagDigits[0]=AddTexture("n_digit0.jpg");
\par \tab g_dwNagDigits[1]=AddTexture("n_digit1.jpg");
\par \tab g_dwNagDigits[2]=AddTexture("n_digit2.jpg");
\par \tab g_dwNagDigits[3]=AddTexture("n_digit3.jpg");
\par \tab g_dwNagDigits[4]=AddTexture("n_digit4.jpg");
\par \tab g_dwNagDigits[5]=AddTexture("n_digit5.jpg");
\par \tab g_dwNagDigits[6]=AddTexture("n_digit6.jpg");
\par \tab g_dwNagDigits[7]=AddTexture("n_digit7.jpg");
\par \tab g_dwNagDigits[8]=AddTexture("n_digit8.jpg");
\par \tab g_dwNagDigits[9]=AddTexture("n_digit9.jpg");
\par \tab g_dwNagCursor   =AddTexture("n_cursor.dds");
\par \tab g_dwNagBlank    =AddTexture("n_blank.bmp");
\par 
\par \tab // check for errors
\par \tab if(g_dwNagMain     ==NO_OBJECT||
\par \tab    g_dwNagClose    ==NO_OBJECT||
\par \tab    g_dwNagRedX     ==NO_OBJECT||
\par \tab    g_dwNagDigits[0]==NO_OBJECT||
\par \tab    g_dwNagDigits[1]==NO_OBJECT||
\par \tab    g_dwNagDigits[2]==NO_OBJECT||
\par \tab    g_dwNagDigits[3]==NO_OBJECT||
\par \tab    g_dwNagDigits[4]==NO_OBJECT||
\par \tab    g_dwNagDigits[5]==NO_OBJECT||
\par \tab    g_dwNagDigits[6]==NO_OBJECT||
\par \tab    g_dwNagDigits[7]==NO_OBJECT||
\par \tab    g_dwNagDigits[8]==NO_OBJECT||
\par \tab    g_dwNagDigits[9]==NO_OBJECT||
\par \tab    g_dwNagCursor   ==NO_OBJECT||
\par \tab    g_dwNagBlank    ==NO_OBJECT)
\par \tab \tab return(FALSE);
\par 
\par \tab // check sound flag
\par \tab if(g_bUseSFX)
\par \tab \{
\par \tab \tab // load nag sound
\par \tab \tab g_dwNagSnd=AddAudioSegment("n_chord1.wav");
\par 
\par \tab \tab // check for error
\par \tab \tab if(g_dwNagSnd==NO_OBJECT)
\par \tab \tab \tab return(FALSE);
\par \tab \}
\par 
\par \tab // set maximum values
\par \tab if(g_dwTrialDays==TRIALDAYS_MAX)
\par \tab \{
\par \tab \tab g_dwNagFreqMax =NAG_FREQ1;
\par \tab \tab g_dwNagDelayMax=NAG_DELAY1;
\par \tab \}
\par \tab else if(g_dwTrialDays>TRIALDAYS_WARN)
\par \tab \{
\par \tab \tab g_dwNagFreqMax =NAG_FREQ2;
\par \tab \tab g_dwNagDelayMax=NAG_DELAY2;
\par \tab \}
\par \tab else if(g_dwTrialDays>0)
\par \tab \{
\par \tab \tab g_dwNagFreqMax =NAG_FREQ3;
\par \tab \tab g_dwNagDelayMax=NAG_DELAY3;
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab g_dwNagFreqMax =NAG_FREQ4;
\par \tab \tab g_dwNagDelayMax=NAG_DELAY4;
\par \tab \}
\par \tab 
\par \tab // reset active flag
\par \tab g_bNagScreen=FALSE;
\par 
\par \tab // reset frequency counter
\par \tab if(g_dwTrialDays==0)
\par \tab \tab g_dwNagFreqCur=g_dwNagFreqMax;
\par \tab else
\par \tab \tab g_dwNagFreqCur=0;
\par \tab 
\par \tab // ok
\par \tab return(TRUE);
\par \}
\par 
\par // UpdateNagScreen()
\par 
\par void UpdateNagScreen(void)
\par \{
\par \tab // check active flag
\par \tab if(g_bNagScreen)
\par \tab \{
\par \tab \tab // check delay value
\par \tab \tab if(g_dwNagDelayCur!=0)
\par \tab \tab \{
\par \tab \tab \tab // update counter
\par \tab \tab \tab g_dwNagDelayCur--;
\par 
\par \tab \tab \tab // check value
\par \tab \tab \tab if(g_dwNagDelayCur==0)
\par \tab \tab \tab \tab CloseNagScreen();
\par 
\par \tab \tab \tab // check pre-close flag
\par \tab \tab \tab if(g_bPreClose)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // allow 1/4 sec for fade-in
\par \tab \tab \tab \tab if(g_dwNagAnimPos>15)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // reset delay value
\par \tab \tab \tab \tab \tab g_dwNagDelayCur=0;
\par 
\par \tab \tab \tab \tab \tab // allow immediate close
\par \tab \tab \tab \tab \tab CloseNagScreen();
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab // update animation counter
\par \tab \tab g_dwNagAnimPos++;
\par 
\par \tab \tab // check pre-close flag
\par \tab \tab if(g_bPreClose)
\par \tab \tab \{
\par \tab \tab \tab // enable mouse if necessary
\par \tab \tab \tab if(!g_bMouseCursor)
\par \tab \tab \tab \tab EnableMouseCursor(g_dwNagCursor,
\par \tab \tab \tab \tab \tab \tab \tab \tab   -4,-11,
\par \tab \tab \tab \tab \tab \tab \tab \tab   ScrSize(32,32));
\par \tab \tab \tab 
\par \tab \tab \tab // method below is faulty
\par \tab \tab \tab /*
\par \tab \tab \tab // cursor flag
\par \tab \tab \tab static BOOL bCursor=FALSE;
\par 
\par \tab \tab \tab // check flag
\par \tab \tab \tab if(!bCursor)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // show system cursor
\par \tab \tab \tab \tab ShowWindowsCursor();
\par 
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bCursor=TRUE;
\par \tab \tab \tab \}
\par \tab \tab \tab */
\par \tab \tab \}
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // update counter
\par \tab \tab g_dwNagFreqCur++;
\par 
\par \tab \tab // check value
\par \tab \tab if(g_dwNagFreqCur>=g_dwNagFreqMax)
\par \tab \tab \tab OpenNagScreen();
\par 
\par \tab \tab // check pre-close flag
\par \tab \tab if(g_bPreClose)
\par \tab \tab \tab OpenNagScreen();
\par \tab \}
\par \}
\par 
\par // OpenNagScreen()
\par 
\par void OpenNagScreen(void)
\par \{
\par \tab // check active flag
\par \tab if(!g_bNagScreen)
\par \tab \{
\par \tab \tab // set active flag
\par \tab \tab g_bNagScreen=TRUE;
\par 
\par \tab \tab // reset delay & position
\par \tab \tab g_dwNagDelayCur=g_dwNagDelayMax;
\par \tab \tab g_dwNagAnimPos =0;
\par 
\par \tab \tab // reset speed mode
\par \tab \tab if(g_bSpeedMode)
\par \tab \tab \tab g_bSpeedMode=FALSE;
\par 
\par \tab \tab // pause audio output
\par \tab \tab PauseAudioOutput();
\par \tab \}
\par \}
\par 
\par // CloseNagScreen()
\par 
\par void CloseNagScreen(void)
\par \{
\par \tab // set closing position
\par \tab g_dwNagAnimPos=NAG_CLOSEVAL;
\par \}
\par 
\par // RenderNagScreen()
\par 
\par void RenderNagScreen(void)
\par \{
\par \tab // alpha value
\par \tab float fAlpha;
\par 
\par \tab // fade-in delay\tab 
\par \tab #define FADEIN_DELAY 8
\par 
\par \tab // sound-played flag
\par \tab static BOOL bSoundPlayed=FALSE;
\par 
\par \tab // title flash flag
\par \tab BOOL bTFlash=FALSE;
\par 
\par \tab // number of seconds
\par \tab DWORD dwSec;
\par 
\par \tab // trial days digits
\par \tab DWORD dwDays1;
\par \tab DWORD dwDays2;
\par 
\par \tab // seconds flash flag
\par \tab BOOL bSFlash=FALSE;
\par 
\par \tab // close flag
\par \tab BOOL bClose=FALSE;
\par 
\par \tab // check animation position
\par \tab if(g_dwNagAnimPos>=NAG_CLOSEVAL)
\par \tab \{
\par \tab \tab // check pre-close flag
\par \tab \tab if(g_bPreClose)
\par \tab \tab \{
\par \tab \tab \tab // reset animation position
\par \tab \tab \tab g_dwNagAnimPos=NAG_CLOSEVAL;
\par 
\par \tab \tab \tab // check for mouse click
\par \tab \tab \tab if(g_bMouseClkL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // check close area
\par \tab \tab \tab \tab if(IsMouseInArea(428,116,444,132))
\par \tab \tab \tab \tab \tab g_bCloseOK=TRUE;
\par 
\par \tab \tab \tab \tab // check purchase area
\par \tab \tab \tab \tab if(IsMouseInArea(199,299,440,323))
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // load purchase page
\par \tab \tab \tab \tab \tab g_bPurchPage=TRUE;
\par 
\par \tab \tab \tab \tab \tab // allow close
\par \tab \tab \tab \tab \tab g_bCloseOK=TRUE;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check for esc key
\par \tab \tab \tab if(IsKeyDown(VK_ESCAPE))
\par \tab \tab \tab \tab g_bCloseOK=TRUE;
\par \tab \tab \tab 
\par \tab \tab \tab // check for enter key
\par \tab \tab \tab if(IsKeyDown(VK_RETURN))
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set purchase page
\par \tab \tab \tab \tab g_bPurchPage=TRUE;
\par 
\par \tab \tab \tab \tab // allow close
\par \tab \tab \tab \tab g_bCloseOK=TRUE;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // check close-ok flag
\par \tab \tab \tab if(g_bCloseOK)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // resume audio output
\par \tab \tab \tab \tab ResumeAudioOutput();
\par 
\par \tab \tab \tab \tab // stop all segments
\par \tab \tab \tab \tab StopAllAudioSegments();
\par 
\par \tab \tab \tab \tab // program will close after this loop
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // set alpha value
\par \tab \tab \tab fAlpha=1.0F;
\par 
\par \tab \tab \tab // inactivity timer
\par \tab \tab \tab static DWORD dwTimer=0;
\par 
\par \tab \tab \tab // check activity flags
\par \tab \tab \tab if(g_bMouseMove||
\par \tab \tab \tab    g_bKeyPress)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // reset timer
\par \tab \tab \tab \tab dwTimer=0;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // increment timer
\par \tab \tab \tab \tab dwTimer+=g_dwFrameSkip;
\par 
\par \tab \tab \tab \tab // check for overflow
\par \tab \tab \tab \tab if(dwTimer>NAG_MAXIDLE)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab // reset pre-close flag
\par \tab \tab \tab \tab \tab g_bPreClose=FALSE;
\par 
\par \tab \tab \tab \tab \tab // disable cursor
\par \tab \tab \tab \tab \tab DisableMouseCursor();
\par 
\par \tab \tab \tab \tab \tab // reset timer
\par \tab \tab \tab \tab \tab dwTimer=0;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // offset animation position
\par \tab \tab \tab DWORD dwAnimPos=g_dwNagAnimPos-NAG_CLOSEVAL;
\par 
\par \tab \tab \tab // check offset position
\par \tab \tab \tab if(dwAnimPos>=FADEIN_DELAY)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set alpha value
\par \tab \tab \tab \tab fAlpha=0.0F;
\par 
\par \tab \tab \tab \tab // reset nag screen flag
\par \tab \tab \tab \tab g_bNagScreen=FALSE;
\par 
\par \tab \tab \tab \tab // reset frequency value
\par \tab \tab \tab \tab g_dwNagFreqCur=0;
\par 
\par \tab \tab \tab \tab // resume audio output
\par \tab \tab \tab \tab ResumeAudioOutput();
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set alpha value
\par \tab \tab \tab \tab fAlpha=1.0F-(((float)dwAnimPos)/((float)FADEIN_DELAY));
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab // check animation position
\par \tab \tab if(g_dwNagAnimPos>=FADEIN_DELAY)
\par \tab \tab \{
\par \tab \tab \tab // set alpha value
\par \tab \tab \tab fAlpha=1.0F;
\par 
\par \tab \tab \tab // check sound-played flag
\par \tab \tab \tab if(!bSoundPlayed)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // play sound if necessary
\par \tab \tab \tab \tab if(g_bUseSFX)
\par \tab \tab \tab \tab \tab PlayAudioSegment(g_dwNagSnd);
\par 
\par \tab \tab \tab \tab // set flag
\par \tab \tab \tab \tab bSoundPlayed=TRUE;
\par \tab \tab \tab \}
\par 
\par \tab \tab \tab // offset animation posisiton
\par \tab \tab \tab DWORD dwAnimPos=g_dwNagAnimPos-FADEIN_DELAY;
\par 
\par \tab \tab \tab // set flash flag if needed
\par \tab \tab \tab if((dwAnimPos>=0 &&dwAnimPos<=4)||
\par \tab \tab \tab    (dwAnimPos>=10&&dwAnimPos<=14))
\par \tab \tab \tab \tab bTFlash=TRUE;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // set alpha value
\par \tab \tab \tab fAlpha=((float)g_dwNagAnimPos)/((float)FADEIN_DELAY);
\par 
\par \tab \tab \tab // reset sound-played flag
\par \tab \tab \tab bSoundPlayed=FALSE;
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // compute number of seconds
\par \tab dwSec=(DWORD)((((float)g_dwNagDelayCur)/60.0F))+1;
\par 
\par \tab // clip number of seconds
\par \tab if(dwSec>9) dwSec=9;
\par 
\par \tab // set seconds flash flag if needed
\par \tab if((g_dwNagDelayCur%60)>35)
\par \tab \tab bSFlash=TRUE;
\par 
\par \tab // extract trial days digits
\par \tab dwDays1=(DWORD)(((float)(g_dwTrialDays))/10.0F);
\par \tab dwDays2=g_dwTrialDays-(dwDays1*10);
\par 
\par \tab // clip trial days digits
\par \tab if(dwDays1>9) dwDays1=9;
\par \tab if(dwDays2>9) dwDays2=9;
\par 
\par \tab // set close flag as needed
\par \tab if(g_dwNagDelayCur==0&&
\par \tab    g_bPreClose)
\par \tab \tab bClose=TRUE;
\par 
\par \tab // enable alpha blend
\par \tab EnableAlphaBlend();
\par \tab 
\par \tab // fade screen
\par \tab FadeScreen(D3DCOLOR_COLORVALUE(0,0,0,(fAlpha*0.5F)-1.0F));
\par 
\par \tab // begin sprite output
\par \tab if(BeginShadedSprites(TRUE))
\par \tab \{
\par \tab \tab // output main window
\par \tab \tab OutputShadedSprite(g_dwNagMain,
\par \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab    ScrCoords(320,240),
\par \tab \tab \tab \tab \tab \tab    ScrSize(256,256));
\par 
\par \tab \tab // output title flash if needed
\par \tab \tab if(bTFlash)
\par \tab \tab \tab OutputShadedSprite(g_dwNagTFlash,
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(320,124),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(256,16));
\par 
\par \tab \tab // check seconds flash flag
\par \tab \tab if(bSFlash)
\par \tab \tab \{
\par \tab \tab \tab // output blank flash
\par \tab \tab \tab OutputShadedSprite(g_dwNagBlank,
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(320,354),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(160,16));
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // output seconds digit
\par \tab \tab \tab OutputShadedSprite(g_dwNagDigits[dwSec],
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(323.8F,352),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(6.5F,10.5F));
\par \tab \tab \}
\par 
\par \tab \tab // check trial days
\par \tab \tab if(g_dwTrialDays)
\par \tab \tab \{
\par \tab \tab \tab // output trial days digit #1
\par \tab \tab \tab OutputShadedSprite(g_dwNagDigits[dwDays1],
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(375,286),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(6.5F,10.5F));
\par 
\par \tab \tab \tab // output trial days digit #2
\par \tab \tab \tab OutputShadedSprite(g_dwNagDigits[dwDays2],
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(382,286),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(6.5F,10.5F));
\par \tab \tab \}
\par 
\par \tab \tab // check close flag
\par \tab \tab if(bClose)
\par \tab \tab \{
\par \tab \tab \tab // output close box
\par \tab \tab \tab OutputShadedSprite(g_dwNagRedX,
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(320,124),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(256,24));
\par 
\par \tab \tab \tab // output close message
\par \tab \tab \tab OutputShadedSprite(g_dwNagClose,
\par \tab \tab \tab \tab \tab \tab \tab    D3DCOLOR_COLORVALUE(1.0F,1.0F,1.0F,fAlpha),
\par \tab \tab \tab \tab \tab \tab \tab    ScrCoords(320,352),
\par \tab \tab \tab \tab \tab \tab \tab    ScrSize(256,32));
\par \tab \tab \}
\par 
\par \tab \tab // end sprite output
\par \tab \tab EndShadedSprites();
\par \tab \}
\par 
\par \tab // disable alpha blend
\par \tab DisableAlphaBlend();
\par \}
\par 
\par // SwanLakeLoadPurchasePage()
\par 
\par BOOL SwanLakeLoadPurchasePage(void)
\par \{
\par \tab // open purchase page
\par \tab return(OpenExternalDoc("http://www.wavebreaksoftware.com/swanlake.htm"));
\par \}
\par 
\par // GetTrialDaysRemaining()
\par 
\par DWORD GetTrialDaysRemaining(void)
\par \{
\par \tab // timestamp locations
\par \tab LPSTR lpTSLoc=NULL;
\par 
\par \tab // individual timestamps
\par \tab TIMESTAMP lpTS[6];
\par 
\par \tab // final timestamp
\par \tab TIMESTAMP ts;
\par 
\par \tab // unique id
\par \tab DWORD dwID=NO_OBJECT;
\par 
\par \tab // allocate memory for locations
\par \tab if(!AllocMem((LPVOID*)&lpTSLoc,
\par \tab \tab \tab \tab  132))
\par \tab \tab return(0);
\par 
\par \tab // get timestamp locations
\par \tab GetTimeStampLocations(lpTSLoc);
\par 
\par \tab // get unique id
\par \tab dwID=GetHDDSerialNumber();
\par 
\par \tab // get timestamps
\par \tab GetTimeStamp(&lpTS[0],0,dwID,lpTSLoc);
\par \tab GetTimeStamp(&lpTS[1],1,dwID,lpTSLoc);
\par \tab GetTimeStamp(&lpTS[2],2,dwID,lpTSLoc);
\par \tab GetTimeStamp(&lpTS[3],3,dwID,lpTSLoc);
\par \tab GetTimeStamp(&lpTS[4],4,dwID,lpTSLoc);
\par \tab GetTimeStamp(&lpTS[5],5,dwID,lpTSLoc);
\par 
\par \tab // reset output timestamp
\par \tab ts.dwDaysLeft=TRIALDAYS_MAX;
\par \tab ts.dwID=dwID;
\par \tab ts.dwInstTimeHigh=NULL;
\par \tab ts.dwInstTimeLow=NULL;
\par 
\par \tab // sort timestamps
\par \tab SortTimeStamps(&ts,lpTS,6);
\par 
\par \tab // save timestamps
\par \tab SetTimeStamp(&ts,0,lpTSLoc);
\par \tab SetTimeStamp(&ts,1,lpTSLoc);
\par \tab SetTimeStamp(&ts,2,lpTSLoc);
\par \tab SetTimeStamp(&ts,3,lpTSLoc);
\par \tab SetTimeStamp(&ts,4,lpTSLoc);
\par \tab SetTimeStamp(&ts,5,lpTSLoc);
\par 
\par \tab // clear timestamp locations
\par \tab ClearTimeStampLocations(lpTSLoc,
\par \tab \tab \tab \tab \tab \tab \tab 132);
\par 
\par \tab // free memory for locations
\par \tab FreeMem((LPVOID*)&lpTSLoc);
\par 
\par \tab // ok
\par \tab return(ts.dwDaysLeft);
\par \}
\par #endif
\par 
\par // GetTimeStampLocations()
\par 
\par void GetTimeStampLocations(LPSTR lpStr)
\par \{
\par \tab // timestamps are located as follows:
\par \tab // (1): (win.ini)  [scr32_snl] sysid=~
\par \tab // (2): bwapps.ini [appcommon] inf32=~
\par \tab // (3): HK_LM/Software/ SLS/ProfileData
\par \tab // (4): HK_LM/Software/ Microsoft/74ABE3D7-BAF5-4ac2-B848-C655118023E5
\par \tab // (5): C:/Windows/     slrcs32.sbw (every other byte starting at #53)
\par \tab // (6): in swanlake.dat
\par 
\par \tab // copy values into string
\par \tab lpStr[39] ='f';
\par \tab lpStr[84] ='a';
\par \tab lpStr[107]='l';
\par \tab lpStr[101]='2';
\par \tab lpStr[90] ='4';
\par \tab lpStr[58] =NULL;
\par \tab lpStr[89] ='8';
\par \tab lpStr[14] ='d';
\par \tab lpStr[126]='.';
\par \tab lpStr[61] ='c';
\par \tab lpStr[36] =NULL;
\par \tab lpStr[80] ='F';
\par \tab lpStr[26] =NULL;
\par \tab lpStr[109]='c';
\par \tab lpStr[16] ='b';
\par \tab lpStr[112]='2';
\par \tab lpStr[85] ='c';
\par \tab lpStr[52] ='l';
\par \tab lpStr[59] ='M';
\par \tab lpStr[34] ='o';
\par \tab lpStr[32] ='m';
\par \tab lpStr[120]='a';
\par \tab lpStr[103]='E';
\par \tab lpStr[44] ='L';
\par \tab lpStr[60] ='i';
\par \tab lpStr[46] ='\\\\';
\par \tab lpStr[127]='d';
\par \tab lpStr[117]=NULL;
\par \tab lpStr[7]  ='n';
\par \tab lpStr[77] ='-';
\par \tab lpStr[21] ='s';
\par \tab lpStr[25] ='i';
\par \tab lpStr[12] ='s';
\par \tab lpStr[78] ='B';
\par \tab lpStr[45] ='S';
\par \tab lpStr[42] =NULL;
\par \tab lpStr[20] ='p';
\par \tab lpStr[88] ='B';
\par \tab lpStr[65] ='o';
\par \tab lpStr[76] ='7';
\par \tab lpStr[111]='3';
\par \tab lpStr[37] ='i';
\par \tab lpStr[106]='s';
\par \tab lpStr[40] ='3';
\par \tab lpStr[69] ='7';
\par \tab lpStr[92] ='-';
\par \tab lpStr[96] ='5';
\par \tab lpStr[43] ='S';
\par \tab lpStr[129]='t';
\par \tab lpStr[33] ='m';
\par \tab lpStr[29] ='p';
\par \tab lpStr[67] ='t';
\par \tab lpStr[95] ='5';
\par \tab lpStr[75] ='D';
\par \tab lpStr[70] ='4';
\par \tab lpStr[98] ='1';
\par \tab lpStr[122]='l';
\par \tab lpStr[99] ='8';
\par \tab lpStr[116]='w';
\par \tab lpStr[41] ='2';
\par \tab lpStr[23] ='i';
\par \tab lpStr[102]='3';
\par \tab lpStr[38] ='n';
\par \tab lpStr[128]='a';
\par \tab lpStr[50] ='f';
\par \tab lpStr[8]  ='l';
\par \tab lpStr[55] ='a';
\par \tab lpStr[79] ='A';
\par \tab lpStr[5]  ='_';
\par \tab lpStr[100]='0';
\par \tab lpStr[118]='s';
\par \tab lpStr[47] ='P';
\par \tab lpStr[94] ='6';
\par \tab lpStr[18] ='a';
\par \tab lpStr[35] ='n';
\par \tab lpStr[2]  ='r';
\par \tab lpStr[87] ='-';
\par \tab lpStr[3]  ='3';
\par \tab lpStr[30] ='c';
\par \tab lpStr[68] ='\\\\';
\par \tab lpStr[1]  ='c';
\par \tab lpStr[51] ='i';
\par \tab lpStr[124]='k';
\par \tab lpStr[123]='a';
\par \tab lpStr[48] ='r';
\par \tab lpStr[6]  ='s';
\par \tab lpStr[19] ='p';
\par \tab lpStr[93] ='C';
\par \tab lpStr[56] ='t';
\par \tab lpStr[22] ='.';
\par \tab lpStr[63] ='o';
\par \tab lpStr[66] ='f';
\par \tab lpStr[71] ='A';
\par \tab lpStr[15] =NULL;
\par \tab lpStr[105]=NULL;
\par \tab lpStr[10] ='s';
\par \tab lpStr[28] ='p';
\par \tab lpStr[27] ='a';
\par \tab lpStr[113]='.';
\par \tab lpStr[130]=NULL;
\par \tab lpStr[86] ='2';
\par \tab lpStr[82] ='-';
\par \tab lpStr[114]='s';
\par \tab lpStr[54] ='D';
\par \tab lpStr[24] ='n';
\par \tab lpStr[83] ='4';
\par \tab lpStr[125]='e';
\par \tab lpStr[53] ='e';
\par \tab lpStr[17] ='w';
\par \tab lpStr[64] ='s';
\par \tab lpStr[81] ='5';
\par \tab lpStr[119]='w';
\par \tab lpStr[49] ='o';
\par \tab lpStr[11] ='y';
\par \tab lpStr[104]='5';
\par \tab lpStr[72] ='B';
\par \tab lpStr[110]='s';
\par \tab lpStr[13] ='i';
\par \tab lpStr[4]  ='2';
\par \tab lpStr[9]  =NULL;
\par \tab lpStr[57] ='a';
\par \tab lpStr[0]  ='s';
\par \tab lpStr[74] ='3';
\par \tab lpStr[91] ='8';
\par \tab lpStr[97] ='1';
\par \tab lpStr[62] ='r';
\par \tab lpStr[31] ='o';
\par \tab lpStr[73] ='E';
\par \tab lpStr[108]='r';
\par \tab lpStr[121]='n';
\par \tab lpStr[115]='b';
\par \tab lpStr[131]=NULL;
\par \}
\par 
\par // ClearTimeStampLocations()
\par 
\par void ClearTimeStampLocations(LPSTR lpStr,
\par \tab \tab \tab \tab \tab \tab \tab  DWORD dwBytes)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // randomize bytes
\par \tab for(dwCount=0;dwCount<dwBytes;dwCount++)
\par \tab \tab lpStr[dwCount]=GetRandomInt()&0xFF;
\par \}
\par 
\par #ifdef SHAREWARE_MODE
\par // SetTimeStamp()
\par 
\par void SetTimeStamp(LPTIMESTAMP lpTS,
\par \tab \tab \tab \tab   DWORD dwLocID,
\par \tab \tab \tab \tab   LPSTR lpTSLoc)
\par \{
\par \tab // timestamps are located as follows:
\par \tab // (1): (win.ini)  [scr32_snl] sysid=~
\par \tab // (2): bwapps.ini [appcommon] inf32=~
\par \tab // (3): HK_LM/Software/ SLS/ProfileData
\par \tab // (4): HK_LM/Software/ Microsoft/74ABE3D7-BAF5-4ac2-B848-C655118023E5
\par \tab // (5): C:/Windows/     slrcs32.sbw (every other byte starting at #53)
\par \tab // (6): in swanlake.dat
\par 
\par \tab // encoded timestamp
\par \tab char lpEnc[33];
\par 
\par \tab // encode timestamp
\par \tab EncodeTimeStamp((*lpTS),
\par \tab \tab \tab \tab \tab lpEnc);
\par 
\par \tab // check location
\par \tab switch(dwLocID)
\par \tab \{
\par \tab case(0):
\par 
\par \tab \tab // save profile string
\par \tab \tab WriteProfileString(GetStringDivision(lpTSLoc,0),
\par \tab \tab \tab \tab \tab \tab    GetStringDivision(lpTSLoc,1),
\par \tab \tab \tab \tab \tab \tab    lpEnc);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(1):
\par 
\par \tab \tab // save private profile string
\par \tab \tab WritePrivateProfileString(GetStringDivision(lpTSLoc,3),
\par \tab \tab \tab \tab \tab \tab \tab \tab   GetStringDivision(lpTSLoc,4),
\par \tab \tab \tab \tab \tab \tab \tab \tab   lpEnc,
\par \tab \tab \tab \tab \tab \tab \tab \tab   GetStringDivision(lpTSLoc,2));
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(2):
\par 
\par \tab \tab // prepare key string
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "%s\\\\%s",
\par \tab \tab \tab \tab "Software",
\par \tab \tab \tab \tab GetStringDivision(lpTSLoc,5));
\par 
\par \tab \tab // set registry value
\par \tab \tab RegSetValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab \tab g_lpMsg,
\par \tab \tab \tab \tab \tab REG_SZ,
\par \tab \tab \tab \tab \tab lpEnc,
\par \tab \tab \tab \tab \tab 32);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(3):
\par \tab \tab 
\par \tab \tab // prepare key string
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "%s\\\\%s",
\par \tab \tab \tab \tab "Software",
\par \tab \tab \tab \tab GetStringDivision(lpTSLoc,6));
\par 
\par \tab \tab // set registry value
\par \tab \tab RegSetValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab \tab g_lpMsg,
\par \tab \tab \tab \tab \tab REG_SZ,
\par \tab \tab \tab \tab \tab lpEnc,
\par \tab \tab \tab \tab \tab 32);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(4):
\par 
\par \tab \tab // set string to file
\par \tab \tab SetTimeStampStringToFile(lpEnc,
\par \tab \tab \tab \tab \tab \tab \tab \tab  GetStringDivision(lpTSLoc,7));
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(5):
\par 
\par \tab \tab // set string to data file
\par \tab \tab SetTimeStampStringToDataFile(lpEnc,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab  GetStringDivision(lpTSLoc,8));
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab \}
\par \}
\par 
\par // GetTimeStamp()
\par 
\par void GetTimeStamp(LPTIMESTAMP lpTS,
\par \tab \tab \tab \tab   DWORD dwLocID,
\par \tab \tab \tab \tab   DWORD dwUniID,
\par \tab \tab \tab \tab   LPSTR lpTSLoc)
\par \{
\par \tab // timestamps are located as follows:
\par \tab // (1): (win.ini)  [scr32_snl] sysid=~
\par \tab // (2): bwapps.ini [appcommon] inf32=~
\par \tab // (3): HK_LM/Software/ SLS/ProfileData
\par \tab // (4): HK_LM/Software/ Microsoft/74ABE3D7-BAF5-4ac2-B848-C655118023E5
\par \tab // (5): C:/Windows/     slrcs32.sbw (every other byte starting at #53)
\par \tab // (6): in swanlake.dat
\par 
\par \tab // encoded timestamp
\par \tab char lpEnc[33];
\par 
\par \tab // set null in case of error
\par \tab lpEnc[0]=NULL;
\par 
\par \tab // data buffer size
\par \tab LONG cbSize;
\par 
\par \tab // check location
\par \tab switch(dwLocID)
\par \tab \{
\par \tab case(0):
\par 
\par \tab \tab // read profile string
\par \tab \tab GetProfileString(GetStringDivision(lpTSLoc,0),
\par \tab \tab \tab \tab \tab \tab  GetStringDivision(lpTSLoc,1),
\par \tab \tab \tab \tab \tab \tab  "q",
\par \tab \tab \tab \tab \tab \tab  lpEnc,
\par \tab \tab \tab \tab \tab \tab  33);
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(1):
\par 
\par \tab \tab // read private profile string
\par \tab \tab GetPrivateProfileString(GetStringDivision(lpTSLoc,3),
\par \tab \tab \tab \tab \tab \tab \tab \tab GetStringDivision(lpTSLoc,4),
\par \tab \tab \tab \tab \tab \tab \tab \tab "w",
\par \tab \tab \tab \tab \tab \tab \tab \tab lpEnc,
\par \tab \tab \tab \tab \tab \tab \tab \tab 33,
\par \tab \tab \tab \tab \tab \tab \tab \tab GetStringDivision(lpTSLoc,2));
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(2):
\par 
\par \tab \tab // prepare key string
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "%s\\\\%s",
\par \tab \tab \tab \tab "Software",
\par \tab \tab \tab \tab GetStringDivision(lpTSLoc,5));
\par 
\par \tab \tab // get size of registry value
\par \tab \tab RegQueryValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab   NULL,
\par \tab \tab \tab \tab \tab   &cbSize);
\par 
\par \tab \tab // check size
\par \tab \tab if(cbSize>33)
\par \tab \tab \{
\par \tab \tab \tab // set default string
\par \tab \tab \tab strcpy(lpEnc,"e");
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // get registry data
\par \tab \tab \tab RegQueryValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab \tab   lpEnc,
\par \tab \tab \tab \tab \tab \tab   &cbSize);
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(3):
\par 
\par \tab \tab // prepare key string
\par \tab \tab sprintf(g_lpMsg,
\par \tab \tab \tab \tab "%s\\\\%s",
\par \tab \tab \tab \tab "Software",
\par \tab \tab \tab \tab GetStringDivision(lpTSLoc,6));
\par 
\par \tab \tab // get size of registry value
\par \tab \tab RegQueryValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab   NULL,
\par \tab \tab \tab \tab \tab   &cbSize);
\par 
\par \tab \tab // check size
\par \tab \tab if(cbSize>33)
\par \tab \tab \{
\par \tab \tab \tab // set default string
\par \tab \tab \tab strcpy(lpEnc,"r");
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab // get registry data
\par \tab \tab \tab RegQueryValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab \tab \tab   g_lpMsg,
\par \tab \tab \tab \tab \tab \tab   lpEnc,
\par \tab \tab \tab \tab \tab \tab   &cbSize);
\par \tab \tab \}
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(4):
\par 
\par \tab \tab // get string from file
\par \tab \tab GetTimeStampStringFromFile(lpEnc,
\par \tab \tab \tab \tab \tab \tab \tab \tab    GetStringDivision(lpTSLoc,7));
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par 
\par \tab case(5):
\par 
\par \tab \tab // get string from data file
\par \tab \tab GetTimeStampStringFromDataFile(lpEnc,
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab    GetStringDivision(lpTSLoc,8));
\par 
\par \tab \tab // ok
\par \tab \tab break;
\par \tab \}
\par 
\par \tab // decode timestamp
\par \tab (*lpTS)=DecodeTimeStamp(lpEnc);
\par 
\par \tab // check id
\par \tab if(lpTS->dwID!=dwUniID)
\par \tab \{
\par \tab \tab // set default values
\par \tab \tab lpTS->dwDaysLeft=TRIALDAYS_MAX;
\par \tab \tab lpTS->dwID=dwUniID;
\par \tab \tab lpTS->dwInstTimeHigh=NULL;
\par \tab \tab lpTS->dwInstTimeLow=NULL;
\par \tab \}
\par \}
\par 
\par // SortTimeStamps()
\par 
\par void SortTimeStamps(LPTIMESTAMP lpOut,
\par \tab \tab \tab \tab \tab LPTIMESTAMP lpTS,
\par \tab \tab \tab \tab \tab DWORD dwNumTS)
\par \{
\par \tab // counter
\par \tab DWORD dwCount;
\par 
\par \tab // current time
\par \tab FILETIME ft;
\par 
\par \tab // 64-bit time values
\par \tab QWORD qwInstTime;
\par \tab QWORD qwCurTime;
\par 
\par \tab // copy first timestamp
\par \tab (*lpOut)=lpTS[0];
\par 
\par \tab // sort through timestamps
\par \tab for(dwCount=1;dwCount<dwNumTS;dwCount++)
\par \tab \{
\par \tab \tab // set lowest days
\par \tab \tab if(lpTS[dwCount].dwDaysLeft<lpOut->dwDaysLeft)
\par \tab \tab \tab lpOut->dwDaysLeft=lpTS[dwCount].dwDaysLeft;
\par 
\par \tab \tab // set 64-bit date values
\par \tab \tab QWORD qwDateLow=(((QWORD)lpOut->dwInstTimeHigh)       <<32)+((QWORD)lpOut->dwInstTimeLow);
\par \tab \tab QWORD qwDateCur=(((QWORD)lpTS[dwCount].dwInstTimeHigh)<<32)+((QWORD)lpTS[dwCount].dwInstTimeLow);
\par 
\par \tab \tab // check for null date
\par \tab \tab if(qwDateCur!=NULL)
\par \tab \tab \{
\par \tab \tab \tab // compare values
\par \tab \tab \tab if(qwDateCur<qwDateLow)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // set new value
\par \tab \tab \tab \tab lpOut->dwInstTimeHigh=(DWORD)((qwDateCur&0xFFFFFFFF00000000I64)>>32);
\par \tab \tab \tab \tab lpOut->dwInstTimeLow =(DWORD)((qwDateCur&0x00000000FFFFFFFFI64));
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par 
\par \tab // get current time
\par \tab GetSystemTimeAsFileTime(&ft);
\par \tab 
\par \tab // check for null date
\par \tab if(lpOut->dwInstTimeHigh==NULL&&
\par \tab    lpOut->dwInstTimeLow ==NULL)
\par \tab \{
\par \tab \tab // set current date
\par \tab \tab lpOut->dwInstTimeHigh=ft.dwHighDateTime;
\par \tab \tab lpOut->dwInstTimeLow =ft.dwLowDateTime;
\par \tab \}
\par 
\par \tab // set current time
\par \tab qwCurTime=(((QWORD)ft.dwHighDateTime)<<32)+((QWORD)ft.dwLowDateTime);
\par 
\par \tab // get install time
\par \tab qwInstTime=(((QWORD)lpOut->dwInstTimeHigh)<<32)+((QWORD)lpOut->dwInstTimeLow);
\par 
\par \tab // compare current & install times
\par \tab if(qwCurTime<qwInstTime)
\par \tab \{
\par \tab \tab // cheater!!
\par \tab \tab lpOut->dwDaysLeft=0;
\par 
\par \tab \tab // ok
\par \tab \tab return;
\par \tab \}
\par 
\par \tab // compute days left based on install time
\par \tab DWORD dwDaysLeft=TRIALDAYS_MAX-((DWORD)((qwCurTime-qwInstTime)/CNSEC_PER_DAY));
\par 
\par \tab // check for overflow
\par \tab if(dwDaysLeft>TRIALDAYS_MAX)
\par \tab \{
\par \tab \tab // trial expired
\par \tab \tab lpOut->dwDaysLeft=0;
\par 
\par \tab \tab // ok
\par \tab \tab return;
\par \tab \}
\par 
\par \tab // set lowest days left
\par \tab if(dwDaysLeft<lpOut->dwDaysLeft)
\par \tab \tab lpOut->dwDaysLeft=dwDaysLeft;
\par \}
\par #else
\par void ResetTimeStamps(void)
\par \{
\par \tab // timestamps are located as follows:
\par \tab // (1): (win.ini)  [scr32_snl] sysid=~
\par \tab // (2): bwapps.ini [appcommon] inf32=~
\par \tab // (3): HK_LM/Software/ SLS/ProfileData
\par \tab // (4): HK_LM/Software/ Microsoft/74ABE3D7-BAF5-4ac2-B848-C655118023E5
\par \tab // (5): C:/Windows/     slrcs32.sbw (every other byte starting at #53)
\par \tab // (6): in swanlake.dat
\par 
\par \tab // timestamp locations
\par \tab LPSTR lpTSLoc=NULL;
\par 
\par \tab // allocate memory for locations
\par \tab if(!AllocMem((LPVOID*)&lpTSLoc,
\par \tab \tab \tab \tab  132))
\par \tab \tab return;
\par 
\par \tab // get timestamp locations
\par \tab GetTimeStampLocations(lpTSLoc);
\par 
\par \tab // reset location #1
\par \tab WriteProfileString(GetStringDivision(lpTSLoc,0),
\par \tab \tab \tab \tab \tab    GetStringDivision(lpTSLoc,1),
\par \tab \tab \tab \tab \tab    "q");
\par 
\par \tab // reset location #2
\par \tab WritePrivateProfileString(GetStringDivision(lpTSLoc,3),
\par \tab \tab \tab \tab \tab \tab \tab   GetStringDivision(lpTSLoc,4),
\par \tab \tab \tab \tab \tab \tab \tab   "w",
\par \tab \tab \tab \tab \tab \tab \tab   GetStringDivision(lpTSLoc,2));
\par 
\par \tab // prepare key string
\par \tab sprintf(g_lpMsg,
\par \tab \tab \tab "%s\\\\%s",
\par \tab \tab \tab "Software",
\par \tab \tab \tab GetStringDivision(lpTSLoc,5));
\par 
\par \tab // reset location #3
\par \tab RegSetValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab g_lpMsg,
\par \tab \tab \tab \tab REG_SZ,
\par \tab \tab \tab \tab "e",
\par \tab \tab \tab \tab 1);
\par 
\par \tab // prepare key string
\par \tab sprintf(g_lpMsg,
\par \tab \tab \tab "%s\\\\%s",
\par \tab \tab \tab "Software",
\par \tab \tab \tab GetStringDivision(lpTSLoc,6));
\par 
\par \tab // reset location #4
\par \tab RegSetValue(HKEY_LOCAL_MACHINE,
\par \tab \tab \tab \tab g_lpMsg,
\par \tab \tab \tab \tab REG_SZ,
\par \tab \tab \tab \tab "r",
\par \tab \tab \tab \tab 1);
\par 
\par \tab // reset location #5
\par \tab SetTimeStampStringToFile("t",
\par \tab \tab \tab \tab \tab \tab \tab  GetStringDivision(lpTSLoc,7));
\par 
\par \tab // reset location #6
\par \tab SetTimeStampStringToDataFile("y",
\par \tab \tab \tab \tab \tab \tab \tab \tab  GetStringDivision(lpTSLoc,8));
\par 
\par \tab // clear timestamp locations
\par \tab ClearTimeStampLocations(lpTSLoc,
\par \tab \tab \tab \tab \tab \tab \tab 132);
\par 
\par \tab // free memory for locations
\par \tab FreeMem((LPVOID*)&lpTSLoc);
\par \}
\par #endif
\par 
\par // eof //
\par 
\par // Copyright 2005 WaveBreak Software}{\f2 
\par }}